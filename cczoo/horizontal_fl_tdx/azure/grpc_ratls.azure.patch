diff --git a/BUILD b/BUILD
index 138120ed00..5a39d831ad 100644
--- a/BUILD
+++ b/BUILD
@@ -32,6 +32,7 @@ package(
 load(
     "//bazel:grpc_build_system.bzl",
     "grpc_cc_library",
+    "grpc_ratls_library",
     "grpc_generate_one_off_targets",
     "grpc_upb_proto_library",
     "python_config_settings",
@@ -82,6 +83,11 @@ config_setting(
     values = {"define": "use_strict_warning=true"},
 )
 
+config_setting(
+    name = "ra_tls_backend_default",
+    values = {"define": "backend=GRAMINE"},
+)
+
 python_config_settings()
 
 # This should be updated along with build_handwritten.yaml
@@ -293,6 +299,35 @@ GRPCXX_PUBLIC_HDRS = [
     "include/grpcpp/support/validate_service_config.h",
 ]
 
+GRPCXX_RA_TLS_HDRS = [
+    "include/grpcpp/security/sgx/cJSON.h",
+    "include/grpcpp/security/sgx/sgx_ra_tls.h",
+    "include/grpcpp/security/sgx/sgx_ra_tls_backends.h",
+    "include/grpcpp/security/sgx/sgx_ra_tls_context.h",
+    "include/grpcpp/security/sgx/sgx_ra_tls_impl.h",
+    "include/grpcpp/security/sgx/sgx_ra_tls_log.h",
+    "include/grpcpp/security/sgx/sgx_ra_tls_utils.h",
+    "src/cpp/sgx/azure_tdx/AttestClient.h",
+    "src/cpp/sgx/azure_tdx/Utils.h",
+    "src/cpp/sgx/azure_tdx/Logger.h",
+    "src/cpp/sgx/azure_tdx/HttpClient_I.h",
+    "src/cpp/sgx/azure_tdx/HttpClient.h",
+]
+
+GRPCXX_RA_TLS_SRCS = [
+    "src/cpp/sgx/azure_tdx/HttpClient.cpp",
+    "src/cpp/sgx/cJSON.c",
+    "src/cpp/sgx/sgx_ra_tls_credentials.cc",
+    "src/cpp/sgx/sgx_ra_tls_options.cc",
+    "src/cpp/sgx/sgx_ra_tls_backends.cc",
+    "src/cpp/sgx/sgx_ra_tls_gramine.cc",
+    "src/cpp/sgx/sgx_ra_tls_occlum.cc",
+    "src/cpp/sgx/sgx_ra_tls_tdx.cc",
+    "src/cpp/sgx/sgx_ra_tls_dummy.cc",
+    "src/cpp/sgx/sgx_ra_tls_impl.cc",
+    "src/cpp/sgx/sgx_ra_tls_utils.cc",
+]
+
 grpc_cc_library(
     name = "gpr",
     language = "c++",
@@ -364,14 +399,16 @@ grpc_cc_library(
 
 grpc_cc_library(
     name = "grpc++",
+    standalone = True,
+    language = "c++",
     hdrs = [
         "src/cpp/client/secure_credentials.h",
         "src/cpp/common/secure_auth_context.h",
         "src/cpp/common/tls_credentials_options_util.h",
         "src/cpp/server/secure_server_credentials.h",
     ],
-    language = "c++",
     public_hdrs = GRPCXX_PUBLIC_HDRS,
+    deps = ["grpc++_internals", "grpc++_ra_tls"],
     select_deps = {
         "grpc_no_xds": [],
         "//conditions:default": [
@@ -379,10 +416,26 @@ grpc_cc_library(
             "grpc++_xds_server",
         ],
     },
+)
+
+grpc_ratls_library(
+    name = "grpc++_ra_tls",
     standalone = True,
+    language = "c++",
+    hdrs = [
+        "src/cpp/client/secure_credentials.h",
+        "src/cpp/common/secure_auth_context.h",
+        "src/cpp/common/tls_credentials_options_util.h",
+        "src/cpp/server/secure_server_credentials.h",
+    ],
+    public_hdrs = GRPCXX_RA_TLS_HDRS,
+    srcs = GRPCXX_RA_TLS_SRCS,
     deps = [
         "grpc++_internals",
     ],
+    select_deps = {
+        "//conditions:default": [],
+    },
 )
 
 grpc_cc_library(
diff --git a/CMakeLists.txt b/CMakeLists.txt
index eeaf0b43c7..d736b2f9b0 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -49,6 +49,38 @@ option(gRPC_BUILD_CODEGEN "Build codegen" ON)
 option(gRPC_BUILD_CSHARP_EXT "Build C# extensions" ON)
 option(gRPC_BACKWARDS_COMPATIBILITY_MODE "Build libraries that are binary compatible across a larger number of OS and libc versions" OFF)
 
+# RA-TLS
+option(SGX_RA_TLS_BACKEND "Default SGX RA-TLS Backend" "GRAMINE")
+
+if(SGX_RA_TLS_BACKEND STREQUAL "GRAMINE")
+  message("SGX_RA_TLS_GRAMINE_BACKEND is defined")
+  add_definitions(-DSGX_RA_TLS_GRAMINE_BACKEND)
+elseif(SGX_RA_TLS_BACKEND STREQUAL "OCCLUM")
+  message("SGX_RA_TLS_OCCLUM_BACKEND is defined")
+  add_definitions(-DSGX_RA_TLS_OCCLUM_BACKEND)
+elseif(SGX_RA_TLS_BACKEND STREQUAL "TDX")
+  message("SGX_RA_TLS_TDX_BACKEND is defined")
+  add_definitions(-DSGX_RA_TLS_TDX_BACKEND)
+  option(INTEL_SGXSDK_INCLUDE "Intel SGXSDK INCLUDE DIR" "/opt/intel/sgxsdk/include")
+  include_directories($ENV{INTEL_SGXSDK_INCLUDE})
+elseif(SGX_RA_TLS_BACKEND STREQUAL "AZURE_TDX")
+  message("SGX_RA_TLS_AZURE_TDX_BACKEND is defined")
+  add_definitions(-DSGX_RA_TLS_AZURE_TDX_BACKEND)
+elseif(SGX_RA_TLS_BACKEND STREQUAL "DUMMY")
+  message("SGX_RA_TLS_DUMMY_BACKEND is defined")
+  add_definitions(-DSGX_RA_TLS_DUMMY_BACKEND)
+endif()
+
+option(SGX_RA_TLS_SDK "Default SGX RA-TLS SDK" "DEFAULT")
+
+if(SGX_RA_TLS_SDK STREQUAL "DEFAULT")
+  message("SGX_RA_TLS_DEFAULT_SDK is defined")
+  add_definitions(-DSGX_RA_TLS_DEFAULT_SDK)
+elseif(SGX_RA_TLS_SDK STREQUAL "LIBRATS")
+  message("SGX_RA_TLS_LIBRATS_SDK is defined")
+  add_definitions(-DSGX_RA_TLS_LIBRATS_SDK)
+endif()
+
 set(gRPC_INSTALL_default ON)
 if(NOT CMAKE_SOURCE_DIR STREQUAL CMAKE_CURRENT_SOURCE_DIR)
   # Disable gRPC_INSTALL by default if building as a submodule
@@ -2064,6 +2096,7 @@ target_include_directories(grpc
     ${_gRPC_XXHASH_INCLUDE_DIR}
     ${_gRPC_ZLIB_INCLUDE_DIR}
 )
+
 target_link_libraries(grpc
   ${_gRPC_BASELIB_LIBRARIES}
   ${_gRPC_ZLIB_LIBRARIES}
@@ -2080,6 +2113,7 @@ target_link_libraries(grpc
   ${_gRPC_SSL_LIBRARIES}
   address_sorting
 )
+
 if(_gRPC_PLATFORM_IOS OR _gRPC_PLATFORM_MAC)
   target_link_libraries(grpc "-framework CoreFoundation")
 endif()
@@ -2775,6 +2809,17 @@ add_library(grpc++
   src/cpp/util/status.cc
   src/cpp/util/string_ref.cc
   src/cpp/util/time_cc.cc
+  src/cpp/sgx/azure_tdx/HttpClient.cpp
+  src/cpp/sgx/cJSON.c
+  src/cpp/sgx/sgx_ra_tls_credentials.cc
+  src/cpp/sgx/sgx_ra_tls_options.cc
+  src/cpp/sgx/sgx_ra_tls_backends.cc
+  src/cpp/sgx/sgx_ra_tls_gramine.cc
+  src/cpp/sgx/sgx_ra_tls_occlum.cc
+  src/cpp/sgx/sgx_ra_tls_tdx.cc
+  src/cpp/sgx/sgx_ra_tls_dummy.cc
+  src/cpp/sgx/sgx_ra_tls_impl.cc
+  src/cpp/sgx/sgx_ra_tls_utils.cc
 )
 
 set_target_properties(grpc++ PROPERTIES
@@ -2813,6 +2858,31 @@ target_link_libraries(grpc++
   ${_gRPC_ALLTARGETS_LIBRARIES}
   grpc
 )
+if(SGX_RA_TLS_BACKEND STREQUAL "GRAMINE")
+  target_link_libraries(grpc++
+    libmbedx509_gramine.a
+    libmbedcrypto_gramine.a
+  )
+elseif(SGX_RA_TLS_BACKEND STREQUAL "OCCLUM")
+  target_link_libraries(grpc++
+    libdcap_quote.a
+  )
+elseif(SGX_RA_TLS_BACKEND STREQUAL "TDX")
+  target_link_libraries(grpc++
+    tdx_attest
+    sgx_dcap_quoteverify
+    sgx_urts
+  )
+elseif(SGX_RA_TLS_BACKEND STREQUAL "AZURE_TDX")
+  target_link_libraries(grpc++
+    azguestattestation
+    curl
+  )
+elseif(SGX_RA_TLS_BACKEND STREQUAL "DUMMY")
+  target_link_libraries(grpc++
+    ""
+  )
+endif()
 
 foreach(_hdr
   include/grpc++/alarm.h
@@ -2973,6 +3043,14 @@ foreach(_hdr
   include/grpcpp/security/server_credentials.h
   include/grpcpp/security/tls_certificate_provider.h
   include/grpcpp/security/tls_credentials_options.h
+  include/grpcpp/security/sgx/cJSON.h
+  include/grpcpp/security/sgx/sgx_ra_tls.h
+  include/grpcpp/security/sgx/sgx_ra_tls_options.h
+  include/grpcpp/security/sgx/sgx_ra_tls_backends.h
+  include/grpcpp/security/sgx/sgx_ra_tls_context.h
+  include/grpcpp/security/sgx/sgx_ra_tls_impl.h
+  include/grpcpp/security/sgx/sgx_ra_tls_log.h
+  include/grpcpp/security/sgx/sgx_ra_tls_utils.h
   include/grpcpp/server.h
   include/grpcpp/server_builder.h
   include/grpcpp/server_context.h
@@ -3620,6 +3698,8 @@ foreach(_hdr
   include/grpcpp/security/server_credentials.h
   include/grpcpp/security/tls_certificate_provider.h
   include/grpcpp/security/tls_credentials_options.h
+  include/grpcpp/security/sgx/sgx_ra_tls.h
+  include/grpcpp/security/sgx/sgx_ra_tls_options.h
   include/grpcpp/server.h
   include/grpcpp/server_builder.h
   include/grpcpp/server_context.h
diff --git a/azure_tdx_config.json b/azure_tdx_config.json
new file mode 100644
index 0000000000..f24ab96fe9
--- /dev/null
+++ b/azure_tdx_config.json
@@ -0,0 +1,5 @@
+{
+  "attestation_url": "https://api.projectamber.intel.com/appraisal/v1/attest",
+  "attestation_provider": "amber",
+  "api_key": ""
+}
diff --git a/bazel/grpc_build_system.bzl b/bazel/grpc_build_system.bzl
index 85ec2d6b27..e0a88f2347 100644
--- a/bazel/grpc_build_system.bzl
+++ b/bazel/grpc_build_system.bzl
@@ -25,8 +25,10 @@
 
 load("//bazel:cc_grpc_library.bzl", "cc_grpc_library")
 load("//bazel:copts.bzl", "GRPC_DEFAULT_COPTS")
+load("//bazel:ratls.bzl", "RA_TLS_BACKEND")
 load("@upb//bazel:upb_proto_library.bzl", "upb_proto_library")
 load("@build_bazel_rules_apple//apple:ios.bzl", "ios_unit_test")
+# load("@bazel_skylib//rules:common_settings.bzl", "string_flag")
 
 # The set of pollers to test against if a test exercises polling
 POLLERS = ["epollex", "epoll1", "poll"]
@@ -128,6 +130,88 @@ def grpc_cc_library(
         linkstatic = linkstatic,
     )
 
+def grpc_ratls_library(
+        name,
+        srcs = [],
+        public_hdrs = [],
+        hdrs = [],
+        external_deps = [],
+        defines = [],
+        deps = [],
+        select_deps = None,
+        standalone = False,
+        language = "C++",
+        testonly = False,
+        visibility = None,
+        alwayslink = 0,
+        data = [],
+        use_cfstream = False,
+        tags = [],
+        linkstatic = False):
+    copts = []
+    if use_cfstream:
+        copts = if_mac(["-DGRPC_CFSTREAM"])
+    if language.upper() == "C":
+        copts = copts + if_not_windows(["-std=c99"])
+
+    linkopts = if_not_windows(["-pthread"])
+    if use_cfstream:
+        linkopts = linkopts + if_mac(["-framework CoreFoundation"])
+
+    if select_deps:
+        deps += select(select_deps)
+
+    includes = []
+    flags = ["-L/usr/local/lib", "-ldl"]
+    backend = RA_TLS_BACKEND
+    print("RA-TLS Backend: ", backend);
+    if backend == "GRAMINE":
+        flags += ["-DSGX_RA_TLS_GRAMINE_BACKEND=1", "-lmbedx509_gramine", "-lmbedcrypto_gramine"]
+    elif backend == "OCCLUM":
+        flags += ["-DSGX_RA_TLS_OCCLUM_BACKEND=1", "-ldcap_quote"]
+    elif backend == "TDX":
+        flags += ["-DSGX_RA_TLS_TDX_BACKEND=1", "-ltdx_attest", "-lsgx_dcap_quoteverify", "-lsgx_urts"]
+        includes += ["/opt/intel/sgxsdk/include"]
+    elif backend == "AZURE_TDX":
+        flags += ["-DSGX_RA_TLS_AZURE_TDX_BACKEND=1", "-lazguestattestation", "-lcurl"]
+    else:
+        flags += ["-DSGX_RA_TLS_DUMMY_BACKEND=1"]
+        pass
+
+    native.cc_library(
+        name = name,
+        srcs = srcs,
+        defines = defines +
+                  select({
+                      "//:grpc_no_ares": ["GRPC_ARES=0"],
+                      "//conditions:default": [],
+                  }) +
+                  select({
+                      "//:remote_execution": ["GRPC_PORT_ISOLATED_RUNTIME=1"],
+                      "//conditions:default": [],
+                  }) +
+                  select({
+                      "//:grpc_allow_exceptions": ["GRPC_ALLOW_EXCEPTIONS=1"],
+                      "//:grpc_disallow_exceptions": ["GRPC_ALLOW_EXCEPTIONS=0"],
+                      "//conditions:default": [],
+                  }),
+        hdrs = hdrs + public_hdrs,
+        deps = deps + _get_external_deps(external_deps),
+        copts = GRPC_DEFAULT_COPTS + copts + flags,
+        visibility = visibility,
+        testonly = testonly,
+        linkopts = linkopts + flags,
+        includes = includes + [
+            "include",
+            "src/core/ext/upb-generated",  # Once upb code-gen issue is resolved, remove this.
+            "src/core/ext/upbdefs-generated",  # Once upb code-gen issue is resolved, remove this.
+        ],
+        alwayslink = alwayslink,
+        data = data,
+        tags = tags,
+        linkstatic = linkstatic,
+    )
+
 def grpc_proto_plugin(name, srcs = [], deps = []):
     native.cc_binary(
         name = name,
diff --git a/bazel/ratls.bzl b/bazel/ratls.bzl
new file mode 100644
index 0000000000..3041187b23
--- /dev/null
+++ b/bazel/ratls.bzl
@@ -0,0 +1 @@
+RA_TLS_BACKEND = "AZURE_TDX"
\ No newline at end of file
diff --git a/bazel_build_cpp.sh b/bazel_build_cpp.sh
new file mode 100755
index 0000000000..1ddca0356a
--- /dev/null
+++ b/bazel_build_cpp.sh
@@ -0,0 +1,35 @@
+#
+# Copyright (c) 2022 Intel Corporation
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+set -ex
+
+export ABSEIL_PATH=${GRPC_PATH}/third_party/abseil-cpp
+
+if [ -z ${BUILD_TYPE} ]; then
+    export BUILD_TYPE=Debug
+fi
+
+if [ -z ${SGX_RA_TLS_BACKEND} ]; then
+    export SGX_RA_TLS_BACKEND=GRAMINE # GRAMINE,OCCLUM,TDX,DUMMY
+fi
+
+cd ${GRPC_PATH}
+
+echo 'RA_TLS_BACKEND = "'${SGX_RA_TLS_BACKEND}'"' > ${GRPC_PATH}/bazel/ratls.bzl
+cat ${GRPC_PATH}/bazel/ratls.bzl
+
+bazel build //:all --sandbox_debug -s -c dbg
+
+cd -
diff --git a/build_cpp.sh b/build_cpp.sh
new file mode 100755
index 0000000000..f4c73cc8ea
--- /dev/null
+++ b/build_cpp.sh
@@ -0,0 +1,66 @@
+#
+# Copyright (c) 2022 Intel Corporation
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+set -ex
+
+export ABSEIL_PATH=${GRPC_PATH}/third_party/abseil-cpp
+
+if [ -z ${BUILD_TYPE} ]; then
+    export BUILD_TYPE=Debug
+fi
+
+if [ -z ${SGX_RA_TLS_BACKEND} ]; then
+    export SGX_RA_TLS_BACKEND=GRAMINE # GRAMINE,OCCLUM,DUMMY
+fi
+
+if [ -z ${SGX_RA_TLS_SDK} ]; then
+    export SGX_RA_TLS_SDK=DEFAULT # DEFAULT,LIBRATS
+elif [ "${SGX_RA_TLS_SDK}" == "LIBRATS" ]; then
+    ${GRPC_PATH}/build_librats_sdk.sh
+fi
+
+# build and install abseil library
+# https://abseil.io/docs/cpp/quickstart-cmake.html
+if [ ! -d "${ABSEIL_PATH}/build" ]; then
+    mkdir -p ${ABSEIL_PATH}/build
+    cd ${ABSEIL_PATH}/build
+    cmake -DCMAKE_CXX_STANDARD=11 \
+          -DCMAKE_POSITION_INDEPENDENT_CODE=TRUE \
+          -DCMAKE_BUILD_TYPE=${BUILD_TYPE} \
+          -DCMAKE_INSTALL_PREFIX=${INSTALL_PREFIX} \
+          ..
+    make -j `nproc`
+    make install
+    cd -
+fi
+
+# build and install grpc library
+mkdir -p ${GRPC_PATH}/build
+cd ${GRPC_PATH}/build
+cmake -DgRPC_INSTALL=ON \
+      -DgRPC_ABSL_PROVIDER=package \
+      -DgRPC_BUILD_TESTS=OFF \
+      -DgRPC_BUILD_CSHARP_EXT=OFF \
+      -DgRPC_BUILD_GRPC_CSHARP_PLUGIN=OFF \
+      -DgRPC_BUILD_GRPC_PHP_PLUGIN=OFF \
+      -DgRPC_BUILD_GRPC_RUBY_PLUGIN=OFF \
+      -DCMAKE_BUILD_TYPE=${BUILD_TYPE} \
+      -DCMAKE_INSTALL_PREFIX=${INSTALL_PREFIX} \
+      -DSGX_RA_TLS_SDK=${SGX_RA_TLS_SDK} \
+      -DSGX_RA_TLS_BACKEND=${SGX_RA_TLS_BACKEND} \
+      ..
+make -j `nproc`
+make install
+cd -
diff --git a/build_librats_sdk.sh b/build_librats_sdk.sh
new file mode 100755
index 0000000000..1dab0022ef
--- /dev/null
+++ b/build_librats_sdk.sh
@@ -0,0 +1,29 @@
+#
+# Copyright (c) 2022 Intel Corporation
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+set -ex
+
+export LIBRATS_ROOT=${GRPC_PATH}/build/librats
+
+if [ ! -d "${LIBRATS_ROOT}" ]; then
+    git clone https://github.com/inclavare-containers/librats.git ${LIBRATS_ROOT}
+fi
+
+cd ${LIBRATS_ROOT}
+
+cmake -DRATS_BUILD_MODE="occlum" -H. -Bbuild
+make -C build install
+
+cd -
diff --git a/build_python.sh b/build_python.sh
new file mode 100755
index 0000000000..ed36a3bde3
--- /dev/null
+++ b/build_python.sh
@@ -0,0 +1,47 @@
+#
+# Copyright (c) 2022 Intel Corporation
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+set -ex
+
+if [ -z ${DEBUG} ]; then
+    export DEBUG=1
+fi
+
+if [ -z ${SGX_RA_TLS_BACKEND} ]; then
+    export SGX_RA_TLS_BACKEND=GRAMINE # GRAMINE,OCCLUM,TDX,DUMMY
+fi
+
+if [ -z ${SGX_RA_TLS_SDK} ]; then
+    export SGX_RA_TLS_SDK=DEFAULT # DEFAULT,LIBRATS
+fi
+
+# build grpc c / cpp library
+${GRPC_PATH}/cmake_build_cpp.sh
+
+# build grpc python wheel
+cd ${GRPC_PATH}
+rm -rf python_build None src/python/grpcio/__pycache__ src/python/grpcio/grpc/_cython/cygrpc.cpp
+SGX_RA_TLS_BACKEND=${SGX_RA_TLS_BACKEND} python3 -c "import os; print(os.getenv('SGX_RA_TLS_BACKEND'))"
+SGX_RA_TLS_BACKEND=${SGX_RA_TLS_BACKEND} python3 setup.py bdist_wheel
+cd -
+
+ldd ${GRPC_PATH}/python_build/lib.linux-x86_64-*/grpc/_cython/cygrpc.cpython-*-x86_64-linux-gnu.so
+
+# install grpc python wheel
+pip3 uninstall -y grpcio protobuf
+pip3 install ${GRPC_PATH}/dist/*.whl
+pip3 install grpcio-tools==1.38.1
+
+python3 -u -c "import grpc"
diff --git a/cmake_build_cpp.sh b/cmake_build_cpp.sh
new file mode 100755
index 0000000000..a7c24883e2
--- /dev/null
+++ b/cmake_build_cpp.sh
@@ -0,0 +1,64 @@
+#
+# Copyright (c) 2022 Intel Corporation
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+set -ex
+
+export ABSEIL_PATH=${GRPC_PATH}/third_party/abseil-cpp
+
+if [ -z ${BUILD_TYPE} ]; then
+    export BUILD_TYPE=Debug
+fi
+
+if [ -z ${SGX_RA_TLS_BACKEND} ]; then
+    export SGX_RA_TLS_BACKEND=GRAMINE # GRAMINE,OCCLUM,TDX,DUMMY
+fi
+
+if [ -z ${SGX_RA_TLS_SDK} ]; then
+    export SGX_RA_TLS_SDK=DEFAULT # DEFAULT,LIBRATS
+elif [ "${SGX_RA_TLS_SDK}" == "LIBRATS" ]; then
+    ${GRPC_PATH}/build_librats_sdk.sh
+fi
+
+# build and install abseil library
+# https://abseil.io/docs/cpp/quickstart-cmake.html
+mkdir -p ${ABSEIL_PATH}/build
+cd ${ABSEIL_PATH}/build
+cmake -DCMAKE_CXX_STANDARD=11 \
+        -DCMAKE_POSITION_INDEPENDENT_CODE=TRUE \
+        -DCMAKE_BUILD_TYPE=${BUILD_TYPE} \
+        -DCMAKE_INSTALL_PREFIX=${INSTALL_PREFIX} \
+        ..
+make -j `nproc`
+make install
+cd -
+
+# build and install grpc library
+mkdir -p ${GRPC_PATH}/build
+cd ${GRPC_PATH}/build
+cmake -DgRPC_INSTALL=ON \
+      -DgRPC_ABSL_PROVIDER=package \
+      -DgRPC_BUILD_TESTS=OFF \
+      -DgRPC_BUILD_CSHARP_EXT=OFF \
+      -DgRPC_BUILD_GRPC_CSHARP_PLUGIN=OFF \
+      -DgRPC_BUILD_GRPC_PHP_PLUGIN=OFF \
+      -DgRPC_BUILD_GRPC_RUBY_PLUGIN=OFF \
+      -DCMAKE_BUILD_TYPE=${BUILD_TYPE} \
+      -DCMAKE_INSTALL_PREFIX=${INSTALL_PREFIX} \
+      -DSGX_RA_TLS_SDK=${SGX_RA_TLS_SDK} \
+      -DSGX_RA_TLS_BACKEND=${SGX_RA_TLS_BACKEND} \
+      ..
+make -j `nproc`
+make install
+cd -
diff --git a/dynamic_config.json b/dynamic_config.json
new file mode 100644
index 0000000000..71870f94bd
--- /dev/null
+++ b/dynamic_config.json
@@ -0,0 +1,14 @@
+{
+    "verify_mr_enclave" : "on",
+    "verify_mr_signer" : "on",
+    "verify_isv_prod_id" : "on",
+    "verify_isv_svn" : "on",
+    "sgx_mrs": [
+        {
+            "mr_enclave" : "",
+            "mr_signer" : "",
+            "isv_prod_id" : "0",
+            "isv_svn" : "0"
+        }
+    ]
+}
diff --git a/examples/cpp/attestation/BUILD b/examples/cpp/attestation/BUILD
new file mode 100644
index 0000000000..ea3abe2943
--- /dev/null
+++ b/examples/cpp/attestation/BUILD
@@ -0,0 +1,42 @@
+# Copyright 2020 the gRPC authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+licenses(["notice"])  # 3-clause BSD
+
+cc_binary(
+    name = "server",
+    srcs = [
+        "server.cc",
+        "getopt.hpp",
+    ],
+    defines = ["BAZEL_BUILD"],
+    deps = [
+        "//:grpc++",
+        "//:grpc++_reflection",
+        "//examples/protos:secretmanager_proto",
+    ],
+)
+
+cc_binary(
+    name = "client",
+    srcs = [
+        "client.cc",
+        "getopt.hpp",
+    ],
+    defines = ["BAZEL_BUILD"],
+    deps = [
+        "//:grpc++",
+        "//examples/protos:secretmanager_proto",
+    ],
+)
diff --git a/examples/cpp/attestation/CMakeLists.txt b/examples/cpp/attestation/CMakeLists.txt
new file mode 100644
index 0000000000..b92b6a12cd
--- /dev/null
+++ b/examples/cpp/attestation/CMakeLists.txt
@@ -0,0 +1,62 @@
+# Copyright (c) 2022 Intel Corporation
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+cmake_minimum_required(VERSION 3.5.1)
+
+project(RA-TLS C CXX)
+
+include(../cmake/common.cmake)
+
+# Proto file
+get_filename_component(hw_proto "../../protos/secretmanager.proto" ABSOLUTE)
+get_filename_component(hw_proto_path "${hw_proto}" PATH)
+
+# Generated sources
+set(hw_proto_srcs "${CMAKE_CURRENT_BINARY_DIR}/secretmanager.pb.cc")
+set(hw_proto_hdrs "${CMAKE_CURRENT_BINARY_DIR}/secretmanager.pb.h")
+set(hw_grpc_srcs "${CMAKE_CURRENT_BINARY_DIR}/secretmanager.grpc.pb.cc")
+set(hw_grpc_hdrs "${CMAKE_CURRENT_BINARY_DIR}/secretmanager.grpc.pb.h")
+add_custom_command(
+      OUTPUT "${hw_proto_srcs}" "${hw_proto_hdrs}" "${hw_grpc_srcs}" "${hw_grpc_hdrs}"
+      COMMAND ${_PROTOBUF_PROTOC}
+      ARGS --grpc_out "${CMAKE_CURRENT_BINARY_DIR}"
+        --cpp_out "${CMAKE_CURRENT_BINARY_DIR}"
+        -I "${hw_proto_path}"
+        --plugin=protoc-gen-grpc="${_GRPC_CPP_PLUGIN_EXECUTABLE}"
+        "${hw_proto}"
+      DEPENDS "${hw_proto}")
+
+# Include generated *.pb.h files
+include_directories("${CMAKE_CURRENT_BINARY_DIR}")
+
+# hw_grpc_proto
+add_library(hw_grpc_proto
+  ${hw_grpc_srcs}
+  ${hw_grpc_hdrs}
+  ${hw_proto_srcs}
+  ${hw_proto_hdrs})
+target_link_libraries(hw_grpc_proto
+  ${_REFLECTION}
+  ${_GRPC_GRPCPP}
+  ${_PROTOBUF_LIBPROTOBUF})
+
+# Targets greeter_[async_](client|server)
+foreach(_target client server)
+  add_executable(${_target} "${_target}.cc")
+  target_link_libraries(${_target}
+    hw_grpc_proto
+    ${_REFLECTION}
+    ${_GRPC_GRPCPP}
+    ${_PROTOBUF_LIBPROTOBUF})
+endforeach()
diff --git a/examples/cpp/attestation/README.md b/examples/cpp/attestation/README.md
new file mode 100644
index 0000000000..d2d81cc6a0
--- /dev/null
+++ b/examples/cpp/attestation/README.md
@@ -0,0 +1,7 @@
+# gRPC
+
+## Quick Start
+
+```
+./build.sh
+```
diff --git a/examples/cpp/attestation/build.sh b/examples/cpp/attestation/build.sh
new file mode 100755
index 0000000000..05581b74b4
--- /dev/null
+++ b/examples/cpp/attestation/build.sh
@@ -0,0 +1,62 @@
+#
+# Copyright (c) 2022 Intel Corporation
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+set -ex
+
+export EXP_PATH=`dirname $0`
+export EXP_NAME=examples/cpp/attestation
+
+if [ -z ${BUILD_TYPE} ]; then
+    export BUILD_TYPE=Debug
+    export COMPILATION_MODE=dbg
+fi
+
+if [ -z ${SGX_RA_TLS_BACKEND} ]; then
+    export SGX_RA_TLS_BACKEND=GRAMINE # GRAMINE,OCCLUM,TDX,AZURE_TDX,DUMMY
+fi
+
+if [ -z ${SGX_RA_TLS_SDK} ]; then
+    export SGX_RA_TLS_SDK=DEFAULT # DEFAULT,LIBRATS
+fi
+
+# build grpc package
+${GRPC_PATH}/cmake_build_cpp.sh
+# ${GRPC_PATH}/bazel_build_cpp.sh
+
+# build c++ example
+cd ${EXP_PATH}
+
+mkdir -p build
+cd build
+touch .bazelignore
+../generate_ssl.sh -s localhost -a my_ca
+cp ${GRPC_PATH}/dynamic_config.json .
+cp ../secret.json .
+cd -
+
+# build with cmake
+cd build
+cmake -D CMAKE_PREFIX_PATH=${INSTALL_PREFIX} \
+      -D CMAKE_BUILD_TYPE=${BUILD_TYPE} \
+      -D GRPC_AS_SUBMODULE=OFF \
+      -D GRPC_FETCHCONTENT=OFF ..
+make -j `nproc`
+cd -
+
+# build with bazel
+# bazel build :all -c dbg
+# cp ${GRPC_PATH}/bazel-bin/${EXP_NAME}/server ${GRPC_PATH}/bazel-bin/${EXP_NAME}/client build
+
+cd -
diff --git a/examples/cpp/attestation/client.cc b/examples/cpp/attestation/client.cc
new file mode 100644
index 0000000000..a8e766f300
--- /dev/null
+++ b/examples/cpp/attestation/client.cc
@@ -0,0 +1,100 @@
+/*
+ *
+ * Copyright (c) 2022 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+#include <grpcpp/grpcpp.h>
+#include <grpcpp/security/sgx/sgx_ra_tls.h>
+
+#ifdef BAZEL_BUILD
+#include "examples/protos/secretmanager.grpc.pb.h"
+#else
+#include "secretmanager.grpc.pb.h"
+#endif
+
+#include "getopt.hpp"
+
+struct argparser {
+    std::string server_address;
+    std::string root_cert;
+    std::string key;
+    argparser() {
+        server_address = getarg("localhost:70051", "-host", "--host");
+        root_cert = getarg("ca.crt", "-ca", "--root_cert");
+        key = getarg("", "-key", "--key");
+    };
+};
+
+std::string read_file(const char *file_path) {
+    std::ifstream in(file_path, std::ios::in);
+    std::ostringstream out;
+    out << in.rdbuf();
+    return std::string(out.str());
+}
+
+std::string read_file(std::string file_path) {
+    return read_file(file_path.c_str());
+}
+
+class SecretClient {
+    public:
+        SecretClient(std::shared_ptr<grpc::Channel> channel) : stub_(Attestation::SecretManger::NewStub(channel)) {}
+
+        std::string GetSecret(const std::string& key) {
+            grpc::ClientContext context;
+            Attestation::SecretReply reply;
+            Attestation::SecretRequest request;
+
+            auto cert = grpc::sgx::ra_tls_generate_key_cert(0)[1];
+
+            request.set_key(key);
+            request.set_ctx(cert);
+
+            grpc::Status status = stub_->GetSecret(&context, request, &reply);
+
+            if (status.ok()) {
+                return reply.value();
+            } else {
+                std::cout << "Error code: " << status.error_code() << ", message: " << status.error_message() << std::endl;
+                return "RPC failed";
+            }
+        }
+
+    private:
+        std::unique_ptr<Attestation::SecretManger::Stub> stub_;
+};
+
+void run_client() {
+    argparser args;
+
+    grpc::SslCredentialsOptions options;
+    options.pem_root_certs  = read_file(args.root_cert);
+    options.pem_cert_chain  = "";
+    options.pem_private_key = "";
+
+    auto creds = grpc::SslCredentials(options);
+    auto channel = grpc::CreateChannel(args.server_address, creds);
+
+    SecretClient client(channel);
+
+    std::string value = client.GetSecret(args.key);
+    std::cout << "Secret received: " << value << std::endl;
+};
+
+int main(int argc, char** argv) {
+    run_client();
+    return 0;
+}
diff --git a/examples/cpp/attestation/generate_ssl.sh b/examples/cpp/attestation/generate_ssl.sh
new file mode 100755
index 0000000000..d4733ed9bd
--- /dev/null
+++ b/examples/cpp/attestation/generate_ssl.sh
@@ -0,0 +1,30 @@
+CA_CN="My Cert Authority"
+SERVER_CN=""
+
+while getopts ":a:s:" opt
+do
+    case $opt in
+        a)
+        echo "////////CA CN:$OPTARG////////"
+        CA_CN=$OPTARG
+        ;;
+        s)
+        echo "////////Server CN:$OPTARG////////"
+        SERVER_CN=$OPTARG
+        ;;
+        ?)
+        echo "////////Undefined:$OPTARG////////"
+        exit 1;;
+    esac
+done
+
+# Generate CA Key and Certificate
+openssl req -x509 -sha256 -newkey rsa:4096 -keyout ca.key -out ca.crt -days 356 -nodes -subj "/CN=${CA_CN}"
+
+# Generate Server Key
+openssl req -new -newkey rsa:4096 -keyout server.key -out server.csr -nodes -subj "/CN=${SERVER_CN}"
+
+# Sign Server Certificate with CA Certificate
+openssl x509 -req -sha256 -days 365 -in server.csr -CA ca.crt -CAkey ca.key -set_serial 01 -out server.crt
+
+chmod 600 -R *.key
diff --git a/examples/cpp/attestation/getopt.hpp b/examples/cpp/attestation/getopt.hpp
new file mode 100644
index 0000000000..2fe8e3a3ac
--- /dev/null
+++ b/examples/cpp/attestation/getopt.hpp
@@ -0,0 +1,316 @@
+// Simple getopt replacement class (C++11). 
+// - rlyeh, zlib/libpng licensed.
+// https://github.com/r-lyeh-archived/getopt/blob/master/getopt.hpp
+
+// Two APIs provided:
+//
+// 1) Simple functional api `getarg(...)`. 
+//    - No initialization required: (argc, argv) pair automatically retrieved.
+//    - First argument is default option value, then all option indentifiers follow.
+//
+// int main() {
+//     bool help = getarg( false, "-h", "--help", "-?" );
+//     int version = getarg( 0, "-v", "--version", "--show-version" );
+//     int depth = getarg( 1, "-d", "--depth", "--max-depth");
+//     std::string file = getarg( "", "-f", "--file" );
+//     [...]
+// }
+//
+// 2) Simple OOP map-based api `getopt class`. Initialization (argc, argv) pair required.
+//
+//    This getopt class is a std::map replacement where key/value are std::string types.
+//    Given invokation './app.out --user=me --pass=123 -h' this class delivers not only:
+//    map[0] = "./app.out", map[1] = "--user=me", map[2]="--pass=123", map[3]='-h'
+//    but also, map["--user"]="me", map["--pass"]="123" and also, map["-h"]=true
+//
+//    Additional API:
+//    - .cmdline() for a print app invokation string
+//    - .str() for pretty map printing
+//    - .size() number of arguments (equivalent to argc), rather than std::map.size()
+//
+// int main( int argc, const char **argv ) {
+//     getopt args( argc, argv );
+//     if( args.has("-h") || args.has("--help") || args.has("-?") || args.size() == 1 ) {
+//         std::cout << args["0"] << " [-?|-h|--help] [-v|--version] [--depth=number]" << std::endl;
+//         return 0;
+//     }
+//     if( args.has("-v") || args.has("--version") ) {
+//         std::cout << args["0"] << " sample v1.0.0. Compiled on " << __DATE__ << std::endl;
+//     }
+//     if( args.has("--depth") ) {
+//         int depth = atoi( args["--depth"].c_str() );
+//         std::cout << "depth set to " << depth << std::endl;
+//     }
+//     [...]
+// }
+
+#pragma once
+#include <map>
+#include <string>
+#include <sstream>
+#include <vector>
+
+#ifdef _WIN32
+#include <io.h>
+#include <winsock2.h>
+#include <shellapi.h>
+#pragma comment(lib, "Shell32.lib")
+#else
+#include <fstream>
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sstream>
+#endif
+
+#define GETOPT_VERSION "1.0.0" // (2016/04/18) Initial version
+
+namespace getopt_utils
+{
+    // string conversion
+
+    template< typename T >
+    inline T as( const std::string &self ) {
+        T t;
+        return (std::istringstream(self) >> t) ? t :
+               (T)(self.size() && (self != "0") && (self != "false"));
+    }
+
+    template<>
+    inline char as( const std::string &self ) {
+        return self.size() == 1 ? (char)(self[0]) : (char)(as<int>(self));
+    }
+    template<>
+    inline signed char as( const std::string &self ) {
+        return self.size() == 1 ? (signed char)(self[0]) : (signed char)(as<int>(self));
+    }
+    template<>
+    inline unsigned char as( const std::string &self ) {
+        return self.size() == 1 ? (unsigned char)(self[0]) : (unsigned char)(as<int>(self));
+    }
+
+    template<>
+    inline const char *as( const std::string &self ) {
+        return self.c_str();
+    }
+    template<>
+    inline std::string as( const std::string &self ) {
+        return self;
+    }
+
+    // token split
+
+    inline size_t split( std::vector<std::string> &tokens, const std::string &self, const std::string &delimiters ) {
+        std::string str;
+        tokens.clear();
+        for( auto &ch : self ) {
+            if( delimiters.find_first_of( ch ) != std::string::npos ) {
+                if( str.size() ) tokens.push_back( str ), str = "";
+                tokens.push_back( std::string() + ch );
+            } else str += ch;
+        }
+        return str.empty() ? tokens.size() : ( tokens.push_back( str ), tokens.size() );
+    };
+
+    // portable cmdline 
+
+    inline std::vector<std::string> cmdline() {
+        std::vector<std::string> args;
+        std::string arg;
+    #       ifdef _WIN32
+            int argv;
+            auto *list = CommandLineToArgvW( GetCommandLineW(), &argv );
+            if( list ) {
+                for( int i = 0; i < argv; ++i ) {
+                    std::wstring ws( list[i] );
+                    args.push_back( std::string( ws.begin(), ws.end() ) );
+                }
+                LocalFree(list);
+            }
+    #       else
+            pid_t pid = getpid();
+
+            char fname[32] = {};
+            sprintf(fname, "/proc/%d/cmdline", pid);
+            std::ifstream ifs(fname);
+            if( ifs.good() ) {
+                std::stringstream ss;
+                ifs >> ss.rdbuf();
+                arg = ss.str();
+            }
+            for( auto end = arg.size(), i = end - end; i < end; ++i ) {
+                auto st = i;
+                while (i < arg.size() && arg[i] != '\0') ++i;
+                args.push_back( arg.substr(st, i - st) );
+            }
+    #       endif
+        return args;
+    }
+}
+
+// main map class; explicit initialization
+
+struct getopt : public std::map< std::string, std::string >
+{
+    using super = std::map< std::string, std::string >;
+
+    getopt( int argc, const char **argv ) : super() {
+        // reconstruct vector
+        std::vector<std::string> args( argc, std::string() );
+        for( int i = 0; i < argc; ++i ) {
+            args[ i ] = argv[ i ];
+        }
+        // create key=value and key= args as well
+        for( auto &it : args ) {
+            std::vector<std::string> tokens;
+            auto size = getopt_utils::split( tokens, it, "=" );
+
+            if( size == 3 && tokens[1] == "=" )
+                (*this)[ tokens[0] ] = tokens[2];
+            else
+            if( size == 2 && tokens[1] == "=" )
+                (*this)[ tokens[0] ] = true;
+            else
+            if( size == 1 && tokens[0] != argv[0] )
+                (*this)[ tokens[0] ] = true;
+        }
+        // recreate args
+        while( argc-- ) {
+            (*this)[ std::to_string(argc) ] = std::string( argv[argc] );
+        }
+    }
+
+    getopt( const std::vector<std::string> &args ) : super() {
+        std::vector<const char *> argv;
+        for( auto &it : args ) {
+            argv.push_back( it.c_str() );
+        }
+        *this = getopt( argv.size(), argv.data() );
+    }
+
+    size_t size() const {
+        unsigned i = 0;
+        while( has(std::to_string(i)) ) ++i;
+        return i;
+    }
+
+    bool has( const std::string &op ) const {
+        return this->find(op) != this->end();
+    }
+
+    std::string str() const {
+        std::stringstream ss;
+        std::string sep;
+        for( auto &it : *this ) {
+            ss << sep << it.first << "=" << it.second;
+            sep = ',';
+        }
+        return ss.str();
+    }
+
+    std::string cmdline() const {
+        std::stringstream cmd;
+        std::string sep;
+        // concatenate args
+        for( auto end = size(), arg = end - end; arg < end; ++arg ) {
+            cmd << sep << this->find(std::to_string(arg))->second;
+            sep = ' ';
+        }
+        return cmd.str();
+    }
+};
+
+// variadic syntax sugars {
+
+template< typename T >
+inline T getarg( const T &defaults, const char *argv ) {
+    static struct getopt map( getopt_utils::cmdline() );
+    return map.has( argv ) ? getopt_utils::as<T>(map[ argv ]) : defaults;
+}
+
+template< typename T, typename... Args >
+inline T getarg( const T &defaults, const char *arg0, Args... argv ) {
+    T t = getarg<T>( defaults, arg0 );
+    return t == defaults ? getarg<T>( defaults, argv... ) : t;
+}
+
+inline const char * getarg( const char *defaults, const char *argv ) {
+    static struct getopt map( getopt_utils::cmdline() );
+    return map.has( argv ) ? getopt_utils::as<const char *>(map[ argv ]) : defaults;
+}
+
+template< typename... Args >
+inline const char * getarg( const char *defaults, const char *arg0, Args... argv ) {
+    const char *t = getarg( defaults, arg0 );
+    return t == defaults ? getarg( defaults, argv... ) : t;
+}
+
+// }
+
+
+#ifdef GETOPT_BUILD_DEMO
+#include <iostream>
+#include <stdlib.h>
+
+int main( int argc, const char **argv ) {
+
+    auto show_help = [&]() {
+        std::cout << argv[0] << " [-h|--help|-?] [-f=path|--file=path] [-v|--version] [-d=number|--depth=number|--max-depth=number]" << std::endl;
+        exit(0);
+    };
+
+    // Simple functional api. No initialization required.
+
+    bool help = getarg( false, "-h", "--help", "-?" );
+    int version = getarg( 0, "-v", "--version", "--show-version" );
+    int depth = getarg( 0, "-d", "--depth", "--max-depth");
+    std::string file = getarg( "", "-f", "--file" );
+
+    if( help || argc <= 1 ) {
+        show_help();
+    }
+
+    if( version ) {
+        std::cout << argv[0] << " demo v1.0.0. Compiled on " << __DATE__ << std::endl;
+    }
+
+    if( depth ) {
+        std::cout << "provided depth: " << depth << std::endl;
+    }
+
+    if( !file.empty() ) {
+        std::cout << "provided file: " << file << std::endl;
+    }
+
+    // OOP map-based api. Explicit (argc, argv) initialization required.
+
+    struct getopt args( argc, argv );
+
+    if( args.has("-h") || args.has("--help") || args.has("-?") || args.size() == 1 ) {
+        show_help();
+    }
+
+    if( args.has("-v") || args.has("--version") ) {
+        std::cout << args["0"] << " demo v1.0.0. Compiled on " << __DATE__ << std::endl;
+    }
+
+    if( args.has("-d") || args.has("--depth") || args.has("--max-depth") ) {
+        std::string arg = args["-d"];
+        if( arg.empty() ) arg = args["--depth"];
+        if( arg.empty() ) arg = args["--max-depth"];
+        int depth = atoi( arg.c_str() );
+        std::cout << "provided depth: " << depth << std::endl;
+    }
+
+    if( args.has("-f") || args.has("--file") ) {
+        std::string arg = args["-f"];
+        if( arg.empty() ) arg = args["--file"];
+        std::string fname = arg;
+        std::cout << "provided file: " << fname << std::endl;
+    }
+
+    std::cout << "---" << std::endl;
+    std::cout << args.cmdline() << std::endl;
+    //std::cout << args.size() << " provided args: " << args.str() << std::endl;
+}
+#endif
\ No newline at end of file
diff --git a/examples/cpp/attestation/secret.json b/examples/cpp/attestation/secret.json
new file mode 100644
index 0000000000..1df67d2b1f
--- /dev/null
+++ b/examples/cpp/attestation/secret.json
@@ -0,0 +1,4 @@
+{
+    "key1" : "value1",
+    "key2" : "value2"
+}
diff --git a/examples/cpp/attestation/server.cc b/examples/cpp/attestation/server.cc
new file mode 100644
index 0000000000..949584d938
--- /dev/null
+++ b/examples/cpp/attestation/server.cc
@@ -0,0 +1,157 @@
+/*
+ *
+ * Copyright (c) 2022 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+#include <grpcpp/grpcpp.h>
+#include <grpcpp/security/sgx/sgx_ra_tls.h>
+#include <grpcpp/security/sgx/sgx_ra_tls_utils.h>
+#include <grpcpp/ext/proto_server_reflection_plugin.h>
+
+#ifdef BAZEL_BUILD
+#include "examples/protos/secretmanager.grpc.pb.h"
+#else
+#include "secretmanager.grpc.pb.h"
+#endif
+
+#include <string>
+#include <unordered_map>
+
+#include "getopt.hpp"
+
+struct argparser {
+    std::string config;
+    std::string secret;
+    std::string server_address;
+    std::string server_key;
+    std::string server_cert;
+    std::string root_cert;
+    argparser() {
+        server_address = getarg("localhost:70051", "-host", "--host");
+        server_key = getarg("server.key", "-key", "--key");
+        server_cert = getarg("server.crt", "-cert", "--cert");
+        root_cert = getarg("ca.crt", "-ca", "--root_cert");
+        secret = getarg("secret.json", "-s", "--secret");
+        config = getarg("dynamic_config.json", "-c", "--config");
+    };
+};
+
+std::string read_file(const char *file_path) {
+    std::ifstream in(file_path, std::ios::in);
+    std::ostringstream out;
+    out << in.rdbuf();
+    return std::string(out.str());
+}
+
+std::string read_file(std::string file_path) {
+    return read_file(file_path.c_str());
+}
+
+// Logic and data behind the server's behavior.
+class SecretMangerServiceImpl final :
+    public Attestation::SecretManger::Service {
+public:
+    void Init(std::string config_file, std::string secret_file) {
+        grpc::sgx::ra_tls_parse_config(config_file.c_str());
+        grpc::sgx::ra_tls_verify_init();
+        this->ParseSecret(secret_file.c_str());
+        return;
+    };
+
+    void ParseSecret(const char *secret_file) {
+        class grpc::sgx::json_engine secret_json(secret_file);
+        auto head = secret_json.get_handle()->child;
+        this->secrets.emplace(head->string, head->valuestring);
+        while (head) {
+            this->secrets.emplace(head->string, head->valuestring);
+            head = head->next;
+        }
+        std::cout << secret_json.print_item(secret_json.get_handle()) << std::endl;
+        return;
+    };
+
+    grpc::Status GetSecret(grpc::ServerContext* context,
+                           const Attestation::SecretRequest* request,
+                           Attestation::SecretReply* reply) override {
+        auto status = grpc::StatusCode::NOT_FOUND;
+        std::string value("");
+
+        auto key = request->key();
+        auto ctx = request->ctx();
+        // std::cout << key << std::endl;
+        // std::cout << ctx << std::endl;
+
+        try {
+            if (grpc::sgx::ra_tls_verify_certificate(
+                    ctx.c_str(), CERT_KEY_MAX_SIZE)) {
+                auto mr = grpc::sgx::ra_tls_parse_measurement(ctx.c_str(), CERT_KEY_MAX_SIZE);
+                std::cout << grpc::sgx::byte_to_hex(mr.mr_enclave, 32) << std::endl;
+                status = grpc::StatusCode::UNAUTHENTICATED;
+            } else {
+                value = this->secrets.at(key);
+                status = grpc::StatusCode::OK;
+            }
+            // std::cout << value << std::endl;
+            status = grpc::StatusCode::OK;
+        } catch (...) {
+            std::cout << "Not Found : " << request->key() << std::endl;
+        };
+
+        // auto mr = grpc::sgx::ra_tls_parse_measurement(ctx.c_str(), CERT_KEY_MAX_SIZE);
+        // std::cout << grpc::sgx::byte_to_hex(mr.mr_enclave, 32) << std::endl;
+
+        fflush(stdout);
+        reply->set_value(value);
+        return grpc::Status(status, "");
+    }
+private:
+    std::unordered_map<std::string, std::string> secrets;
+};
+
+void RunServer() {
+    argparser args;
+
+    SecretMangerServiceImpl service;
+    service.Init(args.config, args.secret);
+
+    grpc::EnableDefaultHealthCheckService(true);
+    grpc::reflection::InitProtoReflectionServerBuilderPlugin();
+
+    grpc::ServerBuilder builder;
+
+    grpc::SslServerCredentialsOptions options;
+    grpc::SslServerCredentialsOptions::PemKeyCertPair pkcp;
+    pkcp.private_key = read_file(args.server_key);
+    pkcp.cert_chain  = read_file(args.server_cert);
+    options.pem_key_cert_pairs.push_back(pkcp);
+    options.pem_root_certs = read_file(args.root_cert);
+
+    auto creds = grpc::SslServerCredentials(options);
+    GPR_ASSERT(creds.get() != nullptr);
+
+    builder.AddListeningPort(args.server_address, creds);
+    builder.RegisterService(&service);
+
+    std::unique_ptr<grpc::Server> server(builder.BuildAndStart());
+    std::cout << "Server listening on " << args.server_address << std::endl;
+
+    server->Wait();
+}
+
+int main(int argc, char** argv) {
+    RunServer();
+    return 0;
+}
diff --git a/examples/cpp/ratls/BUILD b/examples/cpp/ratls/BUILD
new file mode 100644
index 0000000000..694d9c77ac
--- /dev/null
+++ b/examples/cpp/ratls/BUILD
@@ -0,0 +1,42 @@
+# Copyright 2020 the gRPC authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+licenses(["notice"])  # 3-clause BSD
+
+cc_binary(
+    name = "server",
+    srcs = [
+        "server.cc",
+        "getopt.hpp",
+    ],
+    defines = ["BAZEL_BUILD"],
+    deps = [
+        "//:grpc++",
+        "//:grpc++_reflection",
+        "//examples/protos:ratls_proto",
+    ],
+)
+
+cc_binary(
+    name = "client",
+    srcs = [
+        "client.cc",
+        "getopt.hpp",
+    ],
+    defines = ["BAZEL_BUILD"],
+    deps = [
+        "//:grpc++",
+        "//examples/protos:ratls_proto",
+    ],
+)
diff --git a/examples/cpp/ratls/CMakeLists.txt b/examples/cpp/ratls/CMakeLists.txt
new file mode 100644
index 0000000000..d04b5f5269
--- /dev/null
+++ b/examples/cpp/ratls/CMakeLists.txt
@@ -0,0 +1,62 @@
+# Copyright (c) 2022 Intel Corporation
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+cmake_minimum_required(VERSION 3.5.1)
+
+project(RA-TLS C CXX)
+
+include(../cmake/common.cmake)
+
+# Proto file
+get_filename_component(hw_proto "../../protos/ratls.proto" ABSOLUTE)
+get_filename_component(hw_proto_path "${hw_proto}" PATH)
+
+# Generated sources
+set(hw_proto_srcs "${CMAKE_CURRENT_BINARY_DIR}/ratls.pb.cc")
+set(hw_proto_hdrs "${CMAKE_CURRENT_BINARY_DIR}/ratls.pb.h")
+set(hw_grpc_srcs "${CMAKE_CURRENT_BINARY_DIR}/ratls.grpc.pb.cc")
+set(hw_grpc_hdrs "${CMAKE_CURRENT_BINARY_DIR}/ratls.grpc.pb.h")
+add_custom_command(
+      OUTPUT "${hw_proto_srcs}" "${hw_proto_hdrs}" "${hw_grpc_srcs}" "${hw_grpc_hdrs}"
+      COMMAND ${_PROTOBUF_PROTOC}
+      ARGS --grpc_out "${CMAKE_CURRENT_BINARY_DIR}"
+        --cpp_out "${CMAKE_CURRENT_BINARY_DIR}"
+        -I "${hw_proto_path}"
+        --plugin=protoc-gen-grpc="${_GRPC_CPP_PLUGIN_EXECUTABLE}"
+        "${hw_proto}"
+      DEPENDS "${hw_proto}")
+
+# Include generated *.pb.h files
+include_directories("${CMAKE_CURRENT_BINARY_DIR}")
+
+# hw_grpc_proto
+add_library(hw_grpc_proto
+  ${hw_grpc_srcs}
+  ${hw_grpc_hdrs}
+  ${hw_proto_srcs}
+  ${hw_proto_hdrs})
+target_link_libraries(hw_grpc_proto
+  ${_REFLECTION}
+  ${_GRPC_GRPCPP}
+  ${_PROTOBUF_LIBPROTOBUF})
+
+# Targets greeter_[async_](client|server)
+foreach(_target client server)
+  add_executable(${_target} "${_target}.cc")
+  target_link_libraries(${_target}
+    hw_grpc_proto
+    ${_REFLECTION}
+    ${_GRPC_GRPCPP}
+    ${_PROTOBUF_LIBPROTOBUF})
+endforeach()
diff --git a/examples/cpp/ratls/README.md b/examples/cpp/ratls/README.md
new file mode 100644
index 0000000000..d2d81cc6a0
--- /dev/null
+++ b/examples/cpp/ratls/README.md
@@ -0,0 +1,7 @@
+# gRPC
+
+## Quick Start
+
+```
+./build.sh
+```
diff --git a/examples/cpp/ratls/build.sh b/examples/cpp/ratls/build.sh
new file mode 100755
index 0000000000..a79b4d88da
--- /dev/null
+++ b/examples/cpp/ratls/build.sh
@@ -0,0 +1,58 @@
+#
+# Copyright (c) 2022 Intel Corporation
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+set -ex
+
+export EXP_PATH=`dirname $0`
+export EXP_NAME=examples/cpp/ratls
+
+if [ -z ${BUILD_TYPE} ]; then
+    export BUILD_TYPE=Debug
+    export COMPILATION_MODE=dbg
+fi
+
+if [ -z ${SGX_RA_TLS_BACKEND} ]; then
+    export SGX_RA_TLS_BACKEND=GRAMINE # GRAMINE,OCCLUM,TDX,DUMMY
+fi
+
+if [ -z ${SGX_RA_TLS_SDK} ]; then
+    export SGX_RA_TLS_SDK=DEFAULT # DEFAULT,LIBRATS
+fi
+
+# build grpc package
+${GRPC_PATH}/cmake_build_cpp.sh
+# ${GRPC_PATH}/bazel_build_cpp.sh
+
+# build c++ example
+cd ${EXP_PATH}
+
+mkdir -p build
+touch build/.bazelignore
+cp ${GRPC_PATH}/dynamic_config.json build
+
+# build with cmake
+cd build
+cmake -D CMAKE_PREFIX_PATH=${INSTALL_PREFIX} \
+      -D CMAKE_BUILD_TYPE=${BUILD_TYPE} \
+      -D GRPC_AS_SUBMODULE=OFF \
+      -D GRPC_FETCHCONTENT=OFF ..
+make -j `nproc`
+cd -
+
+# build with bazel
+# bazel build :all -c dbg
+# cp ${GRPC_PATH}/bazel-bin/${EXP_NAME}/server ${GRPC_PATH}/bazel-bin/${EXP_NAME}/client build
+
+cd -
diff --git a/examples/cpp/ratls/client.cc b/examples/cpp/ratls/client.cc
new file mode 100644
index 0000000000..62dca4578c
--- /dev/null
+++ b/examples/cpp/ratls/client.cc
@@ -0,0 +1,87 @@
+/*
+ *
+ * Copyright (c) 2022 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+#include <grpcpp/grpcpp.h>
+#include <grpcpp/security/sgx/sgx_ra_tls.h>
+
+#ifdef BAZEL_BUILD
+#include "examples/protos/ratls.grpc.pb.h"
+#else
+#include "ratls.grpc.pb.h"
+#endif
+
+#include "getopt.hpp"
+
+using ratls::Greeter;
+using ratls::HelloReply;
+using ratls::HelloRequest;
+
+struct argparser {
+    const char* config;
+    std::string server_address;
+    argparser() {
+        server_address = getarg("localhost:8500", "-host", "--host");
+        config = getarg("dynamic_config.json", "-cfg", "--config");
+    };
+};
+
+class GreeterClient {
+    public:
+        GreeterClient(std::shared_ptr<grpc::Channel> channel) : stub_(Greeter::NewStub(channel)) {}
+
+        std::string SayHello(const std::string& user) {
+            HelloRequest request;
+            request.set_name(user);
+
+            HelloReply reply;
+
+            grpc::ClientContext context;
+
+            grpc::Status status = stub_->SayHello(&context, request, &reply);
+
+            if (status.ok()) {
+                return reply.message();
+            } else {
+                std::cout << status.error_code() << ": " << status.error_message() << std::endl;
+                return "RPC failed";
+            }
+        }
+
+    private:
+        std::unique_ptr<Greeter::Stub> stub_;
+};
+
+void run_client() {
+    argparser args;
+
+    auto cred = grpc::sgx::TlsCredentials(
+                    args.config, GRPC_RA_TLS_TWO_WAY_VERIFICATION);
+    auto channel = grpc::CreateChannel(args.server_address, cred);
+
+    GreeterClient greeter(channel);
+
+    std::string user_a = greeter.SayHello("a");
+    std::string user_b = greeter.SayHello("b");
+
+    std::cout << "Greeter received: " << user_a << " " << user_b << std::endl;
+};
+
+int main(int argc, char** argv) {
+    run_client();
+    return 0;
+}
diff --git a/examples/cpp/ratls/getopt.hpp b/examples/cpp/ratls/getopt.hpp
new file mode 100644
index 0000000000..2fe8e3a3ac
--- /dev/null
+++ b/examples/cpp/ratls/getopt.hpp
@@ -0,0 +1,316 @@
+// Simple getopt replacement class (C++11). 
+// - rlyeh, zlib/libpng licensed.
+// https://github.com/r-lyeh-archived/getopt/blob/master/getopt.hpp
+
+// Two APIs provided:
+//
+// 1) Simple functional api `getarg(...)`. 
+//    - No initialization required: (argc, argv) pair automatically retrieved.
+//    - First argument is default option value, then all option indentifiers follow.
+//
+// int main() {
+//     bool help = getarg( false, "-h", "--help", "-?" );
+//     int version = getarg( 0, "-v", "--version", "--show-version" );
+//     int depth = getarg( 1, "-d", "--depth", "--max-depth");
+//     std::string file = getarg( "", "-f", "--file" );
+//     [...]
+// }
+//
+// 2) Simple OOP map-based api `getopt class`. Initialization (argc, argv) pair required.
+//
+//    This getopt class is a std::map replacement where key/value are std::string types.
+//    Given invokation './app.out --user=me --pass=123 -h' this class delivers not only:
+//    map[0] = "./app.out", map[1] = "--user=me", map[2]="--pass=123", map[3]='-h'
+//    but also, map["--user"]="me", map["--pass"]="123" and also, map["-h"]=true
+//
+//    Additional API:
+//    - .cmdline() for a print app invokation string
+//    - .str() for pretty map printing
+//    - .size() number of arguments (equivalent to argc), rather than std::map.size()
+//
+// int main( int argc, const char **argv ) {
+//     getopt args( argc, argv );
+//     if( args.has("-h") || args.has("--help") || args.has("-?") || args.size() == 1 ) {
+//         std::cout << args["0"] << " [-?|-h|--help] [-v|--version] [--depth=number]" << std::endl;
+//         return 0;
+//     }
+//     if( args.has("-v") || args.has("--version") ) {
+//         std::cout << args["0"] << " sample v1.0.0. Compiled on " << __DATE__ << std::endl;
+//     }
+//     if( args.has("--depth") ) {
+//         int depth = atoi( args["--depth"].c_str() );
+//         std::cout << "depth set to " << depth << std::endl;
+//     }
+//     [...]
+// }
+
+#pragma once
+#include <map>
+#include <string>
+#include <sstream>
+#include <vector>
+
+#ifdef _WIN32
+#include <io.h>
+#include <winsock2.h>
+#include <shellapi.h>
+#pragma comment(lib, "Shell32.lib")
+#else
+#include <fstream>
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sstream>
+#endif
+
+#define GETOPT_VERSION "1.0.0" // (2016/04/18) Initial version
+
+namespace getopt_utils
+{
+    // string conversion
+
+    template< typename T >
+    inline T as( const std::string &self ) {
+        T t;
+        return (std::istringstream(self) >> t) ? t :
+               (T)(self.size() && (self != "0") && (self != "false"));
+    }
+
+    template<>
+    inline char as( const std::string &self ) {
+        return self.size() == 1 ? (char)(self[0]) : (char)(as<int>(self));
+    }
+    template<>
+    inline signed char as( const std::string &self ) {
+        return self.size() == 1 ? (signed char)(self[0]) : (signed char)(as<int>(self));
+    }
+    template<>
+    inline unsigned char as( const std::string &self ) {
+        return self.size() == 1 ? (unsigned char)(self[0]) : (unsigned char)(as<int>(self));
+    }
+
+    template<>
+    inline const char *as( const std::string &self ) {
+        return self.c_str();
+    }
+    template<>
+    inline std::string as( const std::string &self ) {
+        return self;
+    }
+
+    // token split
+
+    inline size_t split( std::vector<std::string> &tokens, const std::string &self, const std::string &delimiters ) {
+        std::string str;
+        tokens.clear();
+        for( auto &ch : self ) {
+            if( delimiters.find_first_of( ch ) != std::string::npos ) {
+                if( str.size() ) tokens.push_back( str ), str = "";
+                tokens.push_back( std::string() + ch );
+            } else str += ch;
+        }
+        return str.empty() ? tokens.size() : ( tokens.push_back( str ), tokens.size() );
+    };
+
+    // portable cmdline 
+
+    inline std::vector<std::string> cmdline() {
+        std::vector<std::string> args;
+        std::string arg;
+    #       ifdef _WIN32
+            int argv;
+            auto *list = CommandLineToArgvW( GetCommandLineW(), &argv );
+            if( list ) {
+                for( int i = 0; i < argv; ++i ) {
+                    std::wstring ws( list[i] );
+                    args.push_back( std::string( ws.begin(), ws.end() ) );
+                }
+                LocalFree(list);
+            }
+    #       else
+            pid_t pid = getpid();
+
+            char fname[32] = {};
+            sprintf(fname, "/proc/%d/cmdline", pid);
+            std::ifstream ifs(fname);
+            if( ifs.good() ) {
+                std::stringstream ss;
+                ifs >> ss.rdbuf();
+                arg = ss.str();
+            }
+            for( auto end = arg.size(), i = end - end; i < end; ++i ) {
+                auto st = i;
+                while (i < arg.size() && arg[i] != '\0') ++i;
+                args.push_back( arg.substr(st, i - st) );
+            }
+    #       endif
+        return args;
+    }
+}
+
+// main map class; explicit initialization
+
+struct getopt : public std::map< std::string, std::string >
+{
+    using super = std::map< std::string, std::string >;
+
+    getopt( int argc, const char **argv ) : super() {
+        // reconstruct vector
+        std::vector<std::string> args( argc, std::string() );
+        for( int i = 0; i < argc; ++i ) {
+            args[ i ] = argv[ i ];
+        }
+        // create key=value and key= args as well
+        for( auto &it : args ) {
+            std::vector<std::string> tokens;
+            auto size = getopt_utils::split( tokens, it, "=" );
+
+            if( size == 3 && tokens[1] == "=" )
+                (*this)[ tokens[0] ] = tokens[2];
+            else
+            if( size == 2 && tokens[1] == "=" )
+                (*this)[ tokens[0] ] = true;
+            else
+            if( size == 1 && tokens[0] != argv[0] )
+                (*this)[ tokens[0] ] = true;
+        }
+        // recreate args
+        while( argc-- ) {
+            (*this)[ std::to_string(argc) ] = std::string( argv[argc] );
+        }
+    }
+
+    getopt( const std::vector<std::string> &args ) : super() {
+        std::vector<const char *> argv;
+        for( auto &it : args ) {
+            argv.push_back( it.c_str() );
+        }
+        *this = getopt( argv.size(), argv.data() );
+    }
+
+    size_t size() const {
+        unsigned i = 0;
+        while( has(std::to_string(i)) ) ++i;
+        return i;
+    }
+
+    bool has( const std::string &op ) const {
+        return this->find(op) != this->end();
+    }
+
+    std::string str() const {
+        std::stringstream ss;
+        std::string sep;
+        for( auto &it : *this ) {
+            ss << sep << it.first << "=" << it.second;
+            sep = ',';
+        }
+        return ss.str();
+    }
+
+    std::string cmdline() const {
+        std::stringstream cmd;
+        std::string sep;
+        // concatenate args
+        for( auto end = size(), arg = end - end; arg < end; ++arg ) {
+            cmd << sep << this->find(std::to_string(arg))->second;
+            sep = ' ';
+        }
+        return cmd.str();
+    }
+};
+
+// variadic syntax sugars {
+
+template< typename T >
+inline T getarg( const T &defaults, const char *argv ) {
+    static struct getopt map( getopt_utils::cmdline() );
+    return map.has( argv ) ? getopt_utils::as<T>(map[ argv ]) : defaults;
+}
+
+template< typename T, typename... Args >
+inline T getarg( const T &defaults, const char *arg0, Args... argv ) {
+    T t = getarg<T>( defaults, arg0 );
+    return t == defaults ? getarg<T>( defaults, argv... ) : t;
+}
+
+inline const char * getarg( const char *defaults, const char *argv ) {
+    static struct getopt map( getopt_utils::cmdline() );
+    return map.has( argv ) ? getopt_utils::as<const char *>(map[ argv ]) : defaults;
+}
+
+template< typename... Args >
+inline const char * getarg( const char *defaults, const char *arg0, Args... argv ) {
+    const char *t = getarg( defaults, arg0 );
+    return t == defaults ? getarg( defaults, argv... ) : t;
+}
+
+// }
+
+
+#ifdef GETOPT_BUILD_DEMO
+#include <iostream>
+#include <stdlib.h>
+
+int main( int argc, const char **argv ) {
+
+    auto show_help = [&]() {
+        std::cout << argv[0] << " [-h|--help|-?] [-f=path|--file=path] [-v|--version] [-d=number|--depth=number|--max-depth=number]" << std::endl;
+        exit(0);
+    };
+
+    // Simple functional api. No initialization required.
+
+    bool help = getarg( false, "-h", "--help", "-?" );
+    int version = getarg( 0, "-v", "--version", "--show-version" );
+    int depth = getarg( 0, "-d", "--depth", "--max-depth");
+    std::string file = getarg( "", "-f", "--file" );
+
+    if( help || argc <= 1 ) {
+        show_help();
+    }
+
+    if( version ) {
+        std::cout << argv[0] << " demo v1.0.0. Compiled on " << __DATE__ << std::endl;
+    }
+
+    if( depth ) {
+        std::cout << "provided depth: " << depth << std::endl;
+    }
+
+    if( !file.empty() ) {
+        std::cout << "provided file: " << file << std::endl;
+    }
+
+    // OOP map-based api. Explicit (argc, argv) initialization required.
+
+    struct getopt args( argc, argv );
+
+    if( args.has("-h") || args.has("--help") || args.has("-?") || args.size() == 1 ) {
+        show_help();
+    }
+
+    if( args.has("-v") || args.has("--version") ) {
+        std::cout << args["0"] << " demo v1.0.0. Compiled on " << __DATE__ << std::endl;
+    }
+
+    if( args.has("-d") || args.has("--depth") || args.has("--max-depth") ) {
+        std::string arg = args["-d"];
+        if( arg.empty() ) arg = args["--depth"];
+        if( arg.empty() ) arg = args["--max-depth"];
+        int depth = atoi( arg.c_str() );
+        std::cout << "provided depth: " << depth << std::endl;
+    }
+
+    if( args.has("-f") || args.has("--file") ) {
+        std::string arg = args["-f"];
+        if( arg.empty() ) arg = args["--file"];
+        std::string fname = arg;
+        std::cout << "provided file: " << fname << std::endl;
+    }
+
+    std::cout << "---" << std::endl;
+    std::cout << args.cmdline() << std::endl;
+    //std::cout << args.size() << " provided args: " << args.str() << std::endl;
+}
+#endif
\ No newline at end of file
diff --git a/examples/cpp/ratls/server.cc b/examples/cpp/ratls/server.cc
new file mode 100644
index 0000000000..bdbef2ef1d
--- /dev/null
+++ b/examples/cpp/ratls/server.cc
@@ -0,0 +1,81 @@
+/*
+ *
+ * Copyright (c) 2022 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+#include <grpcpp/grpcpp.h>
+#include <grpcpp/security/sgx/sgx_ra_tls.h>
+#include <grpcpp/ext/proto_server_reflection_plugin.h>
+
+#ifdef BAZEL_BUILD
+#include "examples/protos/ratls.grpc.pb.h"
+#else
+#include "ratls.grpc.pb.h"
+#endif
+
+#include "getopt.hpp"
+
+using ratls::Greeter;
+using ratls::HelloReply;
+using ratls::HelloRequest;
+
+struct argparser {
+    const char* config;
+    std::string server_address;
+    argparser() {
+        server_address = getarg("localhost:8500", "-host", "--host");
+        config = getarg("dynamic_config.json", "-cfg", "--config");
+    };
+};
+
+// Logic and data behind the server's behavior.
+class GreeterServiceImpl final : public Greeter::Service {
+    grpc::Status SayHello(
+        grpc::ServerContext* context, const HelloRequest* request, HelloReply* reply) override {
+        std::string prefix("Hello ");
+        reply->set_message(prefix + request->name());
+        return grpc::Status::OK;
+    }
+};
+
+void RunServer() {
+    argparser args;
+
+    GreeterServiceImpl service;
+
+    grpc::EnableDefaultHealthCheckService(true);
+    grpc::reflection::InitProtoReflectionServerBuilderPlugin();
+
+    grpc::ServerBuilder builder;
+
+    auto creds = grpc::sgx::TlsServerCredentials(
+                    args.config, GRPC_RA_TLS_TWO_WAY_VERIFICATION);
+    GPR_ASSERT(creds.get() != nullptr);
+
+    builder.AddListeningPort(args.server_address, creds);
+
+    builder.RegisterService(&service);
+
+    std::unique_ptr<grpc::Server> server(builder.BuildAndStart());
+    std::cout << "Server listening on " << args.server_address << std::endl;
+
+    server->Wait();
+}
+
+int main(int argc, char** argv) {
+    RunServer();
+    return 0;
+}
diff --git a/examples/protos/BUILD b/examples/protos/BUILD
index 5418b88e6f..97dddc912a 100644
--- a/examples/protos/BUILD
+++ b/examples/protos/BUILD
@@ -81,3 +81,13 @@ proto_library(
     name = "route_guide_proto",
     srcs = [":route_guide.proto"],
 )
+
+grpc_proto_library(
+    name = "ratls_proto",
+    srcs = [":ratls.proto"],
+)
+
+grpc_proto_library(
+    name = "secretmanager_proto",
+    srcs = [":secretmanager.proto"],
+)
diff --git a/examples/protos/ratls.proto b/examples/protos/ratls.proto
new file mode 100644
index 0000000000..00387dbcef
--- /dev/null
+++ b/examples/protos/ratls.proto
@@ -0,0 +1,33 @@
+// Copyright (c) 2022 Intel Corporation
+// 
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+// 
+//     http://www.apache.org/licenses/LICENSE-2.0
+// 
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+syntax = "proto3";
+
+package ratls;
+
+// The greeting service definition.
+service Greeter {
+  // Sends a greeting
+  rpc SayHello (HelloRequest) returns (HelloReply) {}
+}
+
+// The request message containing the user's name.
+message HelloRequest {
+  string name = 1;
+}
+
+// The response message containing the greetings
+message HelloReply {
+  string message = 1;
+}
diff --git a/examples/protos/secretmanager.proto b/examples/protos/secretmanager.proto
new file mode 100644
index 0000000000..161b1cf86d
--- /dev/null
+++ b/examples/protos/secretmanager.proto
@@ -0,0 +1,32 @@
+// Copyright (c) 2022 Intel Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+syntax = "proto3";
+package Attestation;
+
+// The service definition.
+service SecretManger {
+  rpc GetSecret (SecretRequest) returns (SecretReply) {}
+}
+
+// The request message containing the key.
+message SecretRequest {
+  string key = 1;
+  string ctx = 2;
+}
+
+// The response message containing the value
+message SecretReply {
+  string value = 1;
+}
\ No newline at end of file
diff --git a/examples/python/ratls/README.md b/examples/python/ratls/README.md
new file mode 100644
index 0000000000..d2d81cc6a0
--- /dev/null
+++ b/examples/python/ratls/README.md
@@ -0,0 +1,7 @@
+# gRPC
+
+## Quick Start
+
+```
+./build.sh
+```
diff --git a/examples/python/ratls/build.sh b/examples/python/ratls/build.sh
new file mode 100755
index 0000000000..4d09596260
--- /dev/null
+++ b/examples/python/ratls/build.sh
@@ -0,0 +1,34 @@
+#
+# Copyright (c) 2022 Intel Corporation
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+set -ex
+
+if [ -z ${SGX_RA_TLS_BACKEND} ]; then
+    export SGX_RA_TLS_BACKEND=GRAMINE # GRAMINE,OCCLUM,TDX,AZURE_TDX,DUMMY
+fi
+
+if [ -z ${SGX_RA_TLS_SDK} ]; then
+    export SGX_RA_TLS_SDK=DEFAULT # DEFAULT,LIBRATS
+fi
+
+${GRPC_PATH}/build_python.sh
+
+cur_dir=`dirname $0`
+
+mkdir -p ${cur_dir}/build
+
+cp -r ${cur_dir}/*.py ${cur_dir}/build
+cp ${GRPC_PATH}/dynamic_config.json ${cur_dir}/build
+python3 -m grpc_tools.protoc -I ${GRPC_PATH}/examples/protos --python_out=${cur_dir}/build --grpc_python_out=${cur_dir}/build ratls.proto
diff --git a/examples/python/ratls/client.py b/examples/python/ratls/client.py
new file mode 100644
index 0000000000..05a0d7a4f6
--- /dev/null
+++ b/examples/python/ratls/client.py
@@ -0,0 +1,63 @@
+#
+# Copyright (c) 2022 Intel Corporation
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+"""The Python implementation of the GRPC ratls.Greeter client."""
+
+from __future__ import print_function
+import logging
+import argparse
+
+import grpc
+
+import ratls_pb2
+import ratls_pb2_grpc
+
+
+def run(args):
+    credentials = grpc.sgxratls_channel_credentials(
+        config_json=args.config, verify_option="two-way")
+    channel = grpc.secure_channel(args.host, credentials)
+    stub = ratls_pb2_grpc.GreeterStub(channel)
+
+    user_a = stub.SayHello(ratls_pb2.HelloRequest(name='a'))
+    user_b = stub.SayHello(ratls_pb2.HelloRequest(name='b'))
+
+    print("Greeter received:", user_a.message, user_b.message)
+
+    channel.close()
+
+def command_arguments():
+    parser = argparse.ArgumentParser(description='GRPC client.')
+    parser.add_argument(
+        '-host',
+        '--host',
+        type=str,
+        required=False,
+        default='localhost:8500',
+        help='The server socket address.'
+    )
+    parser.add_argument(
+        '-config',
+        '--config',
+        type=str,
+        required=False,
+        default='dynamic_config.json',
+        help='The path of dynamic config json'
+    )
+    return parser.parse_args()
+
+if __name__ == '__main__':
+    args = command_arguments()
+    logging.basicConfig()
+    run(args)
diff --git a/examples/python/ratls/server.py b/examples/python/ratls/server.py
new file mode 100644
index 0000000000..47d1bf22dc
--- /dev/null
+++ b/examples/python/ratls/server.py
@@ -0,0 +1,65 @@
+#
+# Copyright (c) 2022 Intel Corporation
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+"""The Python implementation of the GRPC ratls.Greeter server."""
+
+from concurrent import futures
+import logging
+import argparse
+
+import grpc
+
+import ratls_pb2
+import ratls_pb2_grpc
+
+
+class Greeter(ratls_pb2_grpc.GreeterServicer):
+    def SayHello(self, request, context):
+        return ratls_pb2.HelloReply(message='Hello %s' % request.name)
+
+def serve(args):
+    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
+    ratls_pb2_grpc.add_GreeterServicer_to_server(Greeter(), server)
+
+    credentials = grpc.sgxratls_server_credentials(
+        config_json=args.config, verify_option="two-way")
+    server.add_secure_port(args.host, credentials)
+
+    server.start()
+    server.wait_for_termination()
+
+def command_arguments():
+    parser = argparse.ArgumentParser(description='GRPC client.')
+    parser.add_argument(
+        '-host',
+        '--host',
+        type=str,
+        required=False,
+        default='localhost:8500',
+        help='The server socket address.'
+    )
+    parser.add_argument(
+        '-config',
+        '--config',
+        type=str,
+        required=False,
+        default='dynamic_config.json',
+        help='The path of dynamic config json'
+    )
+    return parser.parse_args()
+
+if __name__ == '__main__':
+    args = command_arguments()
+    logging.basicConfig()
+    serve(args)
diff --git a/include/grpc/grpc_security_constants.h b/include/grpc/grpc_security_constants.h
index 4d7f0788e7..0e054d3597 100644
--- a/include/grpc/grpc_security_constants.h
+++ b/include/grpc/grpc_security_constants.h
@@ -144,7 +144,16 @@ typedef enum {
   /** Skips both server certificate and hostname verification.
      Client is responsible for verifying server's identity and
      server's certificate via server authorization check callback. */
-  GRPC_TLS_SKIP_ALL_SERVER_VERIFICATION
+  GRPC_TLS_SKIP_ALL_SERVER_VERIFICATION,
+
+  // One-way RA-TLS verify client side
+  GRPC_RA_TLS_CLIENT_VERIFICATION,
+
+  // One-way RA-TLS verify server side
+  GRPC_RA_TLS_SERVER_VERIFICATION,
+
+  // Two-way RA-TLS verification in client and server side
+  GRPC_RA_TLS_TWO_WAY_VERIFICATION,
 } grpc_tls_server_verification_option;
 
 /**
diff --git a/include/grpcpp/security/sgx/cJSON.h b/include/grpcpp/security/sgx/cJSON.h
new file mode 100644
index 0000000000..9cedb93d3b
--- /dev/null
+++ b/include/grpcpp/security/sgx/cJSON.h
@@ -0,0 +1,140 @@
+/*
+  Copyright (c) 2009 Dave Gamble
+ 
+  Permission is hereby granted, free of charge, to any person obtaining a copy
+  of this software and associated documentation files (the "Software"), to deal
+  in the Software without restriction, including without limitation the rights
+  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+  copies of the Software, and to permit persons to whom the Software is
+  furnished to do so, subject to the following conditions:
+ 
+  The above copyright notice and this permission notice shall be included in
+  all copies or substantial portions of the Software.
+ 
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+  THE SOFTWARE.
+*/
+
+#ifndef cJSON__h
+#define cJSON__h
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+#include <stdio.h>
+/* cJSON Types: */
+#define cJSON_False 0
+#define cJSON_True 1
+#define cJSON_NULL 2
+#define cJSON_Number 3
+#define cJSON_String 4
+#define cJSON_Array 5
+#define cJSON_Object 6
+	
+#define cJSON_IsReference 256
+
+/* The cJSON structure: */
+typedef struct cJSON {
+	struct cJSON *next,*prev;	/* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem */
+	struct cJSON *child;		/* An array or object item will have a child pointer pointing to a chain of the items in the array/object. */
+
+	int type;					/* The type of the item, as above. */
+
+	char *valuestring;			/* The item's string, if type==cJSON_String */
+	int valueint;				/* The item's number, if type==cJSON_Number */
+	double valuedouble;			/* The item's number, if type==cJSON_Number */
+
+	char *string;				/* The item's name string, if this item is the child of, or is in the list of subitems of an object. */
+} cJSON;
+
+typedef struct cJSON_Hooks {
+      void *(*malloc_fn)(size_t sz);
+      void (*free_fn)(void *ptr);
+} cJSON_Hooks;
+
+/* Supply malloc, realloc and free functions to cJSON */
+extern void cJSON_InitHooks(cJSON_Hooks* hooks);
+
+
+/* Supply a block of JSON, and this returns a cJSON object you can interrogate. Call cJSON_Delete when finished. */
+extern cJSON *cJSON_Parse(const char *value);
+/* Render a cJSON entity to text for transfer/storage. Free the char* when finished. */
+extern char  *cJSON_Print(cJSON *item);
+/* Render a cJSON entity to text for transfer/storage without any formatting. Free the char* when finished. */
+extern char  *cJSON_PrintUnformatted(cJSON *item);
+/* Delete a cJSON entity and all subentities. */
+extern void   cJSON_Delete(cJSON *c);
+
+/* Returns the number of items in an array (or object). */
+extern int	  cJSON_GetArraySize(cJSON *array);
+/* Retrieve item number "item" from array "array". Returns NULL if unsuccessful. */
+extern cJSON *cJSON_GetArrayItem(cJSON *array,int item);
+/* Get item "string" from object. Case insensitive. */
+extern cJSON *cJSON_GetObjectItem(cJSON *object,const char *string);
+
+/* For analysing failed parses. This returns a pointer to the parse error. You'll probably need to look a few chars back to make sense of it. Defined when cJSON_Parse() returns 0. 0 when cJSON_Parse() succeeds. */
+extern const char *cJSON_GetErrorPtr(void);
+	
+/* These calls create a cJSON item of the appropriate type. */
+extern cJSON *cJSON_CreateNull(void);
+extern cJSON *cJSON_CreateTrue(void);
+extern cJSON *cJSON_CreateFalse(void);
+extern cJSON *cJSON_CreateBool(int b);
+extern cJSON *cJSON_CreateNumber(double num);
+extern cJSON *cJSON_CreateString(const char *string);
+extern cJSON *cJSON_CreateArray(void);
+extern cJSON *cJSON_CreateObject(void);
+
+/* These utilities create an Array of count items. */
+extern cJSON *cJSON_CreateIntArray(int *numbers,int count);
+extern cJSON *cJSON_CreateFloatArray(float *numbers,int count);
+extern cJSON *cJSON_CreateDoubleArray(double *numbers,int count);
+extern cJSON *cJSON_CreateStringArray(const char **strings,int count);
+
+/* Append item to the specified array/object. */
+extern void cJSON_AddItemToArray(cJSON *array, cJSON *item);
+extern void	cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item);
+/* Append reference to item to the specified array/object. Use this when you want to add an existing cJSON to a new cJSON, but don't want to corrupt your existing cJSON. */
+extern void cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item);
+extern void	cJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item);
+
+/* Remove/Detatch items from Arrays/Objects. */
+extern cJSON *cJSON_DetachItemFromArray(cJSON *array,int which);
+extern void   cJSON_DeleteItemFromArray(cJSON *array,int which);
+extern cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string);
+extern void   cJSON_DeleteItemFromObject(cJSON *object,const char *string);
+	
+/* Update array items. */
+extern void cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem);
+extern void cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem);
+
+/* Duplicate a cJSON item */
+extern cJSON *cJSON_Duplicate(cJSON *item,int recurse);
+/* Duplicate will create a new, identical cJSON item to the one you pass, in new memory that will
+need to be released. With recurse!=0, it will duplicate any children connected to the item.
+The item->next and ->prev pointers are always zero on return from Duplicate. */
+
+/* ParseWithOpts allows you to require (and check) that the JSON is null terminated, and to retrieve the pointer to the final byte parsed. */
+extern cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated);
+
+/* Macros for creating things quickly. */
+#define cJSON_AddNullToObject(object,name)		cJSON_AddItemToObject(object, name, cJSON_CreateNull())
+#define cJSON_AddTrueToObject(object,name)		cJSON_AddItemToObject(object, name, cJSON_CreateTrue())
+#define cJSON_AddFalseToObject(object,name)		cJSON_AddItemToObject(object, name, cJSON_CreateFalse())
+#define cJSON_AddBoolToObject(object,name,b)	cJSON_AddItemToObject(object, name, cJSON_CreateBool(b))
+#define cJSON_AddNumberToObject(object,name,n)	cJSON_AddItemToObject(object, name, cJSON_CreateNumber(n))
+#define cJSON_AddStringToObject(object,name,s)	cJSON_AddItemToObject(object, name, cJSON_CreateString(s))
+
+/* When assigning an integer value, it needs to be propagated to valuedouble too. */
+#define cJSON_SetIntValue(object,val)			((object)?(object)->valueint=(object)->valuedouble=(val):(val))
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/include/grpcpp/security/sgx/sgx_ra_tls.h b/include/grpcpp/security/sgx/sgx_ra_tls.h
new file mode 100644
index 0000000000..63e546ef15
--- /dev/null
+++ b/include/grpcpp/security/sgx/sgx_ra_tls.h
@@ -0,0 +1,65 @@
+/*
+ *
+ * Copyright (c) 2022 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+#ifndef SGX_RA_TLS_H
+#define SGX_RA_TLS_H
+
+#include <memory>
+
+#include <grpcpp/security/sgx/sgx_ra_tls_backends.h>
+#include <grpcpp/security/sgx/sgx_ra_tls_context.h>
+
+#define CERT_KEY_MAX_SIZE 16000
+
+namespace grpc {
+namespace sgx {
+
+std::vector<std::string> ra_tls_generate_key_cert(int is_dummy);
+
+void ra_tls_parse_config(ra_tls_config cfg);
+
+void ra_tls_parse_config(const char *file);
+
+void ra_tls_verify_init();
+
+int ra_tls_verify_certificate(const char *der_crt, size_t len);
+
+ra_tls_measurement ra_tls_parse_measurement(const char *der_crt, size_t len);
+
+int ra_tls_auth_check_schedule(void * /* config_user_data */,
+                               grpc_tls_server_authorization_check_arg *arg);
+
+std::shared_ptr<grpc::ChannelCredentials> TlsCredentials(
+    ra_tls_config cfg, grpc_tls_server_verification_option verify_option=GRPC_RA_TLS_TWO_WAY_VERIFICATION);
+
+std::shared_ptr<grpc::ChannelCredentials> TlsCredentials(
+    const char* cfg_json, grpc_tls_server_verification_option verify_option=GRPC_RA_TLS_TWO_WAY_VERIFICATION);
+
+std::shared_ptr<grpc::ServerCredentials> TlsServerCredentials(
+    ra_tls_config cfg, grpc_tls_server_verification_option verify_option=GRPC_RA_TLS_TWO_WAY_VERIFICATION);
+
+std::shared_ptr<grpc::ServerCredentials> TlsServerCredentials(
+    const char* cfg_json, grpc_tls_server_verification_option verify_option=GRPC_RA_TLS_TWO_WAY_VERIFICATION);
+
+std::shared_ptr<grpc::Channel> CreateSecureChannel(
+    string target_str, std::shared_ptr<grpc::ChannelCredentials> channel_creds);
+
+}  // namespace sgx
+}  // namespace grpc
+
+#endif  // SGX_RA_TLS_H
diff --git a/include/grpcpp/security/sgx/sgx_ra_tls_backends.h b/include/grpcpp/security/sgx/sgx_ra_tls_backends.h
new file mode 100644
index 0000000000..a141df45dd
--- /dev/null
+++ b/include/grpcpp/security/sgx/sgx_ra_tls_backends.h
@@ -0,0 +1,101 @@
+/*
+ *
+ * Copyright (c) 2022 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+#ifndef SGX_RA_TLS_BACKENDS_H
+#define SGX_RA_TLS_BACKENDS_H
+
+#include <grpcpp/security/credentials.h>
+#include <grpcpp/security/server_credentials.h>
+#include <grpcpp/security/sgx/sgx_ra_tls_options.h>
+#include <grpcpp/security/sgx/sgx_ra_tls_context.h>
+
+// Set 1 for strict security checks
+#define SGX_MESUREMENTS_MAX_SIZE 16
+
+namespace grpc {
+namespace sgx {
+
+class TlsAuthorizationCheck
+    : public grpc::experimental::TlsServerAuthorizationCheckInterface {
+    int Schedule(grpc::experimental::TlsServerAuthorizationCheckArg* arg) override;
+    void Cancel(grpc::experimental::TlsServerAuthorizationCheckArg* arg) override;
+};
+
+int dummy_generate_quote(uint8_t **quote_buf, uint32_t &quote_size, uint8_t *hash);
+
+std::vector<std::string> dummy_generate_key_cert();
+
+void dummy_verify_init();
+
+int dummy_verify_cert(const char *der_crt, size_t len);
+
+ra_tls_measurement dummy_parse_measurement(const char *der_crt, size_t len);
+
+#if defined(SGX_RA_TLS_GRAMINE_BACKEND)
+
+std::vector<std::string> gramine_generate_key_cert();
+
+void gramine_verify_init();
+
+int gramine_verify_cert(const char *der_crt, size_t len);
+
+ra_tls_measurement gramine_parse_measurement(const char *der_crt, size_t len);
+
+#elif defined(SGX_RA_TLS_OCCLUM_BACKEND)
+
+std::vector<std::string> occlum_generate_key_cert();
+
+void occlum_verify_init();
+
+int occlum_verify_cert(const char *der_crt, size_t len);
+
+ra_tls_measurement occlum_parse_measurement(const char *der_crt, size_t len);
+
+#elif defined(SGX_RA_TLS_TDX_BACKEND) || defined(SGX_RA_TLS_AZURE_TDX_BACKEND)
+
+std::vector<std::string> tdx_generate_key_cert();
+
+void tdx_verify_init();
+
+int tdx_verify_cert(const char *der_crt, size_t len);
+
+ra_tls_measurement tdx_parse_measurement(const char *der_crt, size_t len);
+
+#endif
+
+std::vector<std::string> ra_tls_generate_key_cert(int is_dummy);
+
+void ra_tls_parse_config(ra_tls_config cfg);
+
+void ra_tls_parse_config(const char *file);
+
+void ra_tls_verify_init();
+
+int ra_tls_verify_certificate(const char *der_crt, size_t len);
+
+ra_tls_measurement ra_tls_parse_measurement(const char *der_crt, size_t len);
+
+void credential_option_set_certificate_provider(grpc::sgx::CredentialsOptions& options, int is_dummy);
+
+void credential_option_set_authorization_check(grpc::sgx::CredentialsOptions& options);
+
+
+} // namespace sgx
+} // namespace grpc
+
+#endif // SGX_RA_TLS_BACKENDS_H
diff --git a/include/grpcpp/security/sgx/sgx_ra_tls_context.h b/include/grpcpp/security/sgx/sgx_ra_tls_context.h
new file mode 100644
index 0000000000..4bcc039fe9
--- /dev/null
+++ b/include/grpcpp/security/sgx/sgx_ra_tls_context.h
@@ -0,0 +1,91 @@
+/*
+ *
+ * Copyright (c) 2022 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+#ifndef SGX_RA_TLS_CONTEXT_H
+#define SGX_RA_TLS_CONTEXT_H
+
+#include <mutex>
+#include <unordered_map>
+
+#include <grpc/grpc_security_constants.h>
+#include <grpcpp/security/credentials.h>
+#include <grpcpp/security/server_credentials.h>
+#include <grpcpp/security/sgx/sgx_ra_tls_utils.h>
+
+#define CERT_KEY_MAX_SIZE 16000
+
+namespace grpc {
+namespace sgx {
+
+class TlsAuthorizationCheck;
+
+struct ra_tls_measurement {
+    char mr_enclave[32];
+    char mr_signer[32];
+    uint16_t isv_prod_id;
+    uint16_t isv_svn;
+};
+
+struct ra_tls_config {
+    bool verify_mr_enclave  = true;
+    bool verify_mr_signer   = true;
+    bool verify_isv_prod_id = true;
+    bool verify_isv_svn     = true;
+    std::vector<ra_tls_measurement> mrs;
+};
+
+struct ra_tls_cache {
+    int id = 0;
+    std::unordered_map<
+            int, std::shared_ptr<grpc::experimental::StaticDataCertificateProvider>
+        > certificate_provider;
+    std::unordered_map<
+            int, std::shared_ptr<grpc::sgx::TlsAuthorizationCheck>
+        > authorization_check;
+    std::unordered_map<
+            int, std::shared_ptr<grpc::experimental::TlsServerAuthorizationCheckConfig>
+        > authorization_check_config;
+#ifdef SGX_RA_TLS_GRAMINE_BACKEND
+    std::unordered_map<int, ra_tls_measurement> mrs;
+#endif
+};
+
+struct ra_tls_context {
+    std::mutex mtx;
+    struct ra_tls_config cfg;
+    struct ra_tls_cache cache;
+#ifdef SGX_RA_TLS_GRAMINE_BACKEND
+    class library_engine attest_lib;
+    class library_engine verify_lib;
+    class library_engine sgx_urts_lib;
+    int (*verify_callback_f)(uint8_t* der_crt, size_t der_crt_size) = nullptr;
+#endif
+#ifdef SGX_RA_TLS_LIBRATS_SDK
+    class library_engine attest_lib;
+    class library_engine verify_lib;
+    class library_engine init_lib;
+    class library_engine cleanup_lib;
+#endif
+};
+
+extern struct ra_tls_context _ctx_;
+
+} // namespace sgx
+} // namespace grpc
+
+#endif // SGX_RA_TLS_CONTEXT_H
diff --git a/include/grpcpp/security/sgx/sgx_ra_tls_impl.h b/include/grpcpp/security/sgx/sgx_ra_tls_impl.h
new file mode 100644
index 0000000000..d58c80cba9
--- /dev/null
+++ b/include/grpcpp/security/sgx/sgx_ra_tls_impl.h
@@ -0,0 +1,53 @@
+/*
+ *
+ * Copyright (c) 2022 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+#ifndef SGX_RA_TLS_IMPL_H
+#define SGX_RA_TLS_IMPL_H
+
+#include <grpcpp/security/sgx/sgx_ra_tls_context.h>
+#include <grpcpp/security/sgx/sgx_ra_tls_utils.h>
+
+namespace grpc {
+namespace sgx {
+
+#include <openssl/evp.h>
+#include <openssl/rsa.h>
+#include <openssl/x509.h>
+#include <openssl/x509v3.h>
+#include <openssl/sha.h>
+#include <openssl/pem.h>
+#include <openssl/asn1.h>
+
+extern const char * RA_TLS_SHORT_NAME;
+extern const char * RA_TLS_LONG_NAME;
+
+std::vector<std::string> generate_key_cert(
+    int (*generate_quote)(
+        uint8_t **quote_buf, uint32_t &quote_size, uint8_t *hash));
+
+int parse_quote(X509 *x509, uint8_t **quote, uint32_t &quote_size);
+
+int verify_pubkey_hash(X509 *x509, uint8_t *pubkey_hash, uint32_t hash_size);
+
+int verify_measurement(const char* mr_enclave, const char* mr_signer,
+                       const char* isv_prod_id, const char* isv_svn);
+
+} // namespace sgx
+} // namespace grpc
+
+#endif // SGX_RA_TLS_IMPL_H
\ No newline at end of file
diff --git a/include/grpcpp/security/sgx/sgx_ra_tls_log.h b/include/grpcpp/security/sgx/sgx_ra_tls_log.h
new file mode 100644
index 0000000000..2b8bfb8adb
--- /dev/null
+++ b/include/grpcpp/security/sgx/sgx_ra_tls_log.h
@@ -0,0 +1,32 @@
+/*
+ *
+ * Copyright (c) 2022 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+#ifndef SGX_RA_TLS_LOG_H
+#define SGX_RA_TLS_LOG_H
+
+#define grpc_printf printf
+#define grpc_fprintf fprintf
+#define grpc_sprintf sprintf
+
+namespace grpc {
+namespace sgx {
+
+} // namespace sgx
+} // namespace grpc
+
+#endif // SGX_RA_TLS_LOG_H
diff --git a/include/grpcpp/security/sgx/sgx_ra_tls_options.h b/include/grpcpp/security/sgx/sgx_ra_tls_options.h
new file mode 100644
index 0000000000..db64a86766
--- /dev/null
+++ b/include/grpcpp/security/sgx/sgx_ra_tls_options.h
@@ -0,0 +1,71 @@
+/*
+ *
+ * Copyright (c) 2022 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+#ifndef SGX_RA_TLS_OPTIONS_H
+#define SGX_RA_TLS_OPTIONS_H
+
+#include <grpc/status.h>
+#include <grpc/grpc_security.h>
+#include <grpc/grpc_security_constants.h>
+#include <grpc/support/log.h>
+#include <grpcpp/support/config.h>
+#include <grpcpp/security/tls_certificate_provider.h>
+#include <grpcpp/security/tls_credentials_options.h>
+
+#include <memory>
+#include <vector>
+
+namespace grpc {
+namespace sgx {
+
+// Contains configurable options on the client side.
+// Client side doesn't need to always use certificate provider. When the
+// certificate provider is not set, we will use the root certificates stored
+// in the system default locations, and assume client won't provide any
+// identity certificates(single side TLS).
+// It is used for experimental purposes for now and it is subject to change.
+class CredentialsOptions final : public grpc::experimental::TlsCredentialsOptions {
+ public:
+
+  CredentialsOptions(
+      grpc_tls_server_verification_option option = GRPC_RA_TLS_TWO_WAY_VERIFICATION) : TlsCredentialsOptions() {
+      set_verification_option(option);
+  }
+
+  // Sets the option to verify the server.
+  // The default is GRPC_RA_TLS_TWO_WAY_VERIFICATION.
+  void set_verification_option(
+      grpc_tls_server_verification_option server_verification_option);
+
+  // Sets option to request the certificates from the client.
+  // The default is GRPC_SSL_DONT_REQUEST_CLIENT_CERTIFICATE.
+  void set_cert_request_type(
+      grpc_ssl_client_certificate_request_type cert_request_type);
+
+  // Sets the custom authorization config.
+  void set_authorization_check_config(
+      std::shared_ptr<grpc::experimental::TlsServerAuthorizationCheckConfig>
+          authorization_check_config);
+
+ private:
+};
+
+}  // namespace sgx
+}  // namespace grpc
+
+#endif  // SGX_RA_TLS_OPTIONS_H
diff --git a/include/grpcpp/security/sgx/sgx_ra_tls_utils.h b/include/grpcpp/security/sgx/sgx_ra_tls_utils.h
new file mode 100644
index 0000000000..29c092d10c
--- /dev/null
+++ b/include/grpcpp/security/sgx/sgx_ra_tls_utils.h
@@ -0,0 +1,106 @@
+/*
+ *
+ * Copyright (c) 2022 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+#ifndef SGX_RA_TLS_UTILS_H
+#define SGX_RA_TLS_UTILS_H
+
+#include <string>
+#include <vector>
+#include <memory>
+#include <dlfcn.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <time.h>
+#include <sys/stat.h>
+
+#include <grpcpp/security/sgx/sgx_ra_tls_log.h>
+
+#define HEX_DUMP_SIZE   16
+#define MAX_ROW_SIZE    70
+
+namespace grpc {
+namespace sgx {
+
+#include <grpcpp/security/sgx/cJSON.h>
+
+class library_engine {
+    public:
+        library_engine();
+
+        library_engine(const char*, int);
+
+        ~library_engine();
+
+        void open(const char*, int);
+
+        void close();
+
+        void* get_func(const char*);
+
+        void* get_handle();
+
+    private:
+        void* handle;
+        char* error;
+};
+
+class json_engine {
+    public:
+        json_engine();
+
+        json_engine(const char*);
+
+        ~json_engine();
+
+        bool open(const char*);
+
+        void close();
+
+        cJSON* get_handle();
+
+        cJSON* get_item(cJSON* obj, const char* item);
+
+        char* print_item(cJSON* obj);
+
+        bool cmp_item(cJSON* obj, const char* item);
+
+    private:
+        cJSON* handle;
+};
+
+void check_free(void* ptr);
+
+template<typename T>
+void check_delete(T ptr);
+
+bool check_file(const char* file_path);
+
+bool hex_to_byte(const char* src, char* dst, size_t dst_size);
+
+void byte_to_hex(const char* src, char* dst, size_t src_size);
+
+std::string byte_to_hex(const char* src, size_t src_size);
+
+void print_hex_dump(const char *title, const char *prefix_str,
+                    const uint8_t *buf, int len);
+
+} // namespace sgx
+} // namespace grpc
+
+#endif // SGX_RA_TLS_UTILS_H
diff --git a/setup.py b/setup.py
index c93d419f32..629f93b516 100644
--- a/setup.py
+++ b/setup.py
@@ -113,6 +113,9 @@ def _env_bool_value(env_name, default):
     return os.environ.get(env_name, default).upper() not in ['FALSE', '0', '']
 
 
+BUILD_WITH_SGX_RA_TLS = _env_bool_value('GRPC_BUILD_WITH_SGX_RA_TLS',
+                                            'True')
+
 BUILD_WITH_BORING_SSL_ASM = _env_bool_value('GRPC_BUILD_WITH_BORING_SSL_ASM',
                                             'True')
 
@@ -262,6 +265,21 @@ if EXTRA_ENV_LINK_ARGS is None:
     if "linux" in sys.platform:
         EXTRA_ENV_LINK_ARGS += ' -Wl,-wrap,memcpy -static-libgcc'
 
+if BUILD_WITH_SGX_RA_TLS:
+    SGX_RA_TLS_BACKEND = os.getenv("SGX_RA_TLS_BACKEND")
+    if SGX_RA_TLS_BACKEND == "GRAMINE":
+        EXTRA_ENV_LINK_ARGS += ' -lmbedx509_gramine -lmbedcrypto_gramine -lcjson -lcjson_utils -DSGX_RA_TLS_GRAMINE_BACKEND'
+    elif SGX_RA_TLS_BACKEND == "OCCLUM":
+        EXTRA_ENV_LINK_ARGS += ' -ldcap_quote -DSGX_RA_TLS_OCCLUM_BACKEND'
+    elif SGX_RA_TLS_BACKEND == "TDX":
+        EXTRA_ENV_LINK_ARGS += ' -ltdx_attest -lsgx_dcap_quoteverify -lsgx_urts -DSGX_RA_TLS_TDX_BACKEND'
+    elif SGX_RA_TLS_BACKEND == "AZURE_TDX":
+        EXTRA_ENV_LINK_ARGS += ' -lazguestattestation -lcurl -DSGX_RA_TLS_AZURE_TDX_BACKEND'
+    elif SGX_RA_TLS_BACKEND == "DUMMY":
+        EXTRA_ENV_LINK_ARGS += ' -DSGX_RA_TLS_DUMMY_BACKEND'
+    else:
+        raise Exception('Undefined SGX_RA_TLS_BACKEND!')
+
 EXTRA_COMPILE_ARGS = shlex.split(EXTRA_ENV_COMPILE_ARGS)
 EXTRA_LINK_ARGS = shlex.split(EXTRA_ENV_LINK_ARGS)
 
@@ -275,6 +293,7 @@ CYTHON_EXTENSION_MODULE_NAMES = ('grpc._cython.cygrpc',)
 CYTHON_HELPER_C_FILES = ()
 
 CORE_C_FILES = tuple(grpc_core_dependencies.CORE_SOURCE_FILES)
+
 if "win32" in sys.platform:
     CORE_C_FILES = filter(lambda x: 'third_party/cares' not in x, CORE_C_FILES)
 
@@ -296,12 +315,15 @@ if BUILD_WITH_SYSTEM_RE2:
     CORE_C_FILES = filter(lambda x: 'third_party/re2' not in x, CORE_C_FILES)
     RE2_INCLUDE = (os.path.join('/usr', 'include', 're2'),)
 
+if BUILD_WITH_SGX_RA_TLS:
+    SGXSDK_INCLUDE = (os.path.join('/opt', 'intel', 'sgxsdk', 'include'),)
+
 EXTENSION_INCLUDE_DIRECTORIES = ((PYTHON_STEM,) + CORE_INCLUDE + ABSL_INCLUDE +
                                  ADDRESS_SORTING_INCLUDE + CARES_INCLUDE +
                                  RE2_INCLUDE + SSL_INCLUDE + UPB_INCLUDE +
                                  UPB_GRPC_GENERATED_INCLUDE +
                                  UPBDEFS_GRPC_GENERATED_INCLUDE +
-                                 XXHASH_INCLUDE + ZLIB_INCLUDE)
+                                 XXHASH_INCLUDE + ZLIB_INCLUDE + SGXSDK_INCLUDE)
 
 EXTENSION_LIBRARIES = ()
 if "linux" in sys.platform:
@@ -325,6 +347,8 @@ if BUILD_WITH_SYSTEM_CARES:
     EXTENSION_LIBRARIES += ('cares',)
 if BUILD_WITH_SYSTEM_RE2:
     EXTENSION_LIBRARIES += ('re2',)
+if BUILD_WITH_SGX_RA_TLS:
+    EXTENSION_LIBRARIES += ('grpc++',)
 
 DEFINE_MACROS = (('_WIN32_WINNT', 0x600),)
 asm_files = []
@@ -386,6 +410,20 @@ if "linux" in sys.platform or "darwin" in sys.platform:
     DEFINE_MACROS += (('PyMODINIT_FUNC', pymodinit),)
     DEFINE_MACROS += (('GRPC_POSIX_FORK_ALLOW_PTHREAD_ATFORK', 1),)
 
+if BUILD_WITH_SGX_RA_TLS:
+    if SGX_RA_TLS_BACKEND == "GRAMINE":
+        DEFINE_MACROS += (('SGX_RA_TLS_GRAMINE_BACKEND', 1),)
+    elif SGX_RA_TLS_BACKEND == "OCCLUM":
+        DEFINE_MACROS += (('SGX_RA_TLS_OCCLUM_BACKEND', 1),)
+    elif SGX_RA_TLS_BACKEND == "TDX":
+        DEFINE_MACROS += (('SGX_RA_TLS_TDX_BACKEND', 1),)
+    elif SGX_RA_TLS_BACKEND == "AZURE_TDX":
+        DEFINE_MACROS += (('SGX_RA_TLS_AZURE_TDX_BACKEND', 1),)
+    elif SGX_RA_TLS_BACKEND == "DUMMY":
+        DEFINE_MACROS += (('SGX_RA_TLS_DUMMY_BACKEND', 1),)
+    else:
+        raise Exception('Undefined SGX_RA_TLS_BACKEND!')
+
 # By default, Python3 distutils enforces compatibility of
 # c plugins (.so files) with the OSX version Python was built with.
 # We need OSX 10.10, the oldest which supports C++ thread_local.
@@ -418,6 +456,7 @@ def cython_extensions_and_necessity():
     else:
         core_c_files = list(CORE_C_FILES)
         extra_objects = []
+
     extensions = [
         _extension.Extension(
             name=module_name,
@@ -429,6 +468,7 @@ def cython_extensions_and_necessity():
             extra_objects=extra_objects,
             extra_compile_args=list(CFLAGS),
             extra_link_args=list(LDFLAGS),
+            language='c++',
         ) for (module_name, module_file
               ) in zip(list(CYTHON_EXTENSION_MODULE_NAMES), cython_module_files)
     ]
diff --git a/src/core/lib/security/credentials/tls/tls_credentials.cc b/src/core/lib/security/credentials/tls/tls_credentials.cc
index f5b05d8a01..ab80b22554 100644
--- a/src/core/lib/security/credentials/tls/tls_credentials.cc
+++ b/src/core/lib/security/credentials/tls/tls_credentials.cc
@@ -41,11 +41,11 @@ bool CredentialOptionSanityCheck(const grpc_tls_credentials_options* options,
     return false;
   }
   // TODO(ZhenLian): remove this when it is also supported on server side.
-  if (!is_client && options->server_authorization_check_config() != nullptr) {
-    gpr_log(GPR_INFO,
-            "Server's credentials options should not contain server "
-            "authorization check config.");
-  }
+  // if (!is_client && options->server_authorization_check_config() != nullptr) {
+  //   gpr_log(GPR_INFO,
+  //           "Server's credentials options should not contain server "
+  //           "authorization check config.");
+  // }
   if (options->server_verification_option() != GRPC_TLS_SERVER_VERIFICATION &&
       options->server_authorization_check_config() == nullptr) {
     gpr_log(GPR_ERROR,
diff --git a/src/core/lib/security/security_connector/tls/tls_security_connector.cc b/src/core/lib/security/security_connector/tls/tls_security_connector.cc
index ea6b42e07d..241e8e7452 100644
--- a/src/core/lib/security/security_connector/tls/tls_security_connector.cc
+++ b/src/core/lib/security/security_connector/tls/tls_security_connector.cc
@@ -67,6 +67,13 @@ tsi_ssl_pem_key_cert_pair* ConvertToTsiPemKeyCertPair(
 
 }  // namespace
 
+void gpr_check_free(void* p) {
+  if (p) {
+    gpr_free(p);
+    p = nullptr;
+  }
+}
+
 // -------------------channel security connector-------------------
 RefCountedPtr<grpc_channel_security_connector>
 TlsChannelSecurityConnector::CreateTlsChannelSecurityConnector(
@@ -219,82 +226,84 @@ void TlsChannelSecurityConnector::check_peer(
       return;
     }
   }
-  /* Do the custom server authorization check, if specified by the user. */
-  const grpc_tls_server_authorization_check_config* config =
-      options_->server_authorization_check_config();
-  /* If server authorization config is not null, use it to perform
-   * server authorization check. */
-  if (config != nullptr) {
-    const tsi_peer_property* p =
-        tsi_peer_get_property_by_name(&peer, TSI_X509_PEM_CERT_PROPERTY);
-    if (p == nullptr) {
-      error = GRPC_ERROR_CREATE_FROM_STATIC_STRING(
-          "Cannot check peer: missing pem cert property.");
-    } else {
-      char* peer_pem = static_cast<char*>(gpr_zalloc(p->value.length + 1));
-      memcpy(peer_pem, p->value.data, p->value.length);
-      GPR_ASSERT(check_arg_ != nullptr);
-      check_arg_->peer_cert = check_arg_->peer_cert == nullptr
-                                  ? gpr_strdup(peer_pem)
-                                  : check_arg_->peer_cert;
-      check_arg_->target_name = check_arg_->target_name == nullptr
-                                    ? gpr_strdup(target_name)
-                                    : check_arg_->target_name;
-      on_peer_checked_ = on_peer_checked;
-      gpr_free(peer_pem);
-      const tsi_peer_property* chain = tsi_peer_get_property_by_name(
-          &peer, TSI_X509_PEM_CERT_CHAIN_PROPERTY);
-      if (chain != nullptr) {
-        char* peer_pem_chain =
-            static_cast<char*>(gpr_zalloc(chain->value.length + 1));
-        memcpy(peer_pem_chain, chain->value.data, chain->value.length);
-        check_arg_->peer_cert_full_chain =
-            check_arg_->peer_cert_full_chain == nullptr
-                ? gpr_strdup(peer_pem_chain)
-                : check_arg_->peer_cert_full_chain;
-        gpr_free(peer_pem_chain);
-      }
-      // TODO(zhenlian) - This should be cleaned up as part of the custom
-      // verification changes. Fill in the subject alternative names
-      std::vector<char*> subject_alternative_names;
-      for (size_t i = 0; i < peer.property_count; i++) {
-        const tsi_peer_property* prop = &peer.properties[i];
-        if (strcmp(prop->name,
-                   TSI_X509_SUBJECT_ALTERNATIVE_NAME_PEER_PROPERTY) == 0) {
-          char* san = new char[prop->value.length + 1];
-          memcpy(san, prop->value.data, prop->value.length);
-          san[prop->value.length] = '\0';
-          subject_alternative_names.emplace_back(san);
+  if (options_->server_verification_option() != GRPC_RA_TLS_CLIENT_VERIFICATION) {
+    /* Do the custom server authorization check, if specified by the user. */
+    const grpc_tls_server_authorization_check_config* config =
+        options_->server_authorization_check_config();
+    /* If server authorization config is not null, use it to perform
+    * server authorization check. */
+    if (config != nullptr) {
+      const tsi_peer_property* p =
+          tsi_peer_get_property_by_name(&peer, TSI_X509_PEM_CERT_PROPERTY);
+      if (p == nullptr) {
+        error = GRPC_ERROR_CREATE_FROM_STATIC_STRING(
+            "Cannot check peer: missing pem cert property.");
+      } else {
+        char* peer_pem = static_cast<char*>(gpr_zalloc(p->value.length + 1));
+        memcpy(peer_pem, p->value.data, p->value.length);
+        GPR_ASSERT(check_arg_ != nullptr);
+        check_arg_->peer_cert = check_arg_->peer_cert == nullptr
+                                    ? gpr_strdup(peer_pem)
+                                    : check_arg_->peer_cert;
+        check_arg_->target_name = check_arg_->target_name == nullptr
+                                      ? gpr_strdup(target_name)
+                                      : check_arg_->target_name;
+        on_peer_checked_ = on_peer_checked;
+        gpr_check_free(peer_pem);
+        const tsi_peer_property* chain = tsi_peer_get_property_by_name(
+            &peer, TSI_X509_PEM_CERT_CHAIN_PROPERTY);
+        if (chain != nullptr) {
+          char* peer_pem_chain =
+              static_cast<char*>(gpr_zalloc(chain->value.length + 1));
+          memcpy(peer_pem_chain, chain->value.data, chain->value.length);
+          check_arg_->peer_cert_full_chain =
+              check_arg_->peer_cert_full_chain == nullptr
+                  ? gpr_strdup(peer_pem_chain)
+                  : check_arg_->peer_cert_full_chain;
+          gpr_check_free(peer_pem_chain);
         }
-      }
-      if (check_arg_->subject_alternative_names != nullptr) {
-        for (size_t i = 0; i < check_arg_->subject_alternative_names_size;
-             ++i) {
-          delete[] check_arg_->subject_alternative_names[i];
+        // TODO(zhenlian) - This should be cleaned up as part of the custom
+        // verification changes. Fill in the subject alternative names
+        std::vector<char*> subject_alternative_names;
+        for (size_t i = 0; i < peer.property_count; i++) {
+          const tsi_peer_property* prop = &peer.properties[i];
+          if (strcmp(prop->name,
+                    TSI_X509_SUBJECT_ALTERNATIVE_NAME_PEER_PROPERTY) == 0) {
+            char* san = new char[prop->value.length + 1];
+            memcpy(san, prop->value.data, prop->value.length);
+            san[prop->value.length] = '\0';
+            subject_alternative_names.emplace_back(san);
+          }
         }
-        delete[] check_arg_->subject_alternative_names;
-      }
-      check_arg_->subject_alternative_names_size =
-          subject_alternative_names.size();
-      if (subject_alternative_names.empty()) {
-        check_arg_->subject_alternative_names = nullptr;
-      } else {
-        check_arg_->subject_alternative_names =
-            new char*[check_arg_->subject_alternative_names_size];
-        for (size_t i = 0; i < check_arg_->subject_alternative_names_size;
-             ++i) {
-          check_arg_->subject_alternative_names[i] =
-              subject_alternative_names[i];
+        if (check_arg_->subject_alternative_names != nullptr) {
+          for (size_t i = 0; i < check_arg_->subject_alternative_names_size;
+              ++i) {
+            delete[] check_arg_->subject_alternative_names[i];
+          }
+          delete[] check_arg_->subject_alternative_names;
         }
+        check_arg_->subject_alternative_names_size =
+            subject_alternative_names.size();
+        if (subject_alternative_names.empty()) {
+          check_arg_->subject_alternative_names = nullptr;
+        } else {
+          check_arg_->subject_alternative_names =
+              new char*[check_arg_->subject_alternative_names_size];
+          for (size_t i = 0; i < check_arg_->subject_alternative_names_size;
+              ++i) {
+            check_arg_->subject_alternative_names[i] =
+                subject_alternative_names[i];
+          }
+        }
+        int callback_status = config->Schedule(check_arg_);
+        /* Server authorization check is handled asynchronously. */
+        if (callback_status) {
+          tsi_peer_destruct(&peer);
+          return;
+        }
+        /* Server authorization check is handled synchronously. */
+        error = ProcessServerAuthorizationCheckResult(check_arg_);
       }
-      int callback_status = config->Schedule(check_arg_);
-      /* Server authorization check is handled asynchronously. */
-      if (callback_status) {
-        tsi_peer_destruct(&peer);
-        return;
-      }
-      /* Server authorization check is handled synchronously. */
-      error = ProcessServerAuthorizationCheckResult(check_arg_);
     }
   }
   ExecCtx::Run(DEBUG_LOCATION, on_peer_checked, error);
@@ -318,7 +327,7 @@ bool TlsChannelSecurityConnector::check_call_host(
     grpc_closure* /*on_call_host_checked*/, grpc_error_handle* error) {
   if (options_->server_verification_option() ==
           GRPC_TLS_SKIP_HOSTNAME_VERIFICATION ||
-      options_->server_verification_option() ==
+      options_->server_verification_option() >=
           GRPC_TLS_SKIP_ALL_SERVER_VERIFICATION) {
     return true;
   }
@@ -379,7 +388,7 @@ void TlsChannelSecurityConnector::TlsChannelCertificateWatcher::OnError(
 grpc_security_status
 TlsChannelSecurityConnector::UpdateHandshakerFactoryLocked() {
   bool skip_server_certificate_verification =
-      options_->server_verification_option() ==
+      options_->server_verification_option() >=
       GRPC_TLS_SKIP_ALL_SERVER_VERIFICATION;
   /* Free the client handshaker factory if exists. */
   if (client_handshaker_factory_ != nullptr) {
@@ -474,9 +483,9 @@ void TlsChannelSecurityConnector::ServerAuthorizationCheckArgDestroy(
   if (arg == nullptr) {
     return;
   }
-  gpr_free(const_cast<char*>(arg->target_name));
-  gpr_free(const_cast<char*>(arg->peer_cert));
-  gpr_free(const_cast<char*>(arg->peer_cert_full_chain));
+  gpr_check_free(const_cast<char*>(arg->target_name));
+  gpr_check_free(const_cast<char*>(arg->peer_cert));
+  gpr_check_free(const_cast<char*>(arg->peer_cert_full_chain));
   for (size_t i = 0; i < arg->subject_alternative_names_size; ++i) {
     delete[] arg->subject_alternative_names[i];
   }
@@ -486,6 +495,7 @@ void TlsChannelSecurityConnector::ServerAuthorizationCheckArgDestroy(
     arg->destroy_context(arg->context);
   }
   delete arg;
+  arg = nullptr;
 }
 
 // -------------------server security connector-------------------
@@ -509,12 +519,91 @@ TlsServerSecurityConnector::CreateTlsServerSecurityConnector(
                                                     std::move(options));
 }
 
+void TlsServerSecurityConnector::ClientAuthorizationCheckDone(
+    grpc_tls_server_authorization_check_arg* arg) {
+  GPR_ASSERT(arg != nullptr);
+  ExecCtx exec_ctx;
+  grpc_error_handle error = ProcessClientAuthorizationCheckResult(arg);
+  TlsServerSecurityConnector* connector =
+      static_cast<TlsServerSecurityConnector*>(arg->cb_user_data);
+  ExecCtx::Run(DEBUG_LOCATION, connector->on_peer_checked_, error);
+}
+
+grpc_error_handle
+TlsServerSecurityConnector::ProcessClientAuthorizationCheckResult(
+    grpc_tls_server_authorization_check_arg* arg) {
+  grpc_error_handle error = GRPC_ERROR_NONE;
+  /* Client authorization check is cancelled by caller. */
+  if (arg->status == GRPC_STATUS_CANCELLED) {
+    error = GRPC_ERROR_CREATE_FROM_COPIED_STRING(
+        absl::StrCat("Client authorization check is cancelled by the caller "
+                     "with error: ",
+                     arg->error_details->error_details())
+            .c_str());
+  } else if (arg->status == GRPC_STATUS_OK) {
+    /* Client authorization check completed successfully but returned check
+     * failure. */
+    if (!arg->success) {
+      error = GRPC_ERROR_CREATE_FROM_COPIED_STRING(
+          absl::StrCat("Client authorization check failed with error: ",
+                       arg->error_details->error_details())
+              .c_str());
+    }
+    /* Client authorization check did not complete correctly. */
+  } else {
+    error = GRPC_ERROR_CREATE_FROM_COPIED_STRING(
+        absl::StrCat(
+            "Client authorization check did not finish correctly with error: ",
+            arg->error_details->error_details())
+            .c_str());
+  }
+  return error;
+}
+
+grpc_tls_server_authorization_check_arg*
+TlsServerSecurityConnector::ClientAuthorizationCheckArgCreate(
+    void* user_data) {
+  grpc_tls_server_authorization_check_arg* arg =
+      new grpc_tls_server_authorization_check_arg();
+  arg->target_name = nullptr;
+  arg->peer_cert = nullptr;
+  arg->peer_cert_full_chain = nullptr;
+  arg->subject_alternative_names = nullptr;
+  arg->subject_alternative_names_size = 0;
+  arg->error_details = new grpc_tls_error_details();
+  arg->cb = ClientAuthorizationCheckDone;
+  arg->cb_user_data = user_data;
+  arg->status = GRPC_STATUS_OK;
+  return arg;
+}
+
+void TlsServerSecurityConnector::ClientAuthorizationCheckArgDestroy(
+    grpc_tls_server_authorization_check_arg* arg) {
+  if (arg == nullptr) {
+    return;
+  }
+  gpr_check_free(const_cast<char*>(arg->target_name));
+  gpr_check_free(const_cast<char*>(arg->peer_cert));
+  gpr_check_free(const_cast<char*>(arg->peer_cert_full_chain));
+  for (size_t i = 0; i < arg->subject_alternative_names_size; ++i) {
+    delete[] arg->subject_alternative_names[i];
+  }
+  delete[] arg->subject_alternative_names;
+  delete arg->error_details;
+  if (arg->destroy_context != nullptr) {
+    arg->destroy_context(arg->context);
+  }
+  delete arg;
+  arg = nullptr;
+}
+
 TlsServerSecurityConnector::TlsServerSecurityConnector(
     RefCountedPtr<grpc_server_credentials> server_creds,
     RefCountedPtr<grpc_tls_credentials_options> options)
     : grpc_server_security_connector(GRPC_SSL_URL_SCHEME,
                                      std::move(server_creds)),
       options_(std::move(options)) {
+  check_arg_ = ClientAuthorizationCheckArgCreate(this);
   // Create a watcher.
   auto watcher_ptr = absl::make_unique<TlsServerCertificateWatcher>(this);
   certificate_watcher_ = watcher_ptr.get();
@@ -539,10 +628,15 @@ TlsServerSecurityConnector::~TlsServerSecurityConnector() {
   // Cancel all the watchers.
   grpc_tls_certificate_distributor* distributor =
       options_->certificate_distributor();
-  distributor->CancelTlsCertificatesWatch(certificate_watcher_);
+  if (distributor != nullptr) {
+    distributor->CancelTlsCertificatesWatch(certificate_watcher_);
+  }
   if (server_handshaker_factory_ != nullptr) {
     tsi_ssl_server_handshaker_factory_unref(server_handshaker_factory_);
   }
+  if (check_arg_ != nullptr) {
+    ClientAuthorizationCheckArgDestroy(check_arg_);
+  }
 }
 
 void TlsServerSecurityConnector::add_handshakers(
@@ -574,10 +668,101 @@ void TlsServerSecurityConnector::check_peer(
     RefCountedPtr<grpc_auth_context>* auth_context,
     grpc_closure* on_peer_checked) {
   grpc_error_handle error = grpc_ssl_check_alpn(&peer);
+  if (error != GRPC_ERROR_NONE) {
+    ExecCtx::Run(DEBUG_LOCATION, on_peer_checked, error);
+    tsi_peer_destruct(&peer);
+    return;
+  }
   *auth_context =
       grpc_ssl_peer_to_auth_context(&peer, GRPC_TLS_TRANSPORT_SECURITY_TYPE);
-  tsi_peer_destruct(&peer);
+  if (options_->server_verification_option() == GRPC_TLS_SERVER_VERIFICATION) {
+    /* Do the default host name check if specifying the target name. */
+    error = internal::TlsCheckHostName("", &peer);
+    if (error != GRPC_ERROR_NONE) {
+      ExecCtx::Run(DEBUG_LOCATION, on_peer_checked, error);
+      tsi_peer_destruct(&peer);
+      return;
+    }
+  }
+  if (options_->server_verification_option() == GRPC_RA_TLS_TWO_WAY_VERIFICATION ||
+    options_->server_verification_option() == GRPC_RA_TLS_CLIENT_VERIFICATION) {
+    /* Do the custom client authorization check, if specified by the user. */
+    const grpc_tls_server_authorization_check_config* config =
+        options_->server_authorization_check_config();
+    /* If client authorization config is not null, use it to perform
+    * client authorization check. */
+    if (config != nullptr) {
+      const tsi_peer_property* p =
+          tsi_peer_get_property_by_name(&peer, TSI_X509_PEM_CERT_PROPERTY);
+      if (p == nullptr) {
+        error = GRPC_ERROR_CREATE_FROM_STATIC_STRING(
+            "Cannot check peer: missing pem cert property.");
+      } else {
+        char* peer_pem = static_cast<char*>(gpr_zalloc(p->value.length + 1));
+        memcpy(peer_pem, p->value.data, p->value.length);
+        GPR_ASSERT(check_arg_ != nullptr);
+        check_arg_->peer_cert = gpr_strdup(peer_pem);
+        check_arg_->target_name = gpr_strdup("");
+        on_peer_checked_ = on_peer_checked;
+        gpr_check_free(peer_pem);
+        const tsi_peer_property* chain = tsi_peer_get_property_by_name(
+            &peer, TSI_X509_PEM_CERT_CHAIN_PROPERTY);
+        if (chain != nullptr) {
+          char* peer_pem_chain =
+              static_cast<char*>(gpr_zalloc(chain->value.length + 1));
+          memcpy(peer_pem_chain, chain->value.data, chain->value.length);
+          check_arg_->peer_cert_full_chain =
+              check_arg_->peer_cert_full_chain == nullptr
+                  ? gpr_strdup(peer_pem_chain)
+                  : check_arg_->peer_cert_full_chain;
+          gpr_check_free(peer_pem_chain);
+        }
+        // TODO(zhenlian) - This should be cleaned up as part of the custom
+        // verification changes. Fill in the subject alternative names
+        std::vector<char*> subject_alternative_names;
+        for (size_t i = 0; i < peer.property_count; i++) {
+          const tsi_peer_property* prop = &peer.properties[i];
+          if (strcmp(prop->name,
+                    TSI_X509_SUBJECT_ALTERNATIVE_NAME_PEER_PROPERTY) == 0) {
+            char* san = new char[prop->value.length + 1];
+            memcpy(san, prop->value.data, prop->value.length);
+            san[prop->value.length] = '\0';
+            subject_alternative_names.emplace_back(san);
+          }
+        }
+        if (check_arg_->subject_alternative_names != nullptr) {
+          for (size_t i = 0; i < check_arg_->subject_alternative_names_size;
+              ++i) {
+            delete[] check_arg_->subject_alternative_names[i];
+          }
+          delete[] check_arg_->subject_alternative_names;
+        }
+        check_arg_->subject_alternative_names_size =
+            subject_alternative_names.size();
+        if (subject_alternative_names.empty()) {
+          check_arg_->subject_alternative_names = nullptr;
+        } else {
+          check_arg_->subject_alternative_names =
+              new char*[check_arg_->subject_alternative_names_size];
+          for (size_t i = 0; i < check_arg_->subject_alternative_names_size;
+              ++i) {
+            check_arg_->subject_alternative_names[i] =
+                subject_alternative_names[i];
+          }
+        }
+        int callback_status = config->Schedule(check_arg_);
+        /* Client authorization check is handled asynchronously. */
+        if (callback_status) {
+          tsi_peer_destruct(&peer);
+          return;
+        }
+        /* Client authorization check is handled synchronously. */
+        error = ProcessClientAuthorizationCheckResult(check_arg_);
+      }
+    }
+  }
   ExecCtx::Run(DEBUG_LOCATION, on_peer_checked, error);
+  tsi_peer_destruct(&peer);
 }
 
 int TlsServerSecurityConnector::cmp(
diff --git a/src/core/lib/security/security_connector/tls/tls_security_connector.h b/src/core/lib/security/security_connector/tls/tls_security_connector.h
index 80c26954ac..cd830b9b7a 100644
--- a/src/core/lib/security/security_connector/tls/tls_security_connector.h
+++ b/src/core/lib/security/security_connector/tls/tls_security_connector.h
@@ -219,9 +219,31 @@ class TlsServerSecurityConnector final : public grpc_server_security_connector {
   grpc_security_status UpdateHandshakerFactoryLocked()
       ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);
 
+  // gRPC-provided callback executed by application, which servers to bring the
+  // control back to gRPC core.
+  static void ClientAuthorizationCheckDone(
+      grpc_tls_server_authorization_check_arg* arg);
+
+  // A util function to process server authorization check result.
+  static grpc_error_handle ProcessClientAuthorizationCheckResult(
+      grpc_tls_server_authorization_check_arg* arg);
+
+  // A util function to create a server authorization check arg instance.
+  static grpc_tls_server_authorization_check_arg*
+      ClientAuthorizationCheckArgCreate(void* user_data);
+
+  // A util function to destroy a server authorization check arg instance.
+  static void ClientAuthorizationCheckArgDestroy(
+      grpc_tls_server_authorization_check_arg* arg);
+
   RefCountedPtr<grpc_tls_credentials_options> options_;
+
   grpc_tls_certificate_distributor::TlsCertificatesWatcherInterface*
       certificate_watcher_ = nullptr;
+  grpc_closure* on_peer_checked_ = nullptr;
+  std::string target_name_ = "localhost";
+  std::string overridden_target_name_= "localhost";
+  grpc_tls_server_authorization_check_arg* check_arg_ = nullptr;
 
   Mutex mu_;
   tsi_ssl_server_handshaker_factory* server_handshaker_factory_
diff --git a/src/cpp/sgx/azure_tdx/AttestClient.h b/src/cpp/sgx/azure_tdx/AttestClient.h
new file mode 100644
index 0000000000..6019d9c6ac
--- /dev/null
+++ b/src/cpp/sgx/azure_tdx/AttestClient.h
@@ -0,0 +1,86 @@
+
+#pragma once
+
+#include <fstream>
+#include <iostream>
+#include <unordered_map>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+#include "HttpClient_I.h"
+#include "Utils.h"
+#include <nlohmann/json.hpp>
+
+using json = nlohmann::json;
+
+namespace AttestClient {
+  typedef struct Config {
+    std::string attestation_url;
+    std::string attestation_type;
+    std::string evidence;
+    std::string claims;
+    std::string api_key;
+  } Config;
+
+  inline std::string VerifyEvidence(const AttestClient::Config &config, HttpClient_I &http_client) {
+    std::string url = config.attestation_url;
+    std::string encoded_quote = config.evidence;
+    std::string encoded_claims = config.claims;
+    std::string attestation_type = config.attestation_type;
+
+    // headers needed for requests
+    std::vector<std::string> headers = {
+        "Accept:application/json",
+        "Content-Type:application/json"};
+
+    // checks where we are sending the request
+    std::stringstream stream;
+    if (Utils::case_insensitive_compare(attestation_type, "maa")) {
+      stream << "{\"quote\":\"" << encoded_quote << "\"}";
+    }
+    else if (Utils::case_insensitive_compare(attestation_type, "amber")) {
+      std::string api_key_header = "x-api-key:" + config.api_key;
+      headers.push_back(api_key_header.c_str());
+      stream << "{\"quote\":\"" << Utils::base64url_to_base64(encoded_quote) << "\"";
+
+      // if (!encoded_claims.empty()) {
+      //   stream << ",\"user_data\":\"" << Utils::base64url_to_base64(encoded_claims) << "\"";
+      // }
+      stream << "}";
+    }
+    else {
+      throw std::runtime_error("Attestation type was not provided");
+    }
+
+    std::string response;
+    std::string request_body = stream.str();
+
+    std::cout << "Starting attestation request..." << std::endl;
+    std::cout << "Attestation endpoint: " << url << std::endl;
+
+    int status = http_client.InvokeHttpRequest(
+        response,
+        url,
+        HttpClient_I::HttpVerb::POST,
+        headers,
+        request_body);
+
+    if (status != 0) {
+      std::stringstream stream;
+      stream << "Failed to reach attestation endpoint. Error Code: " << std::to_string(status);
+      throw std::runtime_error(stream.str());
+    }
+
+    if (response.empty()) {
+      throw std::runtime_error("Empty reponse received from attestation endpoint");
+    }
+
+    try {
+      json json_response = json::parse(response);
+      return json_response["token"];
+    }
+    catch (const std::exception &e) {
+      throw;
+    }
+  }
+};
diff --git a/src/cpp/sgx/azure_tdx/HttpClient.cpp b/src/cpp/sgx/azure_tdx/HttpClient.cpp
new file mode 100644
index 0000000000..867370be28
--- /dev/null
+++ b/src/cpp/sgx/azure_tdx/HttpClient.cpp
@@ -0,0 +1,140 @@
+//-------------------------------------------------------------------------------------------------
+// <copyright file="HttpClient.cpp" company="Microsoft Corporation">
+// Copyright (c) Microsoft Corporation.  All rights reserved.
+// </copyright>
+//-------------------------------------------------------------------------------------------------
+
+#include <math.h>
+#include <fstream>
+#include <iostream>
+#include <unordered_map>
+#include <stdio.h>
+#include <unistd.h>
+#include "HttpClient.h"
+
+#define HTTP_STATUS_OK 200
+#define HTTP_STATUS_BAD_REQUEST 400
+#define HTTP_STATUS_RESOURCE_NOT_FOUND 404
+#define HTTP_STATUS_TOO_MANY_REQUESTS 429
+#define HTTP_STATUS_INTERNAL_SERVER_ERROR 500
+#define MAX_RETRIES 3
+
+using namespace std;
+
+HttpClientResult HttpClient::InvokeHttpRequest(std::string& http_response,
+                                                const std::string& url,
+                                                const HttpClient_I::HttpVerb& http_verb,
+                                                const std::vector<std::string>& header_list,
+                                                const std::string& request_body) {
+
+    // Set the the headers for the request
+    struct curl_slist* headers = NULL;
+    for (const auto &header : header_list) {
+        headers = curl_slist_append(headers, header.c_str());
+    }
+    curl_easy_setopt(curl_handle, CURLOPT_HTTPHEADER, headers);
+
+    // Send a pointer to a std::string to hold the response from the end
+    // point along with the handler function.
+    std::string response;
+    curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, WriteResponseCallback);
+    curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, &response);
+
+    // Set the url of the end point that we are trying to talk to.
+    curl_easy_setopt(curl_handle, CURLOPT_URL, url.c_str());
+
+    // Enable SSL/TLS for the connection
+    curl_easy_setopt(curl_handle, CURLOPT_SSL_VERIFYPEER, 1L);
+    curl_easy_setopt(curl_handle, CURLOPT_SSL_VERIFYHOST, 2L);
+
+    // Set SSL versions to be used
+    curl_easy_setopt(curl_handle, CURLOPT_SSLVERSION, CURL_SSLVERSION_TLSv1_2);
+
+    // SUSE Linux uses different SSL cert path than Ubuntu
+    std::string ca_cert_path("/etc/ssl/ca-bundle.pem");
+    if (access(ca_cert_path.c_str(), F_OK) != -1)
+        curl_easy_setopt(curl_handle, CURLOPT_CAINFO, ca_cert_path.c_str());
+
+    if (http_verb == HttpClient::HttpVerb::POST) {
+        if (request_body.empty()) {
+            fprintf(stderr, "Request body missing for POST request");
+            return HttpClientResult::MISSING_REQUEST_BODY;
+        }
+
+        // Set Http verb as POST
+        curl_easy_setopt(curl_handle, CURLOPT_CUSTOMREQUEST, "POST");
+
+        // set the payload that will be sent to the endpoint.
+        curl_easy_setopt(curl_handle, CURLOPT_POSTFIELDS, request_body.c_str());
+        curl_easy_setopt(curl_handle, CURLOPT_POSTFIELDSIZE, request_body.size());
+    }
+
+    // Adding timeout for 300 sec
+    curl_easy_setopt(curl_handle, CURLOPT_TIMEOUT, 300L);
+    CURLcode res;
+
+    uint8_t retries = 0;
+    while ((res = curl_easy_perform(curl_handle)) == CURLE_OK) {
+        long response_code = HTTP_STATUS_OK;
+        curl_easy_getinfo(curl_handle, CURLINFO_RESPONSE_CODE, &response_code);
+
+        if (HTTP_STATUS_OK == response_code) {
+            http_response = response;
+            if (http_response.size() == 0) {
+                fprintf(stderr, "Empty http response received");
+            }
+
+            break;
+        }
+        else if (response_code == HTTP_STATUS_RESOURCE_NOT_FOUND ||
+            response_code == HTTP_STATUS_TOO_MANY_REQUESTS ||
+            response_code >= HTTP_STATUS_INTERNAL_SERVER_ERROR) {
+            if (retries == MAX_RETRIES) {
+                fprintf(stderr, "HTTP request failed with response code: %lu, description: %s\n\n", response_code, response.c_str());
+                break;
+            }
+            fprintf(stderr, "HTTP request failed with response code: %lu, description: %s\n\n", response_code, response.c_str());
+
+            // Retry with backoff 30 -> 60 -> 120 seconds
+            std::this_thread::sleep_for(
+                std::chrono::seconds(
+                    static_cast<long long>(30 * pow(2.0, static_cast<double>(retries++)))
+                ));
+
+            response = std::string();
+            continue;
+        }
+        else
+        {
+            fprintf(stderr, "HTTP request failed with response code: %lu, description: %s\n\n", response_code, response.c_str());
+            break;
+        }
+    }
+
+    if (res != CURLE_OK) {
+        string error = std::string("Failed sending curl_handle request with error:") + std::string(curl_easy_strerror(res));
+        fprintf(stderr, "%s", error.c_str());
+        curl_slist_free_all(headers);
+        return HttpClientResult::FAILED;
+    }
+
+    curl_slist_free_all(headers);
+
+    return HttpClientResult::SUCCESS;
+}
+
+size_t HttpClient::WriteResponseCallback(void* contents, size_t size, size_t nmemb, void* response)
+{
+    if (response == nullptr ||
+        contents == nullptr) {
+        return 0;
+    }
+    std::string* responsePtr = reinterpret_cast<std::string*>(response);
+
+    char* contentsStr = (char*)contents;
+    size_t contentsSize = size * nmemb;
+
+    responsePtr->insert(responsePtr->end(), contentsStr, contentsStr + contentsSize);
+
+    return contentsSize;
+}
diff --git a/src/cpp/sgx/azure_tdx/HttpClient.h b/src/cpp/sgx/azure_tdx/HttpClient.h
new file mode 100644
index 0000000000..86eba7f828
--- /dev/null
+++ b/src/cpp/sgx/azure_tdx/HttpClient.h
@@ -0,0 +1,64 @@
+//-------------------------------------------------------------------------------------------------
+// <copyright file="HttpClient.h" company="Microsoft Corporation">
+// Copyright (c) Microsoft Corporation.  All rights reserved.
+// </copyright>
+//-------------------------------------------------------------------------------------------------
+
+#pragma once
+
+#include <curl/curl.h>
+#include <chrono>
+#include <thread>
+#include <math.h>
+#include <fstream>
+#include <iostream>
+#include <unordered_map>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+#include <vector>
+#include "HttpClient_I.h"
+
+
+class HttpClient : public HttpClient_I{
+public:
+    HttpClient() {
+        curl_global_cleanup();
+        curl_handle = curl_easy_init();
+        if (curl_handle == nullptr) {
+            fprintf(stderr, "Failed to initialize curl_handle for http request.");
+            curl_global_cleanup();
+            exit(1);
+        }
+    }
+
+    ~HttpClient() {
+        curl_easy_cleanup(curl_handle);
+        curl_global_cleanup();
+    }
+
+    /**
+     *@brief This function will be used to send a http request
+     * @param[in] url, the url endpoint to be called
+     * @param[in] http_verb, the HTTP verb (GET or POST)
+     * @param[in] request_body, the request body. This is expected for any POST calls.
+     * @param[out] http_response The response received from the endpoint.
+     * @return On sucess, the function returns REQUEST_SUCCESS and
+     * the http_response is set to the response from the end point.
+     * On failure, an error code is returned.
+     */
+    HttpClientResult InvokeHttpRequest(std::string &http_response,
+                              const std::string &url,
+                              const HttpClient::HttpVerb &http_verb,
+                              const std::vector<std::string>& headers,
+                              const std::string &request_body = std::string()) override;
+
+private:
+    CURL *curl_handle;
+
+    /**
+     * @brief CURL Callback to write response to a user specified pointer
+     */
+    static size_t WriteResponseCallback(void* contents, size_t size, size_t nmemb, void* response);
+
+};
\ No newline at end of file
diff --git a/src/cpp/sgx/azure_tdx/HttpClient_I.h b/src/cpp/sgx/azure_tdx/HttpClient_I.h
new file mode 100644
index 0000000000..e214333647
--- /dev/null
+++ b/src/cpp/sgx/azure_tdx/HttpClient_I.h
@@ -0,0 +1,42 @@
+#pragma once
+#include <chrono>
+#include <thread>
+#include <math.h>
+#include <fstream>
+#include <iostream>
+#include <unordered_map>
+#include <stdio.h>
+#include <string.h>
+#include <stdint.h>
+#include <vector>
+
+typedef enum HttpClientResult {
+  SUCCESS = 0,
+  FAILED = 1,
+  MISSING_REQUEST_BODY = 2,
+} HttpClientResult;
+
+class HttpClient_I {
+public:
+  enum class HttpVerb {
+    GET,
+    POST
+  };
+
+  /**
+   *@brief This function will be used to send a http request
+   * @param[in] url, the url endpoint to be called
+   * @param[in] http_verb, the HTTP verb (GET or POST)
+   * @param[in] headers, a vector of string for each header type needed for the request
+   * @param[in] request_body, the request body. This is expected for any POST calls.
+   * @param[out] http_response The response received from the endpoint.
+   * @return On sucess, the function returns REQUEST_SUCCESS and
+   * the http_response is set to the response from the end point.
+   * On failure, an error code is returned.
+   */
+  virtual HttpClientResult InvokeHttpRequest(std::string &http_response,
+                                     const std::string &url,
+                                     const HttpClient_I::HttpVerb &http_verb,
+                                     const std::vector<std::string> &headers,
+                                     const std::string &request_body = std::string()) = 0;
+};
\ No newline at end of file
diff --git a/src/cpp/sgx/azure_tdx/Logger.h b/src/cpp/sgx/azure_tdx/Logger.h
new file mode 100644
index 0000000000..9f6ea239e0
--- /dev/null
+++ b/src/cpp/sgx/azure_tdx/Logger.h
@@ -0,0 +1,41 @@
+#pragma once
+
+#include <iostream>
+#include <stdarg.h>
+#include <vector>
+#include <azguestattestation1/AttestationClient.h>
+#include <stdio.h>
+#include <memory>
+#include <mutex>
+#include <fstream>
+#include <sstream>
+#include <ctime>
+#include <chrono>
+#include <iomanip>
+#include <azguestattestation1/AttestationClient.h>
+#include "Logger.h"
+
+class Logger : public attest::AttestationLogger
+{
+public:
+    void Log(const char *log_tag,
+             LogLevel level,
+             const char *function,
+             const int line,
+             const char *fmt,
+             ...) {
+        va_list args;
+        va_start(args, fmt);
+        size_t len = std::vsnprintf(NULL, 0, fmt, args);
+        va_end(args);
+
+        std::vector<char> str(len + 1);
+
+        va_start(args, fmt);
+        std::vsnprintf(&str[0], len + 1, fmt, args);
+        va_end(args);
+
+        // Print Logs, comment and recompilte to suppress logs
+        printf("Level: %s Tag: %s %s:%d:%s\n", attest::AttestationLogger::LogLevelStrings[level].c_str(), log_tag, function, line, &str[0]);
+    }
+};
diff --git a/src/cpp/sgx/azure_tdx/Utils.h b/src/cpp/sgx/azure_tdx/Utils.h
new file mode 100644
index 0000000000..51ea8fd631
--- /dev/null
+++ b/src/cpp/sgx/azure_tdx/Utils.h
@@ -0,0 +1,87 @@
+#pragma once
+
+#include <boost/archive/iterators/base64_from_binary.hpp>
+#include <boost/archive/iterators/binary_from_base64.hpp>
+#include <boost/archive/iterators/transform_width.hpp>
+#include <boost/algorithm/string.hpp>
+#include <cstdlib>
+#include <string>
+#include <vector>
+
+#define AMBER_API_KEY_NAME "AMBER_API_KEY"
+
+namespace Utils {
+    /**
+     * Given a base64url encoded string, convert it to binary byte vector
+     *
+     * param[in] base64_data : string of base64url encoded data
+     *
+     * returns: vector of unsigned char (byte)
+     */
+    inline std::vector<unsigned char> base64url_to_binary(const std::string &base64_data) {
+        using namespace boost::archive::iterators;
+        using It = transform_width<binary_from_base64<std::string::const_iterator>, 8, 6>;
+        std::string stringData = base64_data;
+
+        // While decoding base64 url, replace - with + and _ with + and
+        // use stanard base64 decode. we dont need to add padding characters. underlying library handles it.
+        boost::replace_all(stringData, "-", "+");
+        boost::replace_all(stringData, "_", "/");
+
+        return std::vector<unsigned char>(It(std::begin(stringData)), It(std::end(stringData)));
+    }
+
+    /**
+     * Given a binary byte vector, convert it to base64url encoded string
+     *
+     * param[in] binary_data:  vector of unsigned char (byte)
+     *
+     * returns: string of base64url encoded data
+     */
+    inline std::string binary_to_base64url(const std::vector<unsigned char> &binary_data) {
+        using namespace boost::archive::iterators;
+        using It = base64_from_binary<transform_width<std::vector<unsigned char>::const_iterator, 6, 8>>;
+        auto tmp = std::string(It(std::begin(binary_data)), It(std::end(binary_data)));
+
+        // For encoding to base64url, replace "+" with "-" and "/" with "_"
+        boost::replace_all(tmp, "+", "-");
+        boost::replace_all(tmp, "/", "_");
+
+        // We do not need to add padding characters while url encoding.
+        return tmp;
+    }
+
+    inline std::string base64url_to_base64(const std::string &base64_data) {
+        std::string stringData = base64_data;
+
+        // While decoding base64 url, replace - with + and _ with + and
+        // use stanard base64 decode. we dont need to add padding characters. underlying library handles it.
+        boost::replace_all(stringData, "-", "+");
+        boost::replace_all(stringData, "_", "/");
+
+        // Needs to calculate the padding needed at the end
+        int padding = (4 - base64_data.size() % 4) % 4;
+        for (int i = 0; i < padding; i++) {
+            stringData.push_back('=');
+        }
+
+        return stringData;
+    }
+
+    /**
+     * Compares two string case insensitive
+     *
+     * param[in] str1 first string
+     * param[in] str2 second string
+     *
+     * returns: true if equal, false otherwise
+     */
+    inline bool case_insensitive_compare(const std::string &str1, const std::string &str2) {
+        std::string lower_str1 = str1;
+        std::string lower_str2 = str2;
+
+        std::transform(lower_str1.begin(), lower_str1.end(), lower_str1.begin(), ::tolower);
+        std::transform(lower_str2.begin(), lower_str2.end(), lower_str2.begin(), ::tolower);
+        return lower_str2 == lower_str1;
+    }
+};
\ No newline at end of file
diff --git a/src/cpp/sgx/cJSON.c b/src/cpp/sgx/cJSON.c
new file mode 100644
index 0000000000..7fd0dbc8ca
--- /dev/null
+++ b/src/cpp/sgx/cJSON.c
@@ -0,0 +1,567 @@
+/*
+  Copyright (c) 2009 Dave Gamble
+
+  Permission is hereby granted, free of charge, to any person obtaining a copy
+  of this software and associated documentation files (the "Software"), to deal
+  in the Software without restriction, including without limitation the rights
+  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+  copies of the Software, and to permit persons to whom the Software is
+  furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included in
+  all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+  THE SOFTWARE.
+*/
+
+/* cJSON */
+/* JSON parser in C. */
+
+#include <string.h>
+#include <stdio.h>
+#include <math.h>
+#include <stdlib.h>
+#include <float.h>
+#include <limits.h>
+#include <ctype.h>
+#include <grpcpp/security/sgx/cJSON.h>
+
+static const char *ep;
+
+const char *cJSON_GetErrorPtr(void) {return ep;}
+
+static int cJSON_strcasecmp(const char *s1,const char *s2)
+{
+	if (!s1) return (s1==s2)?0:1;if (!s2) return 1;
+	for(; tolower(*s1) == tolower(*s2); ++s1, ++s2)	if(*s1 == 0)	return 0;
+	return tolower(*(const unsigned char *)s1) - tolower(*(const unsigned char *)s2);
+}
+
+static void *(*cJSON_malloc)(size_t sz) = malloc;
+static void (*cJSON_free)(void *ptr) = free;
+
+static char* cJSON_strdup(const char* str)
+{
+      size_t len;
+      char* copy;
+
+      len = strlen(str) + 1;
+      if (!(copy = (char*)cJSON_malloc(len))) return 0;
+      memcpy(copy,str,len);
+      return copy;
+}
+
+void cJSON_InitHooks(cJSON_Hooks* hooks)
+{
+    if (!hooks) { /* Reset hooks */
+        cJSON_malloc = malloc;
+        cJSON_free = free;
+        return;
+    }
+
+	cJSON_malloc = (hooks->malloc_fn)?hooks->malloc_fn:malloc;
+	cJSON_free	 = (hooks->free_fn)?hooks->free_fn:free;
+}
+
+/* Internal constructor. */
+static cJSON *cJSON_New_Item(void)
+{
+	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));
+	if (node) memset(node,0,sizeof(cJSON));
+	return node;
+}
+
+/* Delete a cJSON structure. */
+void cJSON_Delete(cJSON *c)
+{
+	cJSON *next;
+	while (c)
+	{
+		next=c->next;
+		if (!(c->type&cJSON_IsReference) && c->child) cJSON_Delete(c->child);
+		if (!(c->type&cJSON_IsReference) && c->valuestring) cJSON_free(c->valuestring);
+		if (c->string) cJSON_free(c->string);
+		cJSON_free(c);
+		c=next;
+	}
+}
+
+/* Parse the input text to generate a number, and populate the result into item. */
+static const char *parse_number(cJSON *item,const char *num)
+{
+	double n=0,sign=1,scale=0;int subscale=0,signsubscale=1;
+
+	/* Could use sscanf for this? */
+	if (*num=='-') sign=-1,num++;	/* Has sign? */
+	if (*num=='0') num++;			/* is zero */
+	if (*num>='1' && *num<='9')	do	n=(n*10.0)+(*num++ -'0');	while (*num>='0' && *num<='9');	/* Number? */
+	if (*num=='.' && num[1]>='0' && num[1]<='9') {num++;		do	n=(n*10.0)+(*num++ -'0'),scale--; while (*num>='0' && *num<='9');}	/* Fractional part? */
+	if (*num=='e' || *num=='E')		/* Exponent? */
+	{	num++;if (*num=='+') num++;	else if (*num=='-') signsubscale=-1,num++;		/* With sign? */
+		while (*num>='0' && *num<='9') subscale=(subscale*10)+(*num++ - '0');	/* Number? */
+	}
+
+	n=sign*n*pow(10.0,(scale+subscale*signsubscale));	/* number = +/- number.fraction * 10^+/- exponent */
+	
+	item->valuedouble=n;
+	item->valueint=(int)n;
+	item->type=cJSON_Number;
+	return num;
+}
+
+/* Render the number nicely from the given item into a string. */
+static char *print_number(cJSON *item)
+{
+	char *str;
+	double d=item->valuedouble;
+	if (fabs(((double)item->valueint)-d)<=DBL_EPSILON && d<=INT_MAX && d>=INT_MIN)
+	{
+		str=(char*)cJSON_malloc(21);	/* 2^64+1 can be represented in 21 chars. */
+		if (str) sprintf(str,"%d",item->valueint);
+	}
+	else
+	{
+		str=(char*)cJSON_malloc(64);	/* This is a nice tradeoff. */
+		if (str)
+		{
+			if (fabs(floor(d)-d)<=DBL_EPSILON && fabs(d)<1.0e60)sprintf(str,"%.0f",d);
+			else if (fabs(d)<1.0e-6 || fabs(d)>1.0e9)			sprintf(str,"%e",d);
+			else												sprintf(str,"%f",d);
+		}
+	}
+	return str;
+}
+
+/* Parse the input text into an unescaped cstring, and populate item. */
+static const unsigned char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
+static const char *parse_string(cJSON *item,const char *str)
+{
+	const char *ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;
+	if (*str!='\"') {ep=str;return 0;}	/* not a string! */
+	
+	while (*ptr!='\"' && *ptr && ++len) if (*ptr++ == '\\') ptr++;	/* Skip escaped quotes. */
+	
+	out=(char*)cJSON_malloc(len+1);	/* This is how long we need for the string, roughly. */
+	if (!out) return 0;
+	
+	ptr=str+1;ptr2=out;
+	while (*ptr!='\"' && *ptr)
+	{
+		if (*ptr!='\\') *ptr2++=*ptr++;
+		else
+		{
+			ptr++;
+			switch (*ptr)
+			{
+				case 'b': *ptr2++='\b';	break;
+				case 'f': *ptr2++='\f';	break;
+				case 'n': *ptr2++='\n';	break;
+				case 'r': *ptr2++='\r';	break;
+				case 't': *ptr2++='\t';	break;
+				case 'u':	 /* transcode utf16 to utf8. */
+					sscanf(ptr+1,"%4x",&uc);ptr+=4;	/* get the unicode char. */
+
+					if ((uc>=0xDC00 && uc<=0xDFFF) || uc==0)	break;	/* check for invalid.	*/
+
+					if (uc>=0xD800 && uc<=0xDBFF)	/* UTF16 surrogate pairs.	*/
+					{
+						if (ptr[1]!='\\' || ptr[2]!='u')	break;	/* missing second-half of surrogate.	*/
+						sscanf(ptr+3,"%4x",&uc2);ptr+=6;
+						if (uc2<0xDC00 || uc2>0xDFFF)		break;	/* invalid second-half of surrogate.	*/
+						uc=0x10000 + (((uc&0x3FF)<<10) | (uc2&0x3FF));
+					}
+
+					len=4;if (uc<0x80) len=1;else if (uc<0x800) len=2;else if (uc<0x10000) len=3; ptr2+=len;
+					
+					switch (len) {
+						case 4: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
+						case 3: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
+						case 2: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
+						case 1: *--ptr2 =(uc | firstByteMark[len]);
+					}
+					ptr2+=len;
+					break;
+				default:  *ptr2++=*ptr; break;
+			}
+			ptr++;
+		}
+	}
+	*ptr2=0;
+	if (*ptr=='\"') ptr++;
+	item->valuestring=out;
+	item->type=cJSON_String;
+	return ptr;
+}
+
+/* Render the cstring provided to an escaped version that can be printed. */
+static char *print_string_ptr(const char *str)
+{
+	const char *ptr;char *ptr2,*out;int len=0;unsigned char token;
+	
+	if (!str) return cJSON_strdup("");
+	ptr=str;while ((token=*ptr) && ++len) {if (strchr("\"\\\b\f\n\r\t",token)) len++; else if (token<32) len+=5;ptr++;}
+	
+	out=(char*)cJSON_malloc(len+3);
+	if (!out) return 0;
+
+	ptr2=out;ptr=str;
+	*ptr2++='\"';
+	while (*ptr)
+	{
+		if ((unsigned char)*ptr>31 && *ptr!='\"' && *ptr!='\\') *ptr2++=*ptr++;
+		else
+		{
+			*ptr2++='\\';
+			switch (token=*ptr++)
+			{
+				case '\\':	*ptr2++='\\';	break;
+				case '\"':	*ptr2++='\"';	break;
+				case '\b':	*ptr2++='b';	break;
+				case '\f':	*ptr2++='f';	break;
+				case '\n':	*ptr2++='n';	break;
+				case '\r':	*ptr2++='r';	break;
+				case '\t':	*ptr2++='t';	break;
+				default: sprintf(ptr2,"u%04x",token);ptr2+=5;	break;	/* escape and print */
+			}
+		}
+	}
+	*ptr2++='\"';*ptr2++=0;
+	return out;
+}
+/* Invote print_string_ptr (which is useful) on an item. */
+static char *print_string(cJSON *item)	{return print_string_ptr(item->valuestring);}
+
+/* Predeclare these prototypes. */
+static const char *parse_value(cJSON *item,const char *value);
+static char *print_value(cJSON *item,int depth,int fmt);
+static const char *parse_array(cJSON *item,const char *value);
+static char *print_array(cJSON *item,int depth,int fmt);
+static const char *parse_object(cJSON *item,const char *value);
+static char *print_object(cJSON *item,int depth,int fmt);
+
+/* Utility to jump whitespace and cr/lf */
+static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}
+
+/* Parse an object - create a new root, and populate. */
+cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated)
+{
+	const char *end=0;
+	cJSON *c=cJSON_New_Item();
+	ep=0;
+	if (!c) return 0;       /* memory fail */
+
+	end=parse_value(c,skip(value));
+	if (!end)	{cJSON_Delete(c);return 0;}	/* parse failure. ep is set. */
+
+	/* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */
+	if (require_null_terminated) {end=skip(end);if (*end) {cJSON_Delete(c);ep=end;return 0;}}
+	if (return_parse_end) *return_parse_end=end;
+	return c;
+}
+/* Default options for cJSON_Parse */
+cJSON *cJSON_Parse(const char *value) {return cJSON_ParseWithOpts(value,0,0);}
+
+/* Render a cJSON item/entity/structure to text. */
+char *cJSON_Print(cJSON *item)				{return print_value(item,0,1);}
+char *cJSON_PrintUnformatted(cJSON *item)	{return print_value(item,0,0);}
+
+/* Parser core - when encountering text, process appropriately. */
+static const char *parse_value(cJSON *item,const char *value)
+{
+	if (!value)						return 0;	/* Fail on null. */
+	if (!strncmp(value,"null",4))	{ item->type=cJSON_NULL;  return value+4; }
+	if (!strncmp(value,"false",5))	{ item->type=cJSON_False; return value+5; }
+	if (!strncmp(value,"true",4))	{ item->type=cJSON_True; item->valueint=1;	return value+4; }
+	if (*value=='\"')				{ return parse_string(item,value); }
+	if (*value=='-' || (*value>='0' && *value<='9'))	{ return parse_number(item,value); }
+	if (*value=='[')				{ return parse_array(item,value); }
+	if (*value=='{')				{ return parse_object(item,value); }
+
+	ep=value;return 0;	/* failure. */
+}
+
+/* Render a value to text. */
+static char *print_value(cJSON *item,int depth,int fmt)
+{
+	char *out=0;
+	if (!item) return 0;
+	switch ((item->type)&255)
+	{
+		case cJSON_NULL:	out=cJSON_strdup("null");	break;
+		case cJSON_False:	out=cJSON_strdup("false");break;
+		case cJSON_True:	out=cJSON_strdup("true"); break;
+		case cJSON_Number:	out=print_number(item);break;
+		case cJSON_String:	out=print_string(item);break;
+		case cJSON_Array:	out=print_array(item,depth,fmt);break;
+		case cJSON_Object:	out=print_object(item,depth,fmt);break;
+	}
+	return out;
+}
+
+/* Build an array from input text. */
+static const char *parse_array(cJSON *item,const char *value)
+{
+	cJSON *child;
+	if (*value!='[')	{ep=value;return 0;}	/* not an array! */
+
+	item->type=cJSON_Array;
+	value=skip(value+1);
+	if (*value==']') return value+1;	/* empty array. */
+
+	item->child=child=cJSON_New_Item();
+	if (!item->child) return 0;		 /* memory fail */
+	value=skip(parse_value(child,skip(value)));	/* skip any spacing, get the value. */
+	if (!value) return 0;
+
+	while (*value==',')
+	{
+		cJSON *new_item;
+		if (!(new_item=cJSON_New_Item())) return 0; 	/* memory fail */
+		child->next=new_item;new_item->prev=child;child=new_item;
+		value=skip(parse_value(child,skip(value+1)));
+		if (!value) return 0;	/* memory fail */
+	}
+
+	if (*value==']') return value+1;	/* end of array */
+	ep=value;return 0;	/* malformed. */
+}
+
+/* Render an array to text */
+static char *print_array(cJSON *item,int depth,int fmt)
+{
+	char **entries;
+	char *out=0,*ptr,*ret;int len=5;
+	cJSON *child=item->child;
+	int numentries=0,i=0,fail=0;
+	
+	/* How many entries in the array? */
+	while (child) numentries++,child=child->next;
+	/* Explicitly handle numentries==0 */
+	if (!numentries)
+	{
+		out=(char*)cJSON_malloc(3);
+		if (out) strcpy(out,"[]");
+		return out;
+	}
+	/* Allocate an array to hold the values for each */
+	entries=(char**)cJSON_malloc(numentries*sizeof(char*));
+	if (!entries) return 0;
+	memset(entries,0,numentries*sizeof(char*));
+	/* Retrieve all the results: */
+	child=item->child;
+	while (child && !fail)
+	{
+		ret=print_value(child,depth+1,fmt);
+		entries[i++]=ret;
+		if (ret) len+=strlen(ret)+2+(fmt?1:0); else fail=1;
+		child=child->next;
+	}
+	
+	/* If we didn't fail, try to malloc the output string */
+	if (!fail) out=(char*)cJSON_malloc(len);
+	/* If that fails, we fail. */
+	if (!out) fail=1;
+
+	/* Handle failure. */
+	if (fail)
+	{
+		for (i=0;i<numentries;i++) if (entries[i]) cJSON_free(entries[i]);
+		cJSON_free(entries);
+		return 0;
+	}
+	
+	/* Compose the output array. */
+	*out='[';
+	ptr=out+1;*ptr=0;
+	for (i=0;i<numentries;i++)
+	{
+		strcpy(ptr,entries[i]);ptr+=strlen(entries[i]);
+		if (i!=numentries-1) {*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;}
+		cJSON_free(entries[i]);
+	}
+	cJSON_free(entries);
+	*ptr++=']';*ptr++=0;
+	return out;	
+}
+
+/* Build an object from the text. */
+static const char *parse_object(cJSON *item,const char *value)
+{
+	cJSON *child;
+	if (*value!='{')	{ep=value;return 0;}	/* not an object! */
+	
+	item->type=cJSON_Object;
+	value=skip(value+1);
+	if (*value=='}') return value+1;	/* empty array. */
+	
+	item->child=child=cJSON_New_Item();
+	if (!item->child) return 0;
+	value=skip(parse_string(child,skip(value)));
+	if (!value) return 0;
+	child->string=child->valuestring;child->valuestring=0;
+	if (*value!=':') {ep=value;return 0;}	/* fail! */
+	value=skip(parse_value(child,skip(value+1)));	/* skip any spacing, get the value. */
+	if (!value) return 0;
+	
+	while (*value==',')
+	{
+		cJSON *new_item;
+		if (!(new_item=cJSON_New_Item()))	return 0; /* memory fail */
+		child->next=new_item;new_item->prev=child;child=new_item;
+		value=skip(parse_string(child,skip(value+1)));
+		if (!value) return 0;
+		child->string=child->valuestring;child->valuestring=0;
+		if (*value!=':') {ep=value;return 0;}	/* fail! */
+		value=skip(parse_value(child,skip(value+1)));	/* skip any spacing, get the value. */
+		if (!value) return 0;
+	}
+	
+	if (*value=='}') return value+1;	/* end of array */
+	ep=value;return 0;	/* malformed. */
+}
+
+/* Render an object to text. */
+static char *print_object(cJSON *item,int depth,int fmt)
+{
+	char **entries=0,**names=0;
+	char *out=0,*ptr,*ret,*str;int len=7,i=0,j;
+	cJSON *child=item->child;
+	int numentries=0,fail=0;
+	/* Count the number of entries. */
+	while (child) numentries++,child=child->next;
+	/* Explicitly handle empty object case */
+	if (!numentries)
+	{
+		out=(char*)cJSON_malloc(fmt?depth+3:3);
+		if (!out)	return 0;
+		ptr=out;*ptr++='{';
+		if (fmt) {*ptr++='\n';for (i=0;i<depth-1;i++) *ptr++='\t';}
+		*ptr++='}';*ptr++=0;
+		return out;
+	}
+	/* Allocate space for the names and the objects */
+	entries=(char**)cJSON_malloc(numentries*sizeof(char*));
+	if (!entries) return 0;
+	names=(char**)cJSON_malloc(numentries*sizeof(char*));
+	if (!names) {cJSON_free(entries);return 0;}
+	memset(entries,0,sizeof(char*)*numentries);
+	memset(names,0,sizeof(char*)*numentries);
+
+	/* Collect all the results into our arrays: */
+	child=item->child;depth++;if (fmt) len+=depth;
+	while (child)
+	{
+		names[i]=str=print_string_ptr(child->string);
+		entries[i++]=ret=print_value(child,depth,fmt);
+		if (str && ret) len+=strlen(ret)+strlen(str)+2+(fmt?2+depth:0); else fail=1;
+		child=child->next;
+	}
+	
+	/* Try to allocate the output string */
+	if (!fail) out=(char*)cJSON_malloc(len);
+	if (!out) fail=1;
+
+	/* Handle failure */
+	if (fail)
+	{
+		for (i=0;i<numentries;i++) {if (names[i]) cJSON_free(names[i]);if (entries[i]) cJSON_free(entries[i]);}
+		cJSON_free(names);cJSON_free(entries);
+		return 0;
+	}
+	
+	/* Compose the output: */
+	*out='{';ptr=out+1;if (fmt)*ptr++='\n';*ptr=0;
+	for (i=0;i<numentries;i++)
+	{
+		if (fmt) for (j=0;j<depth;j++) *ptr++='\t';
+		strcpy(ptr,names[i]);ptr+=strlen(names[i]);
+		*ptr++=':';if (fmt) *ptr++='\t';
+		strcpy(ptr,entries[i]);ptr+=strlen(entries[i]);
+		if (i!=numentries-1) *ptr++=',';
+		if (fmt) *ptr++='\n';*ptr=0;
+		cJSON_free(names[i]);cJSON_free(entries[i]);
+	}
+	
+	cJSON_free(names);cJSON_free(entries);
+	if (fmt) for (i=0;i<depth-1;i++) *ptr++='\t';
+	*ptr++='}';*ptr++=0;
+	return out;	
+}
+
+/* Get Array size/item / object item. */
+int    cJSON_GetArraySize(cJSON *array)							{cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}
+cJSON *cJSON_GetArrayItem(cJSON *array,int item)				{cJSON *c=array->child;  while (c && item>0) item--,c=c->next; return c;}
+cJSON *cJSON_GetObjectItem(cJSON *object,const char *string)	{cJSON *c=object->child; while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}
+
+/* Utility for array list handling. */
+static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}
+/* Utility for handling references. */
+static cJSON *create_reference(cJSON *item) {cJSON *ref=cJSON_New_Item();if (!ref) return 0;memcpy(ref,item,sizeof(cJSON));ref->string=0;ref->type|=cJSON_IsReference;ref->next=ref->prev=0;return ref;}
+
+/* Add item to array/object. */
+void   cJSON_AddItemToArray(cJSON *array, cJSON *item)						{cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}
+void   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (item->string) cJSON_free(item->string);item->string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}
+void	cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)						{cJSON_AddItemToArray(array,create_reference(item));}
+void	cJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item)	{cJSON_AddItemToObject(object,string,create_reference(item));}
+
+cJSON *cJSON_DetachItemFromArray(cJSON *array,int which)			{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return 0;
+	if (c->prev) c->prev->next=c->next;if (c->next) c->next->prev=c->prev;if (c==array->child) array->child=c->next;c->prev=c->next=0;return c;}
+void   cJSON_DeleteItemFromArray(cJSON *array,int which)			{cJSON_Delete(cJSON_DetachItemFromArray(array,which));}
+cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string) {int i=0;cJSON *c=object->child;while (c && cJSON_strcasecmp(c->string,string)) i++,c=c->next;if (c) return cJSON_DetachItemFromArray(object,i);return 0;}
+void   cJSON_DeleteItemFromObject(cJSON *object,const char *string) {cJSON_Delete(cJSON_DetachItemFromObject(object,string));}
+
+/* Replace array/object items with new ones. */
+void   cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem)		{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return;
+	newitem->next=c->next;newitem->prev=c->prev;if (newitem->next) newitem->next->prev=newitem;
+	if (c==array->child) array->child=newitem; else newitem->prev->next=newitem;c->next=c->prev=0;cJSON_Delete(c);}
+void   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object->child;while(c && cJSON_strcasecmp(c->string,string))i++,c=c->next;if(c){newitem->string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}
+
+/* Create basic types: */
+cJSON *cJSON_CreateNull(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}
+cJSON *cJSON_CreateTrue(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}
+cJSON *cJSON_CreateFalse(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}
+cJSON *cJSON_CreateBool(int b)					{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}
+cJSON *cJSON_CreateNumber(double num)			{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int)num;}return item;}
+cJSON *cJSON_CreateString(const char *string)	{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);}return item;}
+cJSON *cJSON_CreateArray(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Array;return item;}
+cJSON *cJSON_CreateObject(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}
+
+/* Create Arrays: */
+cJSON *cJSON_CreateIntArray(int *numbers,int count)				{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
+cJSON *cJSON_CreateFloatArray(float *numbers,int count)			{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
+cJSON *cJSON_CreateDoubleArray(double *numbers,int count)		{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
+cJSON *cJSON_CreateStringArray(const char **strings,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateString(strings[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
+
+/* Duplication */
+cJSON *cJSON_Duplicate(cJSON *item,int recurse)
+{
+	cJSON *newitem,*cptr,*nptr=0,*newchild;
+	/* Bail on bad ptr */
+	if (!item) return 0;
+	/* Create new item */
+	newitem=cJSON_New_Item();
+	if (!newitem) return 0;
+	/* Copy over all vars */
+	newitem->type=item->type&(~cJSON_IsReference),newitem->valueint=item->valueint,newitem->valuedouble=item->valuedouble;
+	if (item->valuestring)	{newitem->valuestring=cJSON_strdup(item->valuestring);	if (!newitem->valuestring)	{cJSON_Delete(newitem);return 0;}}
+	if (item->string)		{newitem->string=cJSON_strdup(item->string);			if (!newitem->string)		{cJSON_Delete(newitem);return 0;}}
+	/* If non-recursive, then we're done! */
+	if (!recurse) return newitem;
+	/* Walk the ->next chain for the child. */
+	cptr=item->child;
+	while (cptr)
+	{
+		newchild=cJSON_Duplicate(cptr,1);		/* Duplicate (with recurse) each item in the ->next chain */
+		if (!newchild) {cJSON_Delete(newitem);return 0;}
+		if (nptr)	{nptr->next=newchild,newchild->prev=nptr;nptr=newchild;}	/* If newitem->child already set, then crosswire ->prev and ->next and move on */
+		else		{newitem->child=newchild;nptr=newchild;}					/* Set newitem->child and move to it */
+		cptr=cptr->next;
+	}
+	return newitem;
+}
diff --git a/src/cpp/sgx/cjson/cJSON.c b/src/cpp/sgx/cjson/cJSON.c
new file mode 100644
index 0000000000..04b5079c8a
--- /dev/null
+++ b/src/cpp/sgx/cjson/cJSON.c
@@ -0,0 +1,567 @@
+/*
+  Copyright (c) 2009 Dave Gamble
+
+  Permission is hereby granted, free of charge, to any person obtaining a copy
+  of this software and associated documentation files (the "Software"), to deal
+  in the Software without restriction, including without limitation the rights
+  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+  copies of the Software, and to permit persons to whom the Software is
+  furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included in
+  all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+  THE SOFTWARE.
+*/
+
+/* cJSON */
+/* JSON parser in C. */
+
+#include <string.h>
+#include <stdio.h>
+#include <math.h>
+#include <stdlib.h>
+#include <float.h>
+#include <limits.h>
+#include <ctype.h>
+#include "cJSON.h"
+
+static const char *ep;
+
+const char *cJSON_GetErrorPtr(void) {return ep;}
+
+static int cJSON_strcasecmp(const char *s1,const char *s2)
+{
+	if (!s1) return (s1==s2)?0:1;if (!s2) return 1;
+	for(; tolower(*s1) == tolower(*s2); ++s1, ++s2)	if(*s1 == 0)	return 0;
+	return tolower(*(const unsigned char *)s1) - tolower(*(const unsigned char *)s2);
+}
+
+static void *(*cJSON_malloc)(size_t sz) = malloc;
+static void (*cJSON_free)(void *ptr) = free;
+
+static char* cJSON_strdup(const char* str)
+{
+      size_t len;
+      char* copy;
+
+      len = strlen(str) + 1;
+      if (!(copy = (char*)cJSON_malloc(len))) return 0;
+      memcpy(copy,str,len);
+      return copy;
+}
+
+void cJSON_InitHooks(cJSON_Hooks* hooks)
+{
+    if (!hooks) { /* Reset hooks */
+        cJSON_malloc = malloc;
+        cJSON_free = free;
+        return;
+    }
+
+	cJSON_malloc = (hooks->malloc_fn)?hooks->malloc_fn:malloc;
+	cJSON_free	 = (hooks->free_fn)?hooks->free_fn:free;
+}
+
+/* Internal constructor. */
+static cJSON *cJSON_New_Item(void)
+{
+	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));
+	if (node) memset(node,0,sizeof(cJSON));
+	return node;
+}
+
+/* Delete a cJSON structure. */
+void cJSON_Delete(cJSON *c)
+{
+	cJSON *next;
+	while (c)
+	{
+		next=c->next;
+		if (!(c->type&cJSON_IsReference) && c->child) cJSON_Delete(c->child);
+		if (!(c->type&cJSON_IsReference) && c->valuestring) cJSON_free(c->valuestring);
+		if (c->string) cJSON_free(c->string);
+		cJSON_free(c);
+		c=next;
+	}
+}
+
+/* Parse the input text to generate a number, and populate the result into item. */
+static const char *parse_number(cJSON *item,const char *num)
+{
+	double n=0,sign=1,scale=0;int subscale=0,signsubscale=1;
+
+	/* Could use sscanf for this? */
+	if (*num=='-') sign=-1,num++;	/* Has sign? */
+	if (*num=='0') num++;			/* is zero */
+	if (*num>='1' && *num<='9')	do	n=(n*10.0)+(*num++ -'0');	while (*num>='0' && *num<='9');	/* Number? */
+	if (*num=='.' && num[1]>='0' && num[1]<='9') {num++;		do	n=(n*10.0)+(*num++ -'0'),scale--; while (*num>='0' && *num<='9');}	/* Fractional part? */
+	if (*num=='e' || *num=='E')		/* Exponent? */
+	{	num++;if (*num=='+') num++;	else if (*num=='-') signsubscale=-1,num++;		/* With sign? */
+		while (*num>='0' && *num<='9') subscale=(subscale*10)+(*num++ - '0');	/* Number? */
+	}
+
+	n=sign*n*pow(10.0,(scale+subscale*signsubscale));	/* number = +/- number.fraction * 10^+/- exponent */
+	
+	item->valuedouble=n;
+	item->valueint=(int)n;
+	item->type=cJSON_Number;
+	return num;
+}
+
+/* Render the number nicely from the given item into a string. */
+static char *print_number(cJSON *item)
+{
+	char *str;
+	double d=item->valuedouble;
+	if (fabs(((double)item->valueint)-d)<=DBL_EPSILON && d<=INT_MAX && d>=INT_MIN)
+	{
+		str=(char*)cJSON_malloc(21);	/* 2^64+1 can be represented in 21 chars. */
+		if (str) sprintf(str,"%d",item->valueint);
+	}
+	else
+	{
+		str=(char*)cJSON_malloc(64);	/* This is a nice tradeoff. */
+		if (str)
+		{
+			if (fabs(floor(d)-d)<=DBL_EPSILON && fabs(d)<1.0e60)sprintf(str,"%.0f",d);
+			else if (fabs(d)<1.0e-6 || fabs(d)>1.0e9)			sprintf(str,"%e",d);
+			else												sprintf(str,"%f",d);
+		}
+	}
+	return str;
+}
+
+/* Parse the input text into an unescaped cstring, and populate item. */
+static const unsigned char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
+static const char *parse_string(cJSON *item,const char *str)
+{
+	const char *ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;
+	if (*str!='\"') {ep=str;return 0;}	/* not a string! */
+	
+	while (*ptr!='\"' && *ptr && ++len) if (*ptr++ == '\\') ptr++;	/* Skip escaped quotes. */
+	
+	out=(char*)cJSON_malloc(len+1);	/* This is how long we need for the string, roughly. */
+	if (!out) return 0;
+	
+	ptr=str+1;ptr2=out;
+	while (*ptr!='\"' && *ptr)
+	{
+		if (*ptr!='\\') *ptr2++=*ptr++;
+		else
+		{
+			ptr++;
+			switch (*ptr)
+			{
+				case 'b': *ptr2++='\b';	break;
+				case 'f': *ptr2++='\f';	break;
+				case 'n': *ptr2++='\n';	break;
+				case 'r': *ptr2++='\r';	break;
+				case 't': *ptr2++='\t';	break;
+				case 'u':	 /* transcode utf16 to utf8. */
+					sscanf(ptr+1,"%4x",&uc);ptr+=4;	/* get the unicode char. */
+
+					if ((uc>=0xDC00 && uc<=0xDFFF) || uc==0)	break;	/* check for invalid.	*/
+
+					if (uc>=0xD800 && uc<=0xDBFF)	/* UTF16 surrogate pairs.	*/
+					{
+						if (ptr[1]!='\\' || ptr[2]!='u')	break;	/* missing second-half of surrogate.	*/
+						sscanf(ptr+3,"%4x",&uc2);ptr+=6;
+						if (uc2<0xDC00 || uc2>0xDFFF)		break;	/* invalid second-half of surrogate.	*/
+						uc=0x10000 + (((uc&0x3FF)<<10) | (uc2&0x3FF));
+					}
+
+					len=4;if (uc<0x80) len=1;else if (uc<0x800) len=2;else if (uc<0x10000) len=3; ptr2+=len;
+					
+					switch (len) {
+						case 4: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
+						case 3: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
+						case 2: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
+						case 1: *--ptr2 =(uc | firstByteMark[len]);
+					}
+					ptr2+=len;
+					break;
+				default:  *ptr2++=*ptr; break;
+			}
+			ptr++;
+		}
+	}
+	*ptr2=0;
+	if (*ptr=='\"') ptr++;
+	item->valuestring=out;
+	item->type=cJSON_String;
+	return ptr;
+}
+
+/* Render the cstring provided to an escaped version that can be printed. */
+static char *print_string_ptr(const char *str)
+{
+	const char *ptr;char *ptr2,*out;int len=0;unsigned char token;
+	
+	if (!str) return cJSON_strdup("");
+	ptr=str;while ((token=*ptr) && ++len) {if (strchr("\"\\\b\f\n\r\t",token)) len++; else if (token<32) len+=5;ptr++;}
+	
+	out=(char*)cJSON_malloc(len+3);
+	if (!out) return 0;
+
+	ptr2=out;ptr=str;
+	*ptr2++='\"';
+	while (*ptr)
+	{
+		if ((unsigned char)*ptr>31 && *ptr!='\"' && *ptr!='\\') *ptr2++=*ptr++;
+		else
+		{
+			*ptr2++='\\';
+			switch (token=*ptr++)
+			{
+				case '\\':	*ptr2++='\\';	break;
+				case '\"':	*ptr2++='\"';	break;
+				case '\b':	*ptr2++='b';	break;
+				case '\f':	*ptr2++='f';	break;
+				case '\n':	*ptr2++='n';	break;
+				case '\r':	*ptr2++='r';	break;
+				case '\t':	*ptr2++='t';	break;
+				default: sprintf(ptr2,"u%04x",token);ptr2+=5;	break;	/* escape and print */
+			}
+		}
+	}
+	*ptr2++='\"';*ptr2++=0;
+	return out;
+}
+/* Invote print_string_ptr (which is useful) on an item. */
+static char *print_string(cJSON *item)	{return print_string_ptr(item->valuestring);}
+
+/* Predeclare these prototypes. */
+static const char *parse_value(cJSON *item,const char *value);
+static char *print_value(cJSON *item,int depth,int fmt);
+static const char *parse_array(cJSON *item,const char *value);
+static char *print_array(cJSON *item,int depth,int fmt);
+static const char *parse_object(cJSON *item,const char *value);
+static char *print_object(cJSON *item,int depth,int fmt);
+
+/* Utility to jump whitespace and cr/lf */
+static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}
+
+/* Parse an object - create a new root, and populate. */
+cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated)
+{
+	const char *end=0;
+	cJSON *c=cJSON_New_Item();
+	ep=0;
+	if (!c) return 0;       /* memory fail */
+
+	end=parse_value(c,skip(value));
+	if (!end)	{cJSON_Delete(c);return 0;}	/* parse failure. ep is set. */
+
+	/* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */
+	if (require_null_terminated) {end=skip(end);if (*end) {cJSON_Delete(c);ep=end;return 0;}}
+	if (return_parse_end) *return_parse_end=end;
+	return c;
+}
+/* Default options for cJSON_Parse */
+cJSON *cJSON_Parse(const char *value) {return cJSON_ParseWithOpts(value,0,0);}
+
+/* Render a cJSON item/entity/structure to text. */
+char *cJSON_Print(cJSON *item)				{return print_value(item,0,1);}
+char *cJSON_PrintUnformatted(cJSON *item)	{return print_value(item,0,0);}
+
+/* Parser core - when encountering text, process appropriately. */
+static const char *parse_value(cJSON *item,const char *value)
+{
+	if (!value)						return 0;	/* Fail on null. */
+	if (!strncmp(value,"null",4))	{ item->type=cJSON_NULL;  return value+4; }
+	if (!strncmp(value,"false",5))	{ item->type=cJSON_False; return value+5; }
+	if (!strncmp(value,"true",4))	{ item->type=cJSON_True; item->valueint=1;	return value+4; }
+	if (*value=='\"')				{ return parse_string(item,value); }
+	if (*value=='-' || (*value>='0' && *value<='9'))	{ return parse_number(item,value); }
+	if (*value=='[')				{ return parse_array(item,value); }
+	if (*value=='{')				{ return parse_object(item,value); }
+
+	ep=value;return 0;	/* failure. */
+}
+
+/* Render a value to text. */
+static char *print_value(cJSON *item,int depth,int fmt)
+{
+	char *out=0;
+	if (!item) return 0;
+	switch ((item->type)&255)
+	{
+		case cJSON_NULL:	out=cJSON_strdup("null");	break;
+		case cJSON_False:	out=cJSON_strdup("false");break;
+		case cJSON_True:	out=cJSON_strdup("true"); break;
+		case cJSON_Number:	out=print_number(item);break;
+		case cJSON_String:	out=print_string(item);break;
+		case cJSON_Array:	out=print_array(item,depth,fmt);break;
+		case cJSON_Object:	out=print_object(item,depth,fmt);break;
+	}
+	return out;
+}
+
+/* Build an array from input text. */
+static const char *parse_array(cJSON *item,const char *value)
+{
+	cJSON *child;
+	if (*value!='[')	{ep=value;return 0;}	/* not an array! */
+
+	item->type=cJSON_Array;
+	value=skip(value+1);
+	if (*value==']') return value+1;	/* empty array. */
+
+	item->child=child=cJSON_New_Item();
+	if (!item->child) return 0;		 /* memory fail */
+	value=skip(parse_value(child,skip(value)));	/* skip any spacing, get the value. */
+	if (!value) return 0;
+
+	while (*value==',')
+	{
+		cJSON *new_item;
+		if (!(new_item=cJSON_New_Item())) return 0; 	/* memory fail */
+		child->next=new_item;new_item->prev=child;child=new_item;
+		value=skip(parse_value(child,skip(value+1)));
+		if (!value) return 0;	/* memory fail */
+	}
+
+	if (*value==']') return value+1;	/* end of array */
+	ep=value;return 0;	/* malformed. */
+}
+
+/* Render an array to text */
+static char *print_array(cJSON *item,int depth,int fmt)
+{
+	char **entries;
+	char *out=0,*ptr,*ret;int len=5;
+	cJSON *child=item->child;
+	int numentries=0,i=0,fail=0;
+	
+	/* How many entries in the array? */
+	while (child) numentries++,child=child->next;
+	/* Explicitly handle numentries==0 */
+	if (!numentries)
+	{
+		out=(char*)cJSON_malloc(3);
+		if (out) strcpy(out,"[]");
+		return out;
+	}
+	/* Allocate an array to hold the values for each */
+	entries=(char**)cJSON_malloc(numentries*sizeof(char*));
+	if (!entries) return 0;
+	memset(entries,0,numentries*sizeof(char*));
+	/* Retrieve all the results: */
+	child=item->child;
+	while (child && !fail)
+	{
+		ret=print_value(child,depth+1,fmt);
+		entries[i++]=ret;
+		if (ret) len+=strlen(ret)+2+(fmt?1:0); else fail=1;
+		child=child->next;
+	}
+	
+	/* If we didn't fail, try to malloc the output string */
+	if (!fail) out=(char*)cJSON_malloc(len);
+	/* If that fails, we fail. */
+	if (!out) fail=1;
+
+	/* Handle failure. */
+	if (fail)
+	{
+		for (i=0;i<numentries;i++) if (entries[i]) cJSON_free(entries[i]);
+		cJSON_free(entries);
+		return 0;
+	}
+	
+	/* Compose the output array. */
+	*out='[';
+	ptr=out+1;*ptr=0;
+	for (i=0;i<numentries;i++)
+	{
+		strcpy(ptr,entries[i]);ptr+=strlen(entries[i]);
+		if (i!=numentries-1) {*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;}
+		cJSON_free(entries[i]);
+	}
+	cJSON_free(entries);
+	*ptr++=']';*ptr++=0;
+	return out;	
+}
+
+/* Build an object from the text. */
+static const char *parse_object(cJSON *item,const char *value)
+{
+	cJSON *child;
+	if (*value!='{')	{ep=value;return 0;}	/* not an object! */
+	
+	item->type=cJSON_Object;
+	value=skip(value+1);
+	if (*value=='}') return value+1;	/* empty array. */
+	
+	item->child=child=cJSON_New_Item();
+	if (!item->child) return 0;
+	value=skip(parse_string(child,skip(value)));
+	if (!value) return 0;
+	child->string=child->valuestring;child->valuestring=0;
+	if (*value!=':') {ep=value;return 0;}	/* fail! */
+	value=skip(parse_value(child,skip(value+1)));	/* skip any spacing, get the value. */
+	if (!value) return 0;
+	
+	while (*value==',')
+	{
+		cJSON *new_item;
+		if (!(new_item=cJSON_New_Item()))	return 0; /* memory fail */
+		child->next=new_item;new_item->prev=child;child=new_item;
+		value=skip(parse_string(child,skip(value+1)));
+		if (!value) return 0;
+		child->string=child->valuestring;child->valuestring=0;
+		if (*value!=':') {ep=value;return 0;}	/* fail! */
+		value=skip(parse_value(child,skip(value+1)));	/* skip any spacing, get the value. */
+		if (!value) return 0;
+	}
+	
+	if (*value=='}') return value+1;	/* end of array */
+	ep=value;return 0;	/* malformed. */
+}
+
+/* Render an object to text. */
+static char *print_object(cJSON *item,int depth,int fmt)
+{
+	char **entries=0,**names=0;
+	char *out=0,*ptr,*ret,*str;int len=7,i=0,j;
+	cJSON *child=item->child;
+	int numentries=0,fail=0;
+	/* Count the number of entries. */
+	while (child) numentries++,child=child->next;
+	/* Explicitly handle empty object case */
+	if (!numentries)
+	{
+		out=(char*)cJSON_malloc(fmt?depth+3:3);
+		if (!out)	return 0;
+		ptr=out;*ptr++='{';
+		if (fmt) {*ptr++='\n';for (i=0;i<depth-1;i++) *ptr++='\t';}
+		*ptr++='}';*ptr++=0;
+		return out;
+	}
+	/* Allocate space for the names and the objects */
+	entries=(char**)cJSON_malloc(numentries*sizeof(char*));
+	if (!entries) return 0;
+	names=(char**)cJSON_malloc(numentries*sizeof(char*));
+	if (!names) {cJSON_free(entries);return 0;}
+	memset(entries,0,sizeof(char*)*numentries);
+	memset(names,0,sizeof(char*)*numentries);
+
+	/* Collect all the results into our arrays: */
+	child=item->child;depth++;if (fmt) len+=depth;
+	while (child)
+	{
+		names[i]=str=print_string_ptr(child->string);
+		entries[i++]=ret=print_value(child,depth,fmt);
+		if (str && ret) len+=strlen(ret)+strlen(str)+2+(fmt?2+depth:0); else fail=1;
+		child=child->next;
+	}
+	
+	/* Try to allocate the output string */
+	if (!fail) out=(char*)cJSON_malloc(len);
+	if (!out) fail=1;
+
+	/* Handle failure */
+	if (fail)
+	{
+		for (i=0;i<numentries;i++) {if (names[i]) cJSON_free(names[i]);if (entries[i]) cJSON_free(entries[i]);}
+		cJSON_free(names);cJSON_free(entries);
+		return 0;
+	}
+	
+	/* Compose the output: */
+	*out='{';ptr=out+1;if (fmt)*ptr++='\n';*ptr=0;
+	for (i=0;i<numentries;i++)
+	{
+		if (fmt) for (j=0;j<depth;j++) *ptr++='\t';
+		strcpy(ptr,names[i]);ptr+=strlen(names[i]);
+		*ptr++=':';if (fmt) *ptr++='\t';
+		strcpy(ptr,entries[i]);ptr+=strlen(entries[i]);
+		if (i!=numentries-1) *ptr++=',';
+		if (fmt) *ptr++='\n';*ptr=0;
+		cJSON_free(names[i]);cJSON_free(entries[i]);
+	}
+	
+	cJSON_free(names);cJSON_free(entries);
+	if (fmt) for (i=0;i<depth-1;i++) *ptr++='\t';
+	*ptr++='}';*ptr++=0;
+	return out;	
+}
+
+/* Get Array size/item / object item. */
+int    cJSON_GetArraySize(cJSON *array)							{cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}
+cJSON *cJSON_GetArrayItem(cJSON *array,int item)				{cJSON *c=array->child;  while (c && item>0) item--,c=c->next; return c;}
+cJSON *cJSON_GetObjectItem(cJSON *object,const char *string)	{cJSON *c=object->child; while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}
+
+/* Utility for array list handling. */
+static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}
+/* Utility for handling references. */
+static cJSON *create_reference(cJSON *item) {cJSON *ref=cJSON_New_Item();if (!ref) return 0;memcpy(ref,item,sizeof(cJSON));ref->string=0;ref->type|=cJSON_IsReference;ref->next=ref->prev=0;return ref;}
+
+/* Add item to array/object. */
+void   cJSON_AddItemToArray(cJSON *array, cJSON *item)						{cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}
+void   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (item->string) cJSON_free(item->string);item->string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}
+void	cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)						{cJSON_AddItemToArray(array,create_reference(item));}
+void	cJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item)	{cJSON_AddItemToObject(object,string,create_reference(item));}
+
+cJSON *cJSON_DetachItemFromArray(cJSON *array,int which)			{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return 0;
+	if (c->prev) c->prev->next=c->next;if (c->next) c->next->prev=c->prev;if (c==array->child) array->child=c->next;c->prev=c->next=0;return c;}
+void   cJSON_DeleteItemFromArray(cJSON *array,int which)			{cJSON_Delete(cJSON_DetachItemFromArray(array,which));}
+cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string) {int i=0;cJSON *c=object->child;while (c && cJSON_strcasecmp(c->string,string)) i++,c=c->next;if (c) return cJSON_DetachItemFromArray(object,i);return 0;}
+void   cJSON_DeleteItemFromObject(cJSON *object,const char *string) {cJSON_Delete(cJSON_DetachItemFromObject(object,string));}
+
+/* Replace array/object items with new ones. */
+void   cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem)		{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return;
+	newitem->next=c->next;newitem->prev=c->prev;if (newitem->next) newitem->next->prev=newitem;
+	if (c==array->child) array->child=newitem; else newitem->prev->next=newitem;c->next=c->prev=0;cJSON_Delete(c);}
+void   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object->child;while(c && cJSON_strcasecmp(c->string,string))i++,c=c->next;if(c){newitem->string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}
+
+/* Create basic types: */
+cJSON *cJSON_CreateNull(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}
+cJSON *cJSON_CreateTrue(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}
+cJSON *cJSON_CreateFalse(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}
+cJSON *cJSON_CreateBool(int b)					{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}
+cJSON *cJSON_CreateNumber(double num)			{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int)num;}return item;}
+cJSON *cJSON_CreateString(const char *string)	{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);}return item;}
+cJSON *cJSON_CreateArray(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Array;return item;}
+cJSON *cJSON_CreateObject(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}
+
+/* Create Arrays: */
+cJSON *cJSON_CreateIntArray(int *numbers,int count)				{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
+cJSON *cJSON_CreateFloatArray(float *numbers,int count)			{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
+cJSON *cJSON_CreateDoubleArray(double *numbers,int count)		{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
+cJSON *cJSON_CreateStringArray(const char **strings,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateString(strings[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
+
+/* Duplication */
+cJSON *cJSON_Duplicate(cJSON *item,int recurse)
+{
+	cJSON *newitem,*cptr,*nptr=0,*newchild;
+	/* Bail on bad ptr */
+	if (!item) return 0;
+	/* Create new item */
+	newitem=cJSON_New_Item();
+	if (!newitem) return 0;
+	/* Copy over all vars */
+	newitem->type=item->type&(~cJSON_IsReference),newitem->valueint=item->valueint,newitem->valuedouble=item->valuedouble;
+	if (item->valuestring)	{newitem->valuestring=cJSON_strdup(item->valuestring);	if (!newitem->valuestring)	{cJSON_Delete(newitem);return 0;}}
+	if (item->string)		{newitem->string=cJSON_strdup(item->string);			if (!newitem->string)		{cJSON_Delete(newitem);return 0;}}
+	/* If non-recursive, then we're done! */
+	if (!recurse) return newitem;
+	/* Walk the ->next chain for the child. */
+	cptr=item->child;
+	while (cptr)
+	{
+		newchild=cJSON_Duplicate(cptr,1);		/* Duplicate (with recurse) each item in the ->next chain */
+		if (!newchild) {cJSON_Delete(newitem);return 0;}
+		if (nptr)	{nptr->next=newchild,newchild->prev=nptr;nptr=newchild;}	/* If newitem->child already set, then crosswire ->prev and ->next and move on */
+		else		{newitem->child=newchild;nptr=newchild;}					/* Set newitem->child and move to it */
+		cptr=cptr->next;
+	}
+	return newitem;
+}
diff --git a/src/cpp/sgx/cjson/cJSON.h b/src/cpp/sgx/cjson/cJSON.h
new file mode 100644
index 0000000000..9cedb93d3b
--- /dev/null
+++ b/src/cpp/sgx/cjson/cJSON.h
@@ -0,0 +1,140 @@
+/*
+  Copyright (c) 2009 Dave Gamble
+ 
+  Permission is hereby granted, free of charge, to any person obtaining a copy
+  of this software and associated documentation files (the "Software"), to deal
+  in the Software without restriction, including without limitation the rights
+  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+  copies of the Software, and to permit persons to whom the Software is
+  furnished to do so, subject to the following conditions:
+ 
+  The above copyright notice and this permission notice shall be included in
+  all copies or substantial portions of the Software.
+ 
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+  THE SOFTWARE.
+*/
+
+#ifndef cJSON__h
+#define cJSON__h
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+#include <stdio.h>
+/* cJSON Types: */
+#define cJSON_False 0
+#define cJSON_True 1
+#define cJSON_NULL 2
+#define cJSON_Number 3
+#define cJSON_String 4
+#define cJSON_Array 5
+#define cJSON_Object 6
+	
+#define cJSON_IsReference 256
+
+/* The cJSON structure: */
+typedef struct cJSON {
+	struct cJSON *next,*prev;	/* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem */
+	struct cJSON *child;		/* An array or object item will have a child pointer pointing to a chain of the items in the array/object. */
+
+	int type;					/* The type of the item, as above. */
+
+	char *valuestring;			/* The item's string, if type==cJSON_String */
+	int valueint;				/* The item's number, if type==cJSON_Number */
+	double valuedouble;			/* The item's number, if type==cJSON_Number */
+
+	char *string;				/* The item's name string, if this item is the child of, or is in the list of subitems of an object. */
+} cJSON;
+
+typedef struct cJSON_Hooks {
+      void *(*malloc_fn)(size_t sz);
+      void (*free_fn)(void *ptr);
+} cJSON_Hooks;
+
+/* Supply malloc, realloc and free functions to cJSON */
+extern void cJSON_InitHooks(cJSON_Hooks* hooks);
+
+
+/* Supply a block of JSON, and this returns a cJSON object you can interrogate. Call cJSON_Delete when finished. */
+extern cJSON *cJSON_Parse(const char *value);
+/* Render a cJSON entity to text for transfer/storage. Free the char* when finished. */
+extern char  *cJSON_Print(cJSON *item);
+/* Render a cJSON entity to text for transfer/storage without any formatting. Free the char* when finished. */
+extern char  *cJSON_PrintUnformatted(cJSON *item);
+/* Delete a cJSON entity and all subentities. */
+extern void   cJSON_Delete(cJSON *c);
+
+/* Returns the number of items in an array (or object). */
+extern int	  cJSON_GetArraySize(cJSON *array);
+/* Retrieve item number "item" from array "array". Returns NULL if unsuccessful. */
+extern cJSON *cJSON_GetArrayItem(cJSON *array,int item);
+/* Get item "string" from object. Case insensitive. */
+extern cJSON *cJSON_GetObjectItem(cJSON *object,const char *string);
+
+/* For analysing failed parses. This returns a pointer to the parse error. You'll probably need to look a few chars back to make sense of it. Defined when cJSON_Parse() returns 0. 0 when cJSON_Parse() succeeds. */
+extern const char *cJSON_GetErrorPtr(void);
+	
+/* These calls create a cJSON item of the appropriate type. */
+extern cJSON *cJSON_CreateNull(void);
+extern cJSON *cJSON_CreateTrue(void);
+extern cJSON *cJSON_CreateFalse(void);
+extern cJSON *cJSON_CreateBool(int b);
+extern cJSON *cJSON_CreateNumber(double num);
+extern cJSON *cJSON_CreateString(const char *string);
+extern cJSON *cJSON_CreateArray(void);
+extern cJSON *cJSON_CreateObject(void);
+
+/* These utilities create an Array of count items. */
+extern cJSON *cJSON_CreateIntArray(int *numbers,int count);
+extern cJSON *cJSON_CreateFloatArray(float *numbers,int count);
+extern cJSON *cJSON_CreateDoubleArray(double *numbers,int count);
+extern cJSON *cJSON_CreateStringArray(const char **strings,int count);
+
+/* Append item to the specified array/object. */
+extern void cJSON_AddItemToArray(cJSON *array, cJSON *item);
+extern void	cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item);
+/* Append reference to item to the specified array/object. Use this when you want to add an existing cJSON to a new cJSON, but don't want to corrupt your existing cJSON. */
+extern void cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item);
+extern void	cJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item);
+
+/* Remove/Detatch items from Arrays/Objects. */
+extern cJSON *cJSON_DetachItemFromArray(cJSON *array,int which);
+extern void   cJSON_DeleteItemFromArray(cJSON *array,int which);
+extern cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string);
+extern void   cJSON_DeleteItemFromObject(cJSON *object,const char *string);
+	
+/* Update array items. */
+extern void cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem);
+extern void cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem);
+
+/* Duplicate a cJSON item */
+extern cJSON *cJSON_Duplicate(cJSON *item,int recurse);
+/* Duplicate will create a new, identical cJSON item to the one you pass, in new memory that will
+need to be released. With recurse!=0, it will duplicate any children connected to the item.
+The item->next and ->prev pointers are always zero on return from Duplicate. */
+
+/* ParseWithOpts allows you to require (and check) that the JSON is null terminated, and to retrieve the pointer to the final byte parsed. */
+extern cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated);
+
+/* Macros for creating things quickly. */
+#define cJSON_AddNullToObject(object,name)		cJSON_AddItemToObject(object, name, cJSON_CreateNull())
+#define cJSON_AddTrueToObject(object,name)		cJSON_AddItemToObject(object, name, cJSON_CreateTrue())
+#define cJSON_AddFalseToObject(object,name)		cJSON_AddItemToObject(object, name, cJSON_CreateFalse())
+#define cJSON_AddBoolToObject(object,name,b)	cJSON_AddItemToObject(object, name, cJSON_CreateBool(b))
+#define cJSON_AddNumberToObject(object,name,n)	cJSON_AddItemToObject(object, name, cJSON_CreateNumber(n))
+#define cJSON_AddStringToObject(object,name,s)	cJSON_AddItemToObject(object, name, cJSON_CreateString(s))
+
+/* When assigning an integer value, it needs to be propagated to valuedouble too. */
+#define cJSON_SetIntValue(object,val)			((object)?(object)->valueint=(object)->valuedouble=(val):(val))
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/src/cpp/sgx/sgx_ra_tls_backends.cc b/src/cpp/sgx/sgx_ra_tls_backends.cc
new file mode 100644
index 0000000000..9b7ea47cd7
--- /dev/null
+++ b/src/cpp/sgx/sgx_ra_tls_backends.cc
@@ -0,0 +1,225 @@
+/*
+ *
+ * Copyright (c) 2022 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+#include <grpcpp/security/sgx/sgx_ra_tls_backends.h>
+
+namespace grpc {
+namespace sgx {
+
+static ra_tls_config parse_config_json(const char* file) {
+    struct ra_tls_config cfg;
+
+    if (!check_file(file)) {
+        grpc_printf("could not to find and parse file!\n");
+    } else {
+        class json_engine sgx_json(file);
+        //grpc_printf("%s\n", sgx_json.print_item(sgx_json.get_handle()));
+
+        cfg.verify_mr_enclave = sgx_json.cmp_item(sgx_json.get_item(sgx_json.get_handle(), "verify_mr_enclave"), "on");
+        cfg.verify_mr_signer = sgx_json.cmp_item(sgx_json.get_item(sgx_json.get_handle(), "verify_mr_signer"), "on");
+        cfg.verify_isv_prod_id = sgx_json.cmp_item(sgx_json.get_item(sgx_json.get_handle(), "verify_isv_prod_id"), "on");
+        cfg.verify_isv_svn = sgx_json.cmp_item(sgx_json.get_item(sgx_json.get_handle(), "verify_isv_svn"), "on");
+
+        auto objs = sgx_json.get_item(sgx_json.get_handle(), "sgx_mrs");
+        auto obj_num = std::min(cJSON_GetArraySize(objs), SGX_MESUREMENTS_MAX_SIZE);
+
+        cfg.mrs = std::vector<ra_tls_measurement>(obj_num, ra_tls_measurement());
+        for (auto i = 0; i < obj_num; i++) {
+            auto obj = cJSON_GetArrayItem(objs, i);
+
+            auto mr_enclave = sgx_json.print_item(sgx_json.get_item(obj, "mr_enclave"));
+            memset(cfg.mrs[i].mr_enclave, 0, sizeof(cfg.mrs[i].mr_enclave));
+            hex_to_byte(mr_enclave+1, cfg.mrs[i].mr_enclave, sizeof(cfg.mrs[i].mr_enclave));
+
+            auto mr_signer = sgx_json.print_item(sgx_json.get_item(obj, "mr_signer"));
+            memset(cfg.mrs[i].mr_signer, 0, sizeof(cfg.mrs[i].mr_signer));
+            hex_to_byte(mr_signer+1, cfg.mrs[i].mr_signer, sizeof(cfg.mrs[i].mr_signer));
+
+            auto isv_prod_id = sgx_json.print_item(sgx_json.get_item(obj, "isv_prod_id"));
+            cfg.mrs[i].isv_prod_id = strtoul(isv_prod_id, nullptr, 10);
+
+            auto isv_svn = sgx_json.print_item(sgx_json.get_item(obj, "isv_svn"));
+            cfg.mrs[i].isv_svn = strtoul(isv_svn, nullptr, 10);
+        };
+    }
+
+    return cfg;
+}
+
+void ra_tls_parse_config(ra_tls_config cfg) {
+    std::lock_guard<std::mutex> lock(_ctx_.mtx);
+    _ctx_.cfg = cfg;
+}
+
+void ra_tls_parse_config(const char* file) {
+    ra_tls_parse_config(parse_config_json(file));
+}
+
+std::vector<std::string> ra_tls_generate_key_cert(int is_dummy) {
+    if (is_dummy) {
+        return dummy_generate_key_cert();
+    } else {
+#if defined(SGX_RA_TLS_GRAMINE_BACKEND)
+        return gramine_generate_key_cert();
+#elif defined(SGX_RA_TLS_OCCLUM_BACKEND)
+        return occlum_generate_key_cert();
+#elif defined(SGX_RA_TLS_TDX_BACKEND) || defined(SGX_RA_TLS_AZURE_TDX_BACKEND)
+        return tdx_generate_key_cert();
+#elif defined(SGX_RA_TLS_DUMMY_BACKEND)
+        return dummy_generate_key_cert();
+#endif
+    }
+}
+
+static std::vector<grpc::experimental::IdentityKeyCertPair> get_identity_key_cert_pairs(
+    std::vector<std::string> key_cert) {
+    grpc::experimental::IdentityKeyCertPair key_cert_pair;
+    key_cert_pair.private_key = key_cert[0];
+    key_cert_pair.certificate_chain = key_cert[1];
+    std::vector<grpc::experimental::IdentityKeyCertPair> identity_key_cert_pairs;
+    identity_key_cert_pairs.emplace_back(key_cert_pair);
+    return identity_key_cert_pairs;
+}
+
+void credential_option_set_certificate_provider(
+    grpc::sgx::CredentialsOptions& options, int is_dummy) {
+    std::lock_guard<std::mutex> lock(_ctx_.mtx);
+
+    _ctx_.cache.id++;
+
+    auto certificate_provider = _ctx_.cache.certificate_provider.insert({
+            _ctx_.cache.id,
+            std::make_shared<grpc::experimental::StaticDataCertificateProvider>(
+                get_identity_key_cert_pairs(ra_tls_generate_key_cert(is_dummy)))
+        }).first;
+
+    options.set_certificate_provider(certificate_provider->second);
+    options.watch_identity_key_cert_pairs();
+    options.set_cert_request_type(GRPC_SSL_REQUEST_AND_REQUIRE_CLIENT_CERTIFICATE_BUT_DONT_VERIFY);
+    options.set_root_cert_name("");
+    options.set_identity_cert_name("");
+}
+
+void ra_tls_verify_init() {
+#if defined(SGX_RA_TLS_GRAMINE_BACKEND)
+    gramine_verify_init();
+#elif defined(SGX_RA_TLS_OCCLUM_BACKEND)
+    occlum_verify_init();
+#elif defined(SGX_RA_TLS_TDX_BACKEND) || defined(SGX_RA_TLS_AZURE_TDX_BACKEND)
+    tdx_verify_init();
+#elif defined(SGX_RA_TLS_DUMMY_BACKEND)
+    dummy_verify_init();
+#endif
+}
+
+/*
+    certificate verification:
+    1. extract SGX quote from "quote" OID extension from crt
+    2. compare public key's hash from cert against quote's report_data
+    3. prepare user-supplied verification parameter "allow outdated TCB"
+    4. call into libsgx_dcap_quoteverify to verify ECDSA/based SGX quote
+    5. verify all measurements from the SGX quote
+*/
+int ra_tls_verify_certificate(const char *der_crt, size_t len) {
+#if defined(SGX_RA_TLS_GRAMINE_BACKEND)
+    return gramine_verify_cert(der_crt, len);
+#elif defined(SGX_RA_TLS_OCCLUM_BACKEND)
+    return occlum_verify_cert(der_crt, len);
+#elif defined(SGX_RA_TLS_TDX_BACKEND) || defined(SGX_RA_TLS_AZURE_TDX_BACKEND)
+    return tdx_verify_cert(der_crt, len);
+#elif defined(SGX_RA_TLS_DUMMY_BACKEND)
+    return dummy_verify_cert(der_crt, len);
+#endif
+}
+
+ra_tls_measurement ra_tls_parse_measurement(const char *der_crt, size_t len) {
+#if defined(SGX_RA_TLS_GRAMINE_BACKEND)
+    return gramine_parse_measurement(der_crt, len);
+#elif defined(SGX_RA_TLS_OCCLUM_BACKEND)
+    return occlum_parse_measurement(der_crt, len);
+#elif defined(SGX_RA_TLS_TDX_BACKEND) || defined(SGX_RA_TLS_AZURE_TDX_BACKEND)
+    return tdx_parse_measurement(der_crt, len);
+#elif defined(SGX_RA_TLS_DUMMY_BACKEND)
+    return dummy_parse_measurement(der_crt, len);
+#endif
+}
+
+int TlsAuthorizationCheck::Schedule(grpc::experimental::TlsServerAuthorizationCheckArg* arg) {
+    GPR_ASSERT(arg != nullptr);
+
+    char der_crt[CERT_KEY_MAX_SIZE] = "";
+    auto peer_cert_buf = arg->peer_cert();
+    peer_cert_buf.copy(der_crt, peer_cert_buf.length(), 0);
+
+    int ret = ra_tls_verify_certificate(der_crt, CERT_KEY_MAX_SIZE);
+    if (ret != 0) {
+        grpc_printf("something went wrong while verifying quote!\n");
+        arg->set_success(0);
+        arg->set_status(GRPC_STATUS_UNAUTHENTICATED);
+    } else {
+        arg->set_success(1);
+        arg->set_status(GRPC_STATUS_OK);
+    }
+    return 0;
+};
+
+void TlsAuthorizationCheck::Cancel(grpc::experimental::TlsServerAuthorizationCheckArg* arg) {
+    GPR_ASSERT(arg != nullptr);
+    arg->set_status(GRPC_STATUS_PERMISSION_DENIED);
+    arg->set_error_details("cancelled!");
+};
+
+int ra_tls_auth_check_schedule(void* /* confiuser_data */,
+                               grpc_tls_server_authorization_check_arg* arg) {
+    char der_crt[CERT_KEY_MAX_SIZE] = "";
+    memcpy(der_crt, arg->peer_cert, strlen(arg->peer_cert));
+
+    int ret = ra_tls_verify_certificate(der_crt, CERT_KEY_MAX_SIZE);
+    if (ret != 0) {
+        grpc_printf("something went wrong while verifying quote!\n");
+        arg->success = 0;
+        arg->status = GRPC_STATUS_UNAUTHENTICATED;
+    } else {
+        arg->success = 1;
+        arg->status = GRPC_STATUS_OK;
+    }
+    return 0;
+}
+
+void credential_option_set_authorization_check(grpc::sgx::CredentialsOptions& options) {
+    std::lock_guard<std::mutex> lock(_ctx_.mtx);
+
+    _ctx_.cache.id++;
+
+    ra_tls_verify_init();
+
+    auto authorization_check = _ctx_.cache.authorization_check.insert({
+            _ctx_.cache.id, std::make_shared<grpc::sgx::TlsAuthorizationCheck>()
+        }).first;
+
+    auto authorization_check_config = _ctx_.cache.authorization_check_config.insert({
+            _ctx_.cache.id,
+            std::make_shared<grpc::experimental::TlsServerAuthorizationCheckConfig>(
+                authorization_check->second)
+        }).first;
+
+    options.set_authorization_check_config(authorization_check_config->second);
+}
+
+} // namespace sgx
+} // namespace grpc
diff --git a/src/cpp/sgx/sgx_ra_tls_backends.h b/src/cpp/sgx/sgx_ra_tls_backends.h
new file mode 100644
index 0000000000..0552d3a604
--- /dev/null
+++ b/src/cpp/sgx/sgx_ra_tls_backends.h
@@ -0,0 +1,93 @@
+/*
+ *
+ * Copyright (c) 2022 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+#ifndef SGX_RA_TLS_BACKENDS_H
+#define SGX_RA_TLS_BACKENDS_H
+
+#include "sgx_ra_tls_utils.h"
+#include "sgx_ra_tls_context.h"
+
+#include <grpcpp/security/tls_credentials_options.h>
+#include <grpcpp/security/server_credentials.h>
+#include <grpcpp/security/sgx/sgx_ra_tls_options.h>
+
+// Set 1 for strict security checks
+#define SGX_MESUREMENTS_MAX_SIZE 16
+
+namespace grpc {
+namespace sgx {
+
+class TlsAuthorizationCheck
+    : public grpc::experimental::TlsServerAuthorizationCheckInterface {
+    int Schedule(grpc::experimental::TlsServerAuthorizationCheckArg* arg) override;
+    void Cancel(grpc::experimental::TlsServerAuthorizationCheckArg* arg) override;
+};
+
+int dummy_generate_quote(uint8_t **quote_buf, uint32_t &quote_size, uint8_t *hash);
+
+std::vector<std::string> dummy_generate_key_cert();
+
+void dummy_verify_init();
+
+int dummy_verify_cert(const char *der_crt, size_t len);
+
+ra_tls_measurement dummy_parse_measurement(const char *der_crt, size_t len);
+
+#if defined(SGX_RA_TLS_GRAMINE_BACKEND)
+
+std::vector<std::string> gramine_generate_key_cert();
+
+void gramine_verify_init();
+
+int gramine_verify_cert(const char *der_crt, size_t len);
+
+ra_tls_measurement gramine_parse_measurement(const char *der_crt, size_t len);
+
+#elif defined(SGX_RA_TLS_OCCLUM_BACKEND)
+
+std::vector<std::string> occlum_generate_key_cert();
+
+void occlum_verify_init();
+
+int occlum_verify_cert(const char *der_crt, size_t len);
+
+ra_tls_measurement occlum_parse_measurement(const char *der_crt, size_t len);
+
+#endif
+
+std::vector<std::string> ra_tls_generate_key_cert(int is_dummy);
+
+void ra_tls_parse_config(ra_tls_config cfg);
+
+void ra_tls_parse_config(const char *file);
+
+void ra_tls_verify_init();
+
+int ra_tls_verify_certificate(const char *der_crt, size_t len);
+
+ra_tls_measurement ra_tls_parse_measurement(const char *der_crt, size_t len);
+
+void credential_option_set_certificate_provider(grpc::sgx::CredentialsOptions& options, int is_dummy);
+
+void credential_option_set_authorization_check(grpc::sgx::CredentialsOptions& options);
+
+
+} // namespace sgx
+} // namespace grpc
+
+#endif // SGX_RA_TLS_BACKENDS_H
\ No newline at end of file
diff --git a/src/cpp/sgx/sgx_ra_tls_context.h b/src/cpp/sgx/sgx_ra_tls_context.h
new file mode 100644
index 0000000000..b26efd1993
--- /dev/null
+++ b/src/cpp/sgx/sgx_ra_tls_context.h
@@ -0,0 +1,91 @@
+/*
+ *
+ * Copyright (c) 2022 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+#ifndef SGX_RA_TLS_CONTEXT_H
+#define SGX_RA_TLS_CONTEXT_H
+
+#include "sgx_ra_tls_utils.h"
+
+#include <mutex>
+#include <unordered_map>
+
+#include <grpcpp/grpcpp.h>
+#include <grpc/grpc_security.h>
+#include <grpc/grpc_security_constants.h>
+#include <grpcpp/security/credentials.h>
+#include <grpcpp/security/tls_certificate_provider.h>
+
+#define CERT_KEY_MAX_SIZE 16000
+
+namespace grpc {
+namespace sgx {
+
+class TlsAuthorizationCheck;
+
+struct ra_tls_measurement {
+    char mr_enclave[32];
+    char mr_signer[32];
+    uint16_t isv_prod_id;
+    uint16_t isv_svn;
+};
+
+struct ra_tls_config {
+    bool verify_mr_enclave  = true;
+    bool verify_mr_signer   = true;
+    bool verify_isv_prod_id = true;
+    bool verify_isv_svn     = true;
+    std::vector<ra_tls_measurement> mrs;
+};
+
+struct ra_tls_cache {
+    int id = 0;
+    std::unordered_map<
+            int, std::shared_ptr<grpc::experimental::StaticDataCertificateProvider>
+        > certificate_provider;
+    std::unordered_map<
+            int, std::shared_ptr<grpc::sgx::TlsAuthorizationCheck>
+        > authorization_check;
+    std::unordered_map<
+            int, std::shared_ptr<grpc::experimental::TlsServerAuthorizationCheckConfig>
+        > authorization_check_config;
+};
+
+struct ra_tls_context {
+    std::mutex mtx;
+    struct ra_tls_config cfg;
+    struct ra_tls_cache cache;
+#ifdef SGX_RA_TLS_GRAMINE_BACKEND
+    class library_engine attest_lib;
+    class library_engine verify_lib;
+    class library_engine sgx_urts_lib;
+    int (*verify_callback_f)(uint8_t* der_crt, size_t der_crt_size) = nullptr;
+#endif
+#ifdef SGX_RA_TLS_LIBRATS_SDK
+    class library_engine attest_lib;
+    class library_engine verify_lib;
+    class library_engine init_lib;
+    class library_engine cleanup_lib;
+#endif
+};
+
+extern struct ra_tls_context _ctx_;
+
+} // namespace sgx
+} // namespace grpc
+
+#endif // SGX_RA_TLS_CONTEXT_H
diff --git a/src/cpp/sgx/sgx_ra_tls_credentials.cc b/src/cpp/sgx/sgx_ra_tls_credentials.cc
new file mode 100644
index 0000000000..e79d09ee7f
--- /dev/null
+++ b/src/cpp/sgx/sgx_ra_tls_credentials.cc
@@ -0,0 +1,87 @@
+/*
+ *
+ * Copyright (c) 2022 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+#include <grpcpp/security/server_credentials.h>
+#include <grpcpp/security/sgx/sgx_ra_tls_options.h>
+#include <grpcpp/security/sgx/sgx_ra_tls_backends.h>
+
+namespace grpc {
+namespace sgx {
+
+std::shared_ptr<grpc::ChannelCredentials> TlsCredentials(
+    ra_tls_config cfg, grpc_tls_server_verification_option verify_option) {
+    ra_tls_parse_config(cfg);
+
+    grpc::sgx::CredentialsOptions options(verify_option);
+    int is_dummy = verify_option == GRPC_RA_TLS_SERVER_VERIFICATION;
+    credential_option_set_certificate_provider(options, is_dummy);
+    credential_option_set_authorization_check(options);
+
+    return grpc::experimental::TlsCredentials(
+        reinterpret_cast<const grpc::experimental::TlsChannelCredentialsOptions&>(options));
+};
+
+std::shared_ptr<grpc::ChannelCredentials> TlsCredentials(
+    const char* cfg_json, grpc_tls_server_verification_option verify_option) {
+    ra_tls_parse_config(cfg_json);
+
+    grpc::sgx::CredentialsOptions options(verify_option);
+    int is_dummy = verify_option == GRPC_RA_TLS_SERVER_VERIFICATION;
+    credential_option_set_certificate_provider(options, is_dummy);
+    credential_option_set_authorization_check(options);
+
+    return grpc::experimental::TlsCredentials(
+        reinterpret_cast<const grpc::experimental::TlsChannelCredentialsOptions&>(options));
+};
+
+std::shared_ptr<grpc::ServerCredentials> TlsServerCredentials(
+    ra_tls_config cfg, grpc_tls_server_verification_option verify_option) {
+    ra_tls_parse_config(cfg);
+
+    grpc::sgx::CredentialsOptions options(verify_option);
+    int is_dummy = verify_option == GRPC_RA_TLS_CLIENT_VERIFICATION;
+    credential_option_set_certificate_provider(options, is_dummy);
+    credential_option_set_authorization_check(options);
+
+    return grpc::experimental::TlsServerCredentials(
+        reinterpret_cast<const grpc::experimental::TlsServerCredentialsOptions&>(options));
+};
+
+std::shared_ptr<grpc::ServerCredentials> TlsServerCredentials(
+    const char* cfg_json, grpc_tls_server_verification_option verify_option) {
+    ra_tls_parse_config(cfg_json);
+
+    grpc::sgx::CredentialsOptions options(verify_option);
+    int is_dummy = verify_option == GRPC_RA_TLS_CLIENT_VERIFICATION;
+    credential_option_set_certificate_provider(options, is_dummy);
+    credential_option_set_authorization_check(options);
+
+    return grpc::experimental::TlsServerCredentials(
+        reinterpret_cast<const grpc::experimental::TlsServerCredentialsOptions&>(options));
+};
+
+std::shared_ptr<grpc::Channel> CreateSecureChannel(
+    string target_str, std::shared_ptr<grpc::ChannelCredentials> channel_creds) {
+    GPR_ASSERT(channel_creds.get() != nullptr);
+    auto channel_args = grpc::ChannelArguments();
+    channel_args.SetSslTargetNameOverride("RATLS");
+    return grpc::CreateCustomChannel(target_str, std::move(channel_creds), channel_args);
+};
+
+} // namespace sgx
+} // namespace grpc
diff --git a/src/cpp/sgx/sgx_ra_tls_dummy.cc b/src/cpp/sgx/sgx_ra_tls_dummy.cc
new file mode 100644
index 0000000000..bd83db3309
--- /dev/null
+++ b/src/cpp/sgx/sgx_ra_tls_dummy.cc
@@ -0,0 +1,104 @@
+/*
+ *
+ * Copyright (c) 2022 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+// #ifdef SGX_RA_TLS_DUMMY_BACKEND
+
+#include <grpcpp/security/sgx/sgx_ra_tls_backends.h>
+#include <grpcpp/security/sgx/sgx_ra_tls_impl.h>
+
+namespace grpc {
+namespace sgx {
+
+int dummy_generate_quote(
+        uint8_t **quote_buf, uint32_t &quote_size, uint8_t *hash) {
+    quote_size = 0;
+    *quote_buf = (uint8_t*)calloc(quote_size+SHA256_DIGEST_LENGTH, sizeof(char));
+    memcpy((*quote_buf)+quote_size, hash, SHA256_DIGEST_LENGTH);
+    quote_size += SHA256_DIGEST_LENGTH;
+    return 1;
+};
+
+std::vector<std::string> dummy_generate_key_cert() {
+    return generate_key_cert(dummy_generate_quote);
+};
+
+void dummy_verify_init() {
+    struct ra_tls_config config;
+    config.verify_mr_enclave = false;
+    config.verify_mr_signer = false;
+    config.verify_isv_prod_id = false;
+    config.verify_isv_svn = false;
+    _ctx_.cfg = config;
+};
+
+int dummy_parse_quote(X509 *x509, uint8_t **quote, uint32_t &quote_size) {
+    return parse_quote(x509, quote, quote_size);
+};
+
+int dummy_verify_quote(uint8_t *quote_buf, size_t quote_size) {
+    return 0;
+}
+
+int dummy_verify_cert(const char *der_crt, size_t crt_size) {
+    int ret = 0;
+    uint32_t quote_size = 0;
+    uint8_t *quote_buf = nullptr;
+
+    BIO *bio = BIO_new(BIO_s_mem());
+    BIO_write(bio, der_crt, crt_size);
+    X509 *x509 = PEM_read_bio_X509(bio, NULL, NULL, NULL);
+    if (!x509) {
+        grpc_printf("parse crt failed!\n");
+        ret = -1;
+        goto out;
+    }
+
+    // parse quote
+    ret = dummy_parse_quote(x509, &quote_buf, quote_size);
+    if (ret != 0) {
+        grpc_printf("parse quote failed!\n");
+        goto out;
+    }
+
+    // verify quote
+    ret = dummy_verify_quote(quote_buf, quote_size-SHA256_DIGEST_LENGTH);
+    if (ret != 0) {
+        grpc_printf("verify quote failed!\n");
+        goto out;
+    }
+
+    // verify hash
+    ret = verify_pubkey_hash(x509, quote_buf+quote_size-SHA256_DIGEST_LENGTH, SHA256_DIGEST_LENGTH);
+    if (ret != 0) {
+        grpc_printf("verify pubkey hash failed!\n");
+        goto out;
+    }
+
+out:
+    BIO_free(bio);
+    return ret;
+}
+
+ra_tls_measurement dummy_parse_measurement(const char *der_crt, size_t len) {
+    return ra_tls_measurement();
+}
+
+} // namespace sgx
+} // namespace grpc
+
+// #endif // SGX_RA_TLS_DUMMY_BACKEND
diff --git a/src/cpp/sgx/sgx_ra_tls_gramine.cc b/src/cpp/sgx/sgx_ra_tls_gramine.cc
new file mode 100644
index 0000000000..ab83d50b1f
--- /dev/null
+++ b/src/cpp/sgx/sgx_ra_tls_gramine.cc
@@ -0,0 +1,165 @@
+/*
+ *
+ * Copyright (c) 2022 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+#ifdef SGX_RA_TLS_GRAMINE_BACKEND
+
+#include <grpcpp/security/sgx/sgx_ra_tls_backends.h>
+#include <grpcpp/security/sgx/sgx_ra_tls_impl.h>
+
+namespace grpc {
+namespace sgx {
+
+#include <mbedtls/config.h>
+#include <mbedtls/certs.h>
+#include <mbedtls/ctr_drbg.h>
+#include <mbedtls/debug.h>
+#include <mbedtls/entropy.h>
+#include <mbedtls/error.h>
+#include <mbedtls/net_sockets.h>
+#include <mbedtls/ssl.h>
+#include <mbedtls/x509.h>
+#include <mbedtls/x509_crt.h>
+#include <mbedtls/pk.h>
+#include <mbedtls/pem.h>
+#include <mbedtls/base64.h>
+#include <mbedtls/ecdsa.h>
+#include <mbedtls/rsa.h>
+
+std::vector<std::string> gramine_generate_key_cert() {
+    if (!_ctx_.attest_lib.get_handle()) {
+        _ctx_.attest_lib.open("libra_tls_attest.so", RTLD_LAZY);
+    }
+
+    auto ra_tls_create_key_and_crt =
+        reinterpret_cast<int (*)(mbedtls_pk_context*, mbedtls_x509_crt*)>(
+            _ctx_.attest_lib.get_func("ra_tls_create_key_and_crt"));
+
+    std::string error = "";
+    std::vector<std::string> key_cert;
+
+    mbedtls_x509_crt cert;
+    mbedtls_pk_context key;
+
+    mbedtls_x509_crt_init(&cert);
+    mbedtls_pk_init(&key);
+
+    int ret = (*ra_tls_create_key_and_crt)(&key, &cert);
+    if (ret != 0) {
+        error = "gramine_generate_key_cert->ra_tls_create_key_and_crt";
+        goto out;
+    }
+
+    unsigned char key_buffer[CERT_KEY_MAX_SIZE],
+                  cert_buffer[CERT_KEY_MAX_SIZE];
+    size_t olen;
+
+    ret = mbedtls_pk_write_key_pem(&key, key_buffer, CERT_KEY_MAX_SIZE);
+    if (ret != 0) {
+        error = "gramine_generate_key_cert->mbedtls_pk_write_key_pem";
+        goto out;
+    }
+
+    ret = mbedtls_pem_write_buffer("-----BEGIN CERTIFICATE-----\n",
+                                   "-----END CERTIFICATE-----\n",
+                                   cert.raw.p, cert.raw.len,
+                                   cert_buffer, CERT_KEY_MAX_SIZE, &olen);
+    if (ret != 0) {
+        error = "gramine_generate_key_cert->mbedtls_pem_write_buffer";
+        goto out;
+    };
+
+    key_cert.emplace_back(std::string((char*) key_buffer));
+    key_cert.emplace_back(std::string((char*) cert_buffer));
+
+out:
+    mbedtls_x509_crt_free(&cert);
+    mbedtls_pk_free(&key);
+
+    if (ret != 0) {
+        throw std::runtime_error(
+            std::string((error + std::string(" failed: %s\n")).c_str(),
+                        mbedtls_high_level_strerr(ret)));
+    }
+
+    return key_cert;
+};
+
+void gramine_verify_init() {
+    if (!_ctx_.verify_lib.get_handle()) {
+        _ctx_.verify_lib.open("libra_tls_verify_dcap_gramine.so", RTLD_LAZY);
+    }
+
+    if (!_ctx_.verify_callback_f) {
+        _ctx_.verify_callback_f =
+            reinterpret_cast<int (*)(uint8_t* der_crt, size_t len)>(
+                _ctx_.verify_lib.get_func("ra_tls_verify_callback_der"));
+    }
+
+    auto set_verify_mr_callback =
+        reinterpret_cast<void (*)(int (*)(const char *mr_enclave,
+                                          const char *mr_signer,
+                                          const char *isv_prod_id,
+                                          const char *isv_svn))>(
+            _ctx_.verify_lib.get_func("ra_tls_set_measurement_callback"));
+    (*set_verify_mr_callback)(verify_measurement);
+}
+
+int gramine_verify_cert(const char *der_crt, size_t len) {
+    return (*_ctx_.verify_callback_f)((uint8_t*)der_crt, len);
+}
+
+int gramine_parse_mr_callback(const char* mr_enclave, const char* mr_signer,
+                              const char* isv_prod_id, const char* isv_svn) {
+    struct ra_tls_measurement mr;
+    memcpy(mr.mr_enclave, mr_enclave, 32);
+    memcpy(mr.mr_signer, mr_signer, 32);
+    mr.isv_prod_id = *(uint16_t*)isv_prod_id;
+    mr.isv_svn = *(uint16_t*)isv_svn;
+    _ctx_.cache.mrs.insert({0, mr});
+    return 0;
+}
+
+ra_tls_measurement gramine_parse_measurement(const char *crt, size_t len) {
+    std::lock_guard<std::mutex> lock(_ctx_.mtx);
+
+    auto set_verify_mr_callback =
+        reinterpret_cast<void (*)(int (*)(const char *mr_enclave,
+                                          const char *mr_signer,
+                                          const char *isv_prod_id,
+                                          const char *isv_svn))>(
+            _ctx_.verify_lib.get_func("ra_tls_set_measurement_callback"));
+    (*set_verify_mr_callback)(gramine_parse_mr_callback);
+
+    gramine_verify_cert(crt, len);
+    ra_tls_measurement mr = _ctx_.cache.mrs[0];
+
+    set_verify_mr_callback =
+        reinterpret_cast<void (*)(int (*)(const char *mr_enclave,
+                                          const char *mr_signer,
+                                          const char *isv_prod_id,
+                                          const char *isv_svn))>(
+            _ctx_.verify_lib.get_func("ra_tls_set_measurement_callback"));
+    (*set_verify_mr_callback)(verify_measurement);
+
+    return mr;
+}
+
+} // namespace sgx
+} // namespace grpc
+
+#endif // SGX_RA_TLS_GRAMINE_BACKEND
diff --git a/src/cpp/sgx/sgx_ra_tls_impl.cc b/src/cpp/sgx/sgx_ra_tls_impl.cc
new file mode 100644
index 0000000000..3d61519b46
--- /dev/null
+++ b/src/cpp/sgx/sgx_ra_tls_impl.cc
@@ -0,0 +1,265 @@
+/*
+ *
+ *Copyright (c) 2022 Intel Corporation
+ *
+ *Licensed under the Apache License, Version 2.0 (the "License");
+ *you may not use this file except in compliance with the License.
+ *You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *Unless required by applicable law or agreed to in writing, software
+ *distributed under the License is distributed on an "AS IS" BASIS,
+ *WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *See the License for the specific language governing permissions and
+ *limitations under the License.
+ *
+ */
+
+#include <grpcpp/security/sgx/sgx_ra_tls_impl.h>
+
+namespace grpc {
+namespace sgx {
+
+const char *RA_TLS_SHORT_NAME = "RA-TLS";
+const char *RA_TLS_LONG_NAME = "RA-TLS Extension";
+
+struct ra_tls_context _ctx_;
+
+std::vector<std::string> generate_key_cert(
+    int (*generate_quote)(
+        uint8_t **quote_buf, uint32_t &quote_size, uint8_t *hash)) {
+    char private_key_pem[CERT_KEY_MAX_SIZE],
+                cert_pem[CERT_KEY_MAX_SIZE];
+
+    int32_t ret = -1;
+    uint32_t quote_size = 0;
+    uint8_t *quote_buf = nullptr;
+
+    BIGNUM *e = BN_new();
+    BN_set_word(e, RSA_F4);
+    RSA *rsa = RSA_new();
+    RSA_generate_key_ex(rsa, 2048, e, nullptr);
+
+    EVP_PKEY *pkey = EVP_PKEY_new();
+    EVP_PKEY_assign_RSA(pkey, rsa);
+
+    X509 *x509 = X509_new();
+
+    ASN1_INTEGER_set(X509_get_serialNumber(x509), 1);
+    X509_gmtime_adj(X509_get_notBefore(x509), 0);
+    X509_gmtime_adj(X509_get_notAfter(x509), 630720000L);
+    X509_set_pubkey(x509, pkey);
+
+    X509_NAME *name = X509_NAME_new();
+    // X509_NAME *name = X509_get_subject_name(x509);
+    X509_NAME_add_entry_by_txt(name, "C",  MBSTRING_ASC,
+                               (uint8_t *)"CN", -1, -1, 0);
+    X509_NAME_add_entry_by_txt(name, "O",  MBSTRING_ASC,
+                               (uint8_t *)"Intel Inc.", -1, -1, 0);
+    X509_NAME_add_entry_by_txt(name, "CN", MBSTRING_ASC,
+                               (uint8_t *)"localhost", -1, -1, 0);
+    X509_set_subject_name(x509, name);
+    X509_set_issuer_name(x509, name);
+
+    size_t key_size = i2d_PUBKEY(pkey, 0);
+    uint8_t *public_key = nullptr;
+    // size_t pubkey_size = i2d_PUBKEY(pkey, &public_key);
+    size_t pubkey_size = i2d_X509_PUBKEY(X509_get_X509_PUBKEY(x509), &public_key);
+
+    if (pubkey_size != key_size) {
+        grpc_printf("get public key failed!");
+    }
+
+    BIO *bio = BIO_new(BIO_s_mem());
+    if (!bio) {
+        grpc_printf("create bio failed!");
+    }
+
+    ret = PEM_write_bio_RSAPrivateKey(bio, rsa, nullptr, nullptr, 0, nullptr, nullptr);
+    if (ret == 0) {
+        grpc_printf("write private key failed!");
+    }
+
+    ret = BIO_read(bio, private_key_pem, bio->num_write);
+    if (ret == 0) {
+        grpc_printf("read private key failed!");
+    }
+
+    uint8_t hash[SHA256_DIGEST_LENGTH];
+    SHA256_CTX sha256;
+    SHA256_Init(&sha256);
+    SHA256_Update(&sha256, public_key, key_size);
+    SHA256_Final(hash, &sha256);
+
+    ret = generate_quote(&quote_buf, quote_size, hash);
+    if (ret == 0) {
+        grpc_printf("generate quote failed!\n");
+    }
+
+    int nid = OBJ_create("1.2.840.113741.1", RA_TLS_SHORT_NAME, RA_TLS_LONG_NAME);
+    const ASN1_OBJECT* obj = OBJ_nid2obj(nid);
+    ASN1_OCTET_STRING* data = ASN1_OCTET_STRING_new();
+    ASN1_OCTET_STRING_set(data, quote_buf, quote_size);
+
+    X509_EXTENSION* ext = X509_EXTENSION_create_by_OBJ(nullptr, obj, 0, data);
+    X509_add_ext(x509, ext, -1);
+    X509_sign(x509, pkey, EVP_sha1());
+
+    BIO *cert_bio = BIO_new(BIO_s_mem());
+    if (!cert_bio) {
+        grpc_printf("create crt bio failed!");
+    }
+
+    ret = PEM_write_bio_X509(cert_bio, x509);
+    if (ret == 0) {
+        grpc_printf("read crt bio failed!");
+    }
+
+    ret = BIO_read(cert_bio, cert_pem, cert_bio->num_write);
+    if (ret == 0) {
+        grpc_printf("read pem cert failed!");
+    }
+
+    std::vector<std::string> key_cert;
+    key_cert.emplace_back(std::string((char*) private_key_pem));
+    key_cert.emplace_back(std::string((char*) cert_pem));
+
+    BIO_free(bio);
+    BIO_free(cert_bio);
+    EVP_PKEY_free(pkey);
+    check_free(quote_buf);
+    return key_cert;
+}
+
+int parse_quote(X509 *x509, uint8_t **quote, uint32_t &quote_size) {
+    int ret = -1;
+    // STACK_OF(X509_EXTENSION) exts = x509->cert_info->extensions;
+    auto exts = X509_get0_extensions(x509);
+    if (exts) {
+        int ext_num = sk_X509_EXTENSION_num(exts);
+        for (int i = 0; i < ext_num; i++) {
+            X509_EXTENSION *ext = sk_X509_EXTENSION_value(exts, i);
+            ASN1_OBJECT *obj = X509_EXTENSION_get_object(ext);
+            int nid = OBJ_obj2nid(obj);
+            if (nid != NID_undef) {
+                const char *ln = OBJ_nid2ln(nid);
+                if (memcmp(RA_TLS_LONG_NAME, ln, sizeof(RA_TLS_LONG_NAME)) == 0) {
+                    BIO *ext_bio = BIO_new(BIO_s_mem());
+                    quote_size = i2d_ASN1_OCTET_STRING(ext->value, quote);
+                    *quote = *quote + 4;
+                    quote_size = quote_size - 4;
+                    ret = 0;
+                    BIO_free(ext_bio);
+                }
+            }
+        }
+    }
+
+    return ret;
+}
+
+int verify_pubkey_hash(X509 *x509, uint8_t *pubkey_hash, uint32_t hash_size) {
+    int32_t ret = -1;
+    uint8_t *public_key = nullptr;
+
+    // EVP_PKEY *pkey = X509_get_pubkey(x509);
+    // size_t key_size = EVP_PKEY_bits(pkey)/8;
+
+    auto key_size = i2d_X509_PUBKEY(X509_get_X509_PUBKEY(x509), &public_key);
+
+    uint8_t hash[hash_size];
+    SHA256_CTX sha256;
+    SHA256_Init(&sha256);
+    SHA256_Update(&sha256, public_key, key_size);
+    SHA256_Final(hash, &sha256);
+
+    // grpc_printf("hash size: %u, %u, %u\n", hash_size, sizeof(hash), sizeof(pubkey_hash));
+
+    ret = memcmp(hash, pubkey_hash, hash_size);
+    return ret;
+}
+
+static bool verify_measurement_internal(const char* mr_enclave,
+                                        const char* mr_signer,
+                                        const char* isv_prod_id,
+                                        const char* isv_svn) {
+    bool status = false;
+    auto & cfg = _ctx_.cfg;
+    if (!(cfg.verify_mr_enclave ||
+        cfg.verify_mr_signer ||
+        cfg.verify_isv_prod_id ||
+        cfg.verify_isv_svn)) {
+        status = true;
+    } else {
+        for (auto & obj : cfg.mrs) {
+            status = true;
+
+            if (status && cfg.verify_mr_enclave && \
+                memcmp(obj.mr_enclave, mr_enclave, 32)) {
+                status = false;
+            }
+
+            if (status && cfg.verify_mr_signer && \
+                memcmp(obj.mr_signer, mr_signer, 32)) {
+                status = false;
+            }
+
+            if (status && cfg.verify_isv_prod_id && \
+                (obj.isv_prod_id != *(uint16_t*)isv_prod_id)) {
+                status = false;
+            }
+
+            if (status && cfg.verify_isv_svn && \
+                (obj.isv_svn != *(uint16_t*)isv_svn)) {
+                status = false;
+            }
+
+            if (status) {
+                break;
+            }
+        }
+    }
+    return status;
+}
+
+int verify_measurement(const char* mr_enclave, const char* mr_signer,
+                       const char* isv_prod_id, const char* isv_svn) {
+    std::lock_guard<std::mutex> lock(_ctx_.mtx);
+    bool status = false;
+    try {
+        assert(mr_enclave && mr_signer && isv_prod_id && isv_svn);
+        status = verify_measurement_internal(mr_enclave, mr_signer, isv_prod_id, isv_svn);
+        grpc_printf("remote attestation\n");
+
+        if (_ctx_.cfg.verify_mr_enclave) {
+            grpc_printf("  |- mr_enclave     :  %s\n", byte_to_hex(mr_enclave, 32).c_str());
+        };
+
+        if (_ctx_.cfg.verify_mr_signer) {
+            grpc_printf("  |- mr_signer      :  %s\n", byte_to_hex(mr_signer, 32).c_str());
+        };
+
+        if (_ctx_.cfg.verify_isv_prod_id) {
+            grpc_printf("  |- isv_prod_id    :  %hu\n", *((uint16_t*)isv_prod_id));
+            };
+
+        if (_ctx_.cfg.verify_isv_svn) {
+            grpc_printf("  |- isv_svn        :  %hu\n", *((uint16_t*)isv_svn));
+        };
+
+        if (status) {
+            grpc_printf("  |- verify result  :  success\n");
+        } else {
+            grpc_printf("  |- verify result  :  failed\n");
+        }
+    } catch (...) {
+        grpc_printf("unable to verify measurement!");
+    }
+
+    fflush(stdout);
+    return status ? 0 : -1;
+}
+
+} // namespace sgx
+} // namespace grpc
diff --git a/src/cpp/sgx/sgx_ra_tls_impl.h b/src/cpp/sgx/sgx_ra_tls_impl.h
new file mode 100644
index 0000000000..929010f372
--- /dev/null
+++ b/src/cpp/sgx/sgx_ra_tls_impl.h
@@ -0,0 +1,53 @@
+/*
+ *
+ * Copyright (c) 2022 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+#ifndef SGX_RA_TLS_IMPL_H
+#define SGX_RA_TLS_IMPL_H
+
+#include "sgx_ra_tls_utils.h"
+#include "sgx_ra_tls_context.h"
+
+namespace grpc {
+namespace sgx {
+
+#include <openssl/evp.h>
+#include <openssl/rsa.h>
+#include <openssl/x509.h>
+#include <openssl/x509v3.h>
+#include <openssl/sha.h>
+#include <openssl/pem.h>
+#include <openssl/asn1.h>
+
+extern const char * RA_TLS_SHORT_NAME;
+extern const char * RA_TLS_LONG_NAME;
+
+std::vector<std::string> generate_key_cert(
+    int (*generate_quote)(
+        uint8_t **quote_buf, uint32_t &quote_size, uint8_t *hash));
+
+int parse_quote(X509 *x509, uint8_t **quote, uint32_t &quote_size);
+
+int verify_pubkey_hash(X509 *x509, uint8_t *pubkey_hash, uint32_t hash_size);
+
+int verify_measurement(const char* mr_enclave, const char* mr_signer,
+                       const char* isv_prod_id, const char* isv_svn);
+
+} // namespace sgx
+} // namespace grpc
+
+#endif // SGX_RA_TLS_IMPL_H
\ No newline at end of file
diff --git a/src/cpp/sgx/sgx_ra_tls_log.h b/src/cpp/sgx/sgx_ra_tls_log.h
new file mode 100644
index 0000000000..2b8bfb8adb
--- /dev/null
+++ b/src/cpp/sgx/sgx_ra_tls_log.h
@@ -0,0 +1,32 @@
+/*
+ *
+ * Copyright (c) 2022 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+#ifndef SGX_RA_TLS_LOG_H
+#define SGX_RA_TLS_LOG_H
+
+#define grpc_printf printf
+#define grpc_fprintf fprintf
+#define grpc_sprintf sprintf
+
+namespace grpc {
+namespace sgx {
+
+} // namespace sgx
+} // namespace grpc
+
+#endif // SGX_RA_TLS_LOG_H
diff --git a/src/cpp/sgx/sgx_ra_tls_occlum.cc b/src/cpp/sgx/sgx_ra_tls_occlum.cc
new file mode 100644
index 0000000000..61f4ebccd8
--- /dev/null
+++ b/src/cpp/sgx/sgx_ra_tls_occlum.cc
@@ -0,0 +1,350 @@
+/*
+ *
+ * Copyright (c) 2022 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+#ifdef SGX_RA_TLS_OCCLUM_BACKEND
+
+#include <grpcpp/security/sgx/sgx_ra_tls_backends.h>
+#include <grpcpp/security/sgx/sgx_ra_tls_impl.h>
+
+#ifdef SGX_RA_TLS_LIBRATS_SDK
+#include "librats/api.h"
+#endif
+
+namespace grpc {
+namespace sgx {
+
+#include "sgx_quote_3.h"
+#include "dcap_quote.h"
+
+int occlum_generate_quote(
+        uint8_t **quote_buf, uint32_t &quote_size, uint8_t *hash) {
+#ifdef SGX_RA_TLS_LIBRATS_SDK
+    int ret = 0;
+    rats_conf_t conf;
+    rats_attester_err_t aerr;
+    attestation_evidence_t ev;
+    rats_err_t err;
+
+    if (!_ctx_.init_lib.get_handle()) {
+        _ctx_.init_lib.open("librats_lib.so", RTLD_GLOBAL | RTLD_NOW);
+    }
+    auto librats_init =
+        reinterpret_cast< rats_err_t (*)(rats_conf_t *conf, rats_core_context_t *ctx)>(
+                _ctx_.init_lib.get_func("librats_init"));
+
+    if (!_ctx_.attest_lib.get_handle()) {
+        _ctx_.attest_lib.open("libattester_sgx_ecdsa.so", RTLD_GLOBAL | RTLD_NOW);
+    }
+    auto librats_collect_evidence =
+        reinterpret_cast< rats_attester_err_t (*)(rats_attester_ctx_t *ctx,
+                attestation_evidence_t *evidence, uint8_t *hash,
+                uint32_t hash_len)>(
+                    _ctx_.attest_lib.get_func("librats_collect_evidence"));
+
+    if (!_ctx_.cleanup_lib.get_handle()) {
+        _ctx_.cleanup_lib.open("librats_lib.so", RTLD_GLOBAL | RTLD_NOW);
+    }
+    auto librats_cleanup =
+        reinterpret_cast< rats_err_t (*)(rats_core_context_t *ctx)>(
+                _ctx_.cleanup_lib.get_func("librats_cleanup"));
+
+    conf.api_version = RATS_API_VERSION_DEFAULT;
+    conf.log_level = RATS_LOG_LEVEL_DEFAULT;
+    memcpy(conf.attester_type, "sgx_ecdsa", sizeof(conf.attester_type));
+    memcpy(conf.verifier_type, "sgx_ecdsa", sizeof(conf.verifier_type));
+
+    rats_core_context_t *ctx = (rats_core_context_t *)malloc(sizeof(struct rats_core_context));
+    if (!ctx) {
+        grpc_printf("couldn't allocate rats_core_context.\n");
+        ret = -1;
+    }
+    memcpy(ev.type, "sgx_ecdsa", sizeof(ev.type));
+
+    err = (*librats_init)(&conf, ctx);
+    if (err != RATS_ERR_NONE) {
+        grpc_printf("librats initialization failed.\n");
+        ret = -1;
+    }
+
+    aerr = (*librats_collect_evidence)(ctx->attester, &ev, (unsigned char *)hash, SHA256_DIGEST_LENGTH);
+    if (aerr != RATS_ATTESTER_ERR_NONE) {
+        grpc_printf("librats collect evidence failed.\n");
+        ret = -1;
+    }
+
+    quote_size = ev.ecdsa.quote_len;
+    *quote_buf = (uint8_t*)calloc(quote_size, sizeof(uint8_t));
+    if (nullptr == *quote_buf) {
+        grpc_printf("couldn't allocate quote_buf.\n");
+    }
+    memcpy(*quote_buf, ev.ecdsa.quote, quote_size);
+
+    err = (*librats_cleanup)(ctx);
+    if (err != RATS_ERR_NONE) {
+        grpc_printf("librats cleanup failed.\n");
+        ret = -1;
+    }
+#else
+    void *handle = dcap_quote_open();
+    quote_size = dcap_get_quote_size(handle);
+    *quote_buf = (uint8_t*)calloc(quote_size, sizeof(uint8_t));
+    if (nullptr == quote_buf) {
+        grpc_printf("couldn't allocate quote_buf.\n");
+    }
+
+    sgx_report_data_t report_data = { 0 };
+    memcpy(report_data.d, hash, SHA256_DIGEST_LENGTH);
+
+    int ret = dcap_generate_quote(handle, *quote_buf, &report_data);
+    if (ret != 0) {
+        grpc_printf("dcap_generate_quote failed.\n");
+    }
+
+    dcap_quote_close(handle);
+#endif
+
+    return !ret;
+};
+
+std::vector<std::string> occlum_generate_key_cert() {
+    return generate_key_cert(occlum_generate_quote);
+}
+
+int occlum_parse_quote(X509 *x509, uint8_t **quote, uint32_t &quote_size) {
+    return parse_quote(x509, quote, quote_size);
+};
+
+void occlum_verify_init() {
+    generate_key_cert(dummy_generate_quote);
+};
+
+int occlum_verify_quote(uint8_t *quote_buf, size_t quote_size) {
+    void *handle = dcap_quote_open();
+
+    uint32_t supplemental_size = dcap_get_supplemental_data_size(handle);
+    uint8_t *p_supplemental_buffer = (uint8_t *)calloc(supplemental_size, sizeof(uint8_t));
+    if (NULL == p_supplemental_buffer) {
+        grpc_printf("Couldn't allocate supplemental buffer\n");
+    }
+
+    sgx_ql_qv_result_t quote_verification_result = SGX_QL_QV_RESULT_UNSPECIFIED;
+    uint32_t collateral_expiration_status = 1;
+    uint32_t ret = dcap_verify_quote(
+        handle,
+        quote_buf,
+        quote_size,
+        &collateral_expiration_status,
+        &quote_verification_result,
+        supplemental_size,
+        p_supplemental_buffer);
+
+    if (ret != 0) {
+        grpc_printf( "Error in dcap_verify_quote.\n");
+    }
+
+    if (collateral_expiration_status != 0) {
+        grpc_printf("The verification collateral has expired!\n");
+    }
+
+    switch (quote_verification_result) {
+        case SGX_QL_QV_RESULT_OK:
+            grpc_printf("Succeed to verify the quote!\n");
+            break;
+        case SGX_QL_QV_RESULT_CONFIG_NEEDED:
+        case SGX_QL_QV_RESULT_OUT_OF_DATE:
+        case SGX_QL_QV_RESULT_OUT_OF_DATE_CONFIG_NEEDED:
+        case SGX_QL_QV_RESULT_SW_HARDENING_NEEDED:
+        case SGX_QL_QV_RESULT_CONFIG_AND_SW_HARDENING_NEEDED:
+            grpc_printf("WARN: App: Verification completed with Non-terminal result: %x\n",
+                   quote_verification_result);
+            break;
+        case SGX_QL_QV_RESULT_INVALID_SIGNATURE:
+        case SGX_QL_QV_RESULT_REVOKED:
+        case SGX_QL_QV_RESULT_UNSPECIFIED:
+        default:
+            grpc_printf("\tError: App: Verification completed with Terminal result: %x\n",
+                   quote_verification_result);
+    }
+    check_free(p_supplemental_buffer);
+    dcap_quote_close(handle);
+    return ret;
+}
+
+uint8_t *occlum_parse_pubkey_hash(void *p_quote) {
+    auto p_rep_body =
+        (sgx_report_body_t *)(&((sgx_quote3_t *)p_quote)->report_body);
+    auto p_rep_data = (sgx_report_data_t *)(&p_rep_body->report_data);
+    return p_rep_data->d;
+}
+
+sgx_report_body_t * occlum_parse_report_body(void *p_quote) {
+    return (sgx_report_body_t *)(&((sgx_quote3_t *)p_quote)->report_body);
+}
+
+int occlum_verify_cert(const char *der_crt, size_t len) {
+    int ret = 0;
+    uint32_t quote_size = 0;
+    uint8_t *quote_buf = nullptr;
+    uint8_t *pubkey_hash = nullptr;
+    sgx_report_body_t *p_rep_body = nullptr;
+
+#ifdef SGX_RA_TLS_LIBRATS_SDK
+    rats_conf_t conf;
+    rats_verifier_err_t verr;
+    attestation_evidence_t ev;
+    rats_err_t err;
+    rats_core_context_t *ctx;
+
+    if (!_ctx_.init_lib.get_handle()) {
+        _ctx_.init_lib.open("librats_lib.so", RTLD_LAZY);
+    }
+    auto librats_init =
+        reinterpret_cast< rats_err_t (*)(rats_conf_t *conf, rats_core_context_t *ctx)>(
+                _ctx_.init_lib.get_func("librats_init"));
+
+    if (!_ctx_.verify_lib.get_handle()) {
+        _ctx_.verify_lib.open("libverifier_sgx_ecdsa.so", RTLD_LAZY);
+    }
+    auto librats_verify_evidence =
+        reinterpret_cast< rats_verifier_err_t (*)(rats_verifier_ctx_t *ctx,
+                attestation_evidence_t *evidence, uint8_t *hash,
+                uint32_t hash_len)>(
+                    _ctx_.verify_lib.get_func("librats_verify_evidence"));
+
+    if (!_ctx_.cleanup_lib.get_handle()) {
+        _ctx_.cleanup_lib.open("librats_lib.so", RTLD_GLOBAL | RTLD_NOW);//RTLD_LAZY);
+    }
+    auto librats_cleanup =
+        reinterpret_cast< rats_err_t (*)(rats_core_context_t *ctx)>(
+                _ctx_.cleanup_lib.get_func("librats_cleanup"));
+#endif
+    BIO *bio = BIO_new(BIO_s_mem());
+    BIO_write(bio, der_crt, len);
+    X509 *x509 = PEM_read_bio_X509(bio, NULL, NULL, NULL);
+    if (!x509) {
+        grpc_printf("parse crt failed!\n");
+        ret = -1;
+        goto out;
+    }
+
+    ret = occlum_parse_quote(x509, &quote_buf, quote_size);
+    if (ret != 0) {
+        grpc_printf("parse quote failed!\n");
+        goto out;
+    }
+
+#ifdef SGX_RA_TLS_LIBRATS_SDK
+    conf.api_version = RATS_API_VERSION_DEFAULT;
+    conf.log_level = RATS_LOG_LEVEL_DEFAULT;
+    memcpy(conf.verifier_type, "sgx_ecdsa", sizeof(conf.verifier_type));
+    memcpy(conf.attester_type, "sgx_ecdsa", sizeof(conf.attester_type));
+
+    ctx = (rats_core_context_t *)malloc(sizeof(struct rats_core_context));
+    if (!ctx) {
+        grpc_printf("couldn't malloc rats_core_context\n");
+        ret = -1;
+        goto out;
+    }
+    memcpy(ev.type, "sgx_ecdsa", sizeof(ev.type));
+    memcpy(ev.ecdsa.quote, quote_buf, quote_size);
+    ev.ecdsa.quote_len = quote_size;
+
+    err = (*librats_init)(&conf, ctx);
+    if (err != RATS_ERR_NONE) {
+        grpc_printf("librats initialization failed\n");
+        ret = -1;
+        goto out;
+    }
+
+    pubkey_hash = occlum_parse_pubkey_hash(quote_buf);
+    verr = (*librats_verify_evidence)(ctx->verifier, &ev, pubkey_hash, SHA256_DIGEST_LENGTH);
+    if (verr != RATS_VERIFIER_ERR_NONE) {
+        grpc_printf("librats verify evidence failed\n");
+        ret = -1;
+        goto out;
+    }
+
+    err = (*librats_cleanup)(ctx);
+    if (err != RATS_ERR_NONE) {
+        grpc_printf("librats cleanup failed\n");
+        ret = -1;
+    }
+#else
+    ret = occlum_verify_quote(quote_buf, quote_size);
+    if (ret != 0) {
+        grpc_printf("verify quote failed!\n");
+        goto out;
+    }
+
+    pubkey_hash = occlum_parse_pubkey_hash(quote_buf);
+    ret = verify_pubkey_hash(x509, pubkey_hash, SHA256_DIGEST_LENGTH);
+    if (ret != 0) {
+        grpc_printf("verify pubkey hash failed!\n");
+        goto out;
+    }
+#endif
+
+    p_rep_body = occlum_parse_report_body(quote_buf);
+    ret = verify_measurement((const char *)&p_rep_body->mr_enclave,
+                             (const char *)&p_rep_body->mr_signer,
+                             (const char *)&p_rep_body->isv_prod_id,
+                             (const char *)&p_rep_body->isv_svn);
+
+out:
+    BIO_free(bio);
+    return ret;
+}
+
+ra_tls_measurement occlum_parse_measurement(const char *der_crt, size_t len) {
+    int ret = 0;
+    uint32_t quote_size = 0;
+    uint8_t *quote_buf = nullptr;
+    uint8_t *pubkey_hash = nullptr;
+    sgx_report_body_t *p_rep_body = nullptr;
+    struct ra_tls_measurement mr;
+
+    BIO *bio = BIO_new(BIO_s_mem());
+    BIO_write(bio, der_crt, len);
+    X509 *x509 = PEM_read_bio_X509(bio, NULL, NULL, NULL);
+    if (!x509) {
+        grpc_printf("parse crt failed!\n");
+        ret = -1;
+        goto out;
+    }
+
+    ret = occlum_parse_quote(x509, &quote_buf, quote_size);
+    if (ret != 0) {
+        grpc_printf("parse quote failed!\n");
+        goto out;
+    }
+
+    p_rep_body = occlum_parse_report_body(quote_buf);
+    memcpy(mr.mr_enclave, &p_rep_body->mr_enclave, 32);
+    memcpy(mr.mr_signer, &p_rep_body->mr_signer, 32);
+    mr.isv_prod_id = p_rep_body->isv_prod_id;
+    mr.isv_svn = p_rep_body->isv_svn;
+
+out:
+    BIO_free(bio);
+    return mr;
+}
+
+} // namespace sgx
+} // namespace grpc
+
+#endif // SGX_RA_TLS_OCCLUM_BACKEND
diff --git a/src/cpp/sgx/sgx_ra_tls_options.cc b/src/cpp/sgx/sgx_ra_tls_options.cc
new file mode 100644
index 0000000000..ea800aed88
--- /dev/null
+++ b/src/cpp/sgx/sgx_ra_tls_options.cc
@@ -0,0 +1,53 @@
+/*
+ *
+ * Copyright (c) 2022 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+#include <grpc/grpc_security.h>
+#include <grpc/support/alloc.h>
+#include <grpcpp/security/sgx/sgx_ra_tls_options.h>
+
+#include "absl/container/inlined_vector.h"
+#include "src/cpp/common/tls_credentials_options_util.h"
+
+namespace grpc {
+namespace sgx {
+
+void CredentialsOptions::set_verification_option(
+    grpc_tls_server_verification_option server_verification_option) {
+    grpc_tls_credentials_options* options = c_credentials_options();
+    GPR_ASSERT(options != nullptr);
+    grpc_tls_credentials_options_set_server_verification_option(
+        options, server_verification_option);
+}
+
+void CredentialsOptions::set_authorization_check_config(
+    std::shared_ptr<grpc::experimental::TlsServerAuthorizationCheckConfig> config) {
+    grpc_tls_credentials_options* options = c_credentials_options();
+    GPR_ASSERT(options != nullptr);
+    grpc_tls_credentials_options_set_server_authorization_check_config(
+        options, config->c_config());
+}
+
+void CredentialsOptions::set_cert_request_type(
+    grpc_ssl_client_certificate_request_type cert_request_type) {
+    grpc_tls_credentials_options* options = c_credentials_options();
+    GPR_ASSERT(options != nullptr);
+    grpc_tls_credentials_options_set_cert_request_type(options, cert_request_type);
+}
+
+} // namespace sgx
+} // namespace grpc
diff --git a/src/cpp/sgx/sgx_ra_tls_tdx.cc b/src/cpp/sgx/sgx_ra_tls_tdx.cc
new file mode 100644
index 0000000000..8ad1843b5f
--- /dev/null
+++ b/src/cpp/sgx/sgx_ra_tls_tdx.cc
@@ -0,0 +1,423 @@
+/*
+ *
+ * Copyright (c) 2022 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+#if defined(SGX_RA_TLS_TDX_BACKEND) || defined (SGX_RA_TLS_AZURE_TDX_BACKEND)
+
+#include <grpcpp/security/sgx/sgx_ra_tls_backends.h>
+#include <grpcpp/security/sgx/sgx_ra_tls_impl.h>
+#include <stdio.h>
+#include <vector>
+#include <string>
+#include <assert.h>
+#include <fstream>
+#include <cstring>
+
+#ifdef SGX_RA_TLS_AZURE_TDX_BACKEND
+#include <azguestattestation1/AttestationClient.h>
+#include <nlohmann/json.hpp>
+#include <chrono>
+#include "azure_tdx/Utils.h"
+#include "azure_tdx/Logger.h"
+#include "azure_tdx/AttestClient.h"
+#include "azure_tdx/HttpClient.h"
+#endif
+
+#ifdef SGX_RA_TLS_TDX_BACKEND
+#include "sgx_urts.h"
+#endif
+
+namespace grpc {
+namespace sgx {
+
+#include <tdx_attest.h>
+
+#ifdef SGX_RA_TLS_TDX_BACKEND
+#include <sgx_ql_quote.h>
+#include <sgx_dcap_quoteverify.h>
+#endif
+
+#ifdef SGX_RA_TLS_AZURE_TDX_BACKEND
+using json = nlohmann::json;
+using namespace std;
+using namespace std::chrono;
+#endif
+
+const uint8_t g_att_key_id_list[256] = {0};
+
+static void tdx_gen_report_data(uint8_t *reportdata) {
+    srand(time(NULL));
+    for (int i = 0; i < TDX_REPORT_DATA_SIZE; i++) {
+        reportdata[i] = rand();
+    }
+}
+
+#ifdef SGX_RA_TLS_AZURE_TDX_BACKEND
+static int tdx_generate_quote(
+        uint8_t **quote_buf, uint32_t &quote_size, uint8_t *hash) {
+
+  int ret = -1;
+
+  try {
+    AttestationClient *attestation_client = nullptr;
+    Logger *log_handle = new Logger();
+
+    // Initialize attestation client
+    if (!Initialize(log_handle, &attestation_client)) {
+      grpc_fprintf(stderr, "Failed to create attestation client object\n\n");
+      Uninitialize();
+      return(0);
+    }
+    attest::AttestationResult result;
+
+    auto start = high_resolution_clock::now();
+
+    unsigned char *evidence = nullptr;
+    result = attestation_client->GetHardwarePlatformEvidence(&evidence);
+
+    auto stop = high_resolution_clock::now();
+    duration<double, std::milli> elapsed = stop - start;
+
+    if (result.code_ != attest::AttestationResult::ErrorCode::SUCCESS) {
+      grpc_fprintf(stderr, "Failed to get quote\n\n");
+      Uninitialize();
+      return(0);
+    }
+
+    std::string quote_data;
+    quote_data = reinterpret_cast<char *>(evidence);
+
+    // Parses the returned json response
+    json json_response = json::parse(quote_data);
+
+    std::string encoded_quote = json_response["quote"];
+    if (encoded_quote.empty()) {
+      result.code_ = attest::AttestationResult::ErrorCode::ERROR_EMPTY_TD_QUOTE;
+      result.description_ = std::string("Empty Quote received from IMDS Quote Endpoint");
+      Uninitialize();
+      return(0);
+    }
+
+    // decode the base64url encoded quote to raw bytes
+    std::vector<unsigned char> quote_bytes = Utils::base64url_to_binary(encoded_quote);
+
+    quote_size = quote_bytes.size();
+    *quote_buf = (uint8_t *)realloc(*quote_buf, quote_size+SHA256_DIGEST_LENGTH);
+    memcpy(*quote_buf, (uint8_t *)quote_bytes.data(), quote_size);
+    memcpy((*quote_buf)+quote_size, hash, SHA256_DIGEST_LENGTH);
+    quote_size += SHA256_DIGEST_LENGTH;
+
+    print_hex_dump("tdx_generate_quote: TDX quote data\n", " ", *quote_buf, quote_size);
+
+    Uninitialize();
+  }
+  catch (std::exception &e) {
+    cout << "Exception occured. Details - " << e.what() << endl;
+    return(0);
+  }
+
+  return ret;
+};
+#else
+static int tdx_generate_quote(
+        uint8_t **quote_buf, uint32_t &quote_size, uint8_t *hash) {
+    int ret = -1;
+
+    tdx_report_data_t report_data = {{0}};
+    tdx_report_t tdx_report = {{0}};
+    tdx_uuid_t selected_att_key_id = {0};
+
+    tdx_gen_report_data(report_data.d);
+    // print_hex_dump("TDX report data\n", " ", report_data.d, sizeof(report_data.d));
+
+    if (TDX_ATTEST_SUCCESS != tdx_att_get_report(&report_data, &tdx_report)) {
+        grpc_fprintf(stderr, "failed to get the report.\n");
+        ret = 0;
+    }
+    // print_hex_dump("TDX report\n", " ", tdx_report.d, sizeof(tdx_report.d));
+
+    if (TDX_ATTEST_SUCCESS != tdx_att_get_quote(&report_data, NULL, 0, &selected_att_key_id,
+        quote_buf, &quote_size, 0)) {
+        grpc_fprintf(stderr, "failed to get the quote.\n");
+        ret = 0;
+    }
+    // print_hex_dump("TDX quote data\n", " ", *quote_buf, quote_size);
+
+    // printf("tdx_generate_quote, sizeof %d, quote_size %d\n", sizeof(*quote_buf), quote_size);
+
+    realloc(*quote_buf, quote_size+SHA256_DIGEST_LENGTH);
+    memcpy((*quote_buf)+quote_size, hash, SHA256_DIGEST_LENGTH);
+    quote_size += SHA256_DIGEST_LENGTH;
+
+    // printf("tdx_generate_quote, sizeof %d, quote_size %d\n", sizeof(*quote_buf), quote_size);
+    return ret;
+};
+#endif
+
+std::vector<std::string> tdx_generate_key_cert() {
+    return generate_key_cert(tdx_generate_quote);
+}
+
+int tdx_parse_quote(X509 *x509, uint8_t **quote, uint32_t &quote_size) {
+    return parse_quote(x509, quote, quote_size);
+};
+
+void tdx_verify_init() {
+    generate_key_cert(dummy_generate_quote);
+};
+
+#ifdef SGX_RA_TLS_AZURE_TDX_BACKEND
+int tdx_verify_quote(uint8_t *quote_buf, size_t quote_size) {
+  int ret = -1;
+
+  try {
+    std::string config_filename = "/etc/azure_tdx_config.json";
+
+    // set attestation request based on config file
+    std::ifstream config_file(config_filename);
+    json config;
+    if (config_file.is_open()) {
+      config = json::parse(config_file);
+      config_file.close();
+    } else {
+        grpc_fprintf(stderr, "Failed to open config file\n\n");
+        return(ret);
+    }
+
+    std::string attestation_url;
+    if (!config.contains("attestation_url")) {
+      grpc_fprintf(stderr, "Attestation_url is missing\n\n");
+      return(ret);
+    }
+    attestation_url = config["attestation_url"];
+
+    std::string api_key;
+    if (config.contains("api_key")) {
+      api_key = config["api_key"];
+    }
+
+    bool metrics_enabled = false;
+    if (config.contains("enable_metrics")) {
+      metrics_enabled = config["enable_metrics"];
+    }
+
+    std::string provider;
+    if (!config.contains("attestation_provider")) {
+      grpc_fprintf(stderr, "Attestation_provider is missing\n\n");
+      return(ret);
+    }
+    provider = config["attestation_provider"];
+
+    if (!Utils::case_insensitive_compare(provider, "amber") &&
+        !Utils::case_insensitive_compare(provider, "maa")) {
+      grpc_fprintf(stderr, "Attestation provider was incorrect\n\n");
+      return(ret);
+    }
+
+    std::map<std::string, std::string> hash_type;
+    hash_type["maa"] = "sha256";
+    hash_type["amber"] = "sha512";
+
+    // check for user claims
+    std::string client_payload;
+    json user_claims = config["claims"];
+    if (!user_claims.is_null()) {
+      client_payload = user_claims.dump();
+    }
+
+    // if attesting with Amber, we need to make sure an API token was provided
+    if (api_key.empty() && Utils::case_insensitive_compare(provider, "amber")) {
+      grpc_fprintf(stderr, "Attestation endpoint \"api_key\" value missing\n\n");
+      return(ret);
+    }
+
+    print_hex_dump("tdx_verify_quote: TDX quote data\n", " ", quote_buf, quote_size);
+
+    std::vector<unsigned char> quote_vector(quote_buf, quote_buf + quote_size);
+    std::string encoded_quote = Utils::binary_to_base64url(quote_vector);
+
+    // For now, pass empty claim
+    std::string json_claims = "{}";
+    std::vector<unsigned char> claims_vector(json_claims.begin(), json_claims.end());
+    std::string encoded_claims = Utils::binary_to_base64url(claims_vector);
+
+    HttpClient http_client;
+    AttestClient::Config attestation_config = {
+        attestation_url,
+        provider,
+        encoded_quote,
+        encoded_claims,
+        api_key};
+
+    auto start = high_resolution_clock::now();
+    std::string jwt_token = AttestClient::VerifyEvidence(attestation_config, http_client);
+    auto stop = high_resolution_clock::now();
+    duration<double, std::milli> token_elapsed = stop - start;
+
+    if (jwt_token.empty()) {
+      fprintf(stderr, "Empty token received\n");
+      return(ret);
+    }
+
+    grpc_printf("Info: App: Verification completed successfully.\n");
+
+    return(0);
+  }
+  catch (std::exception &e) {
+    cout << "Exception occured. Details - " << e.what() << endl;
+    return(1);
+  }
+}
+#else
+int tdx_verify_quote(uint8_t *quote_buf, size_t quote_size) {
+    bool use_qve = false;
+    (void)(use_qve);
+
+    int ret = 0;
+    time_t current_time = 0;
+    uint32_t supplemental_data_size = 0;
+    uint8_t *p_supplemental_data = nullptr;
+
+    quote3_error_t dcap_ret = SGX_QL_ERROR_UNEXPECTED;
+    sgx_ql_qv_result_t quote_verification_result = SGX_QL_QV_RESULT_UNSPECIFIED;
+    uint32_t collateral_expiration_status = 1;
+
+    sgx_status_t sgx_ret = SGX_SUCCESS;
+    uint8_t rand_nonce[16] = "59jslk201fgjmm;";
+    sgx_ql_qe_report_info_t qve_report_info;
+    sgx_launch_token_t token = { 0 };
+
+    int updated = 0;
+    quote3_error_t verify_qveid_ret = SGX_QL_ERROR_UNEXPECTED;
+    sgx_enclave_id_t eid = 0;
+
+    // call DCAP quote verify library to get supplemental data size
+    dcap_ret = tdx_qv_get_quote_supplemental_data_size(&supplemental_data_size);
+    if (dcap_ret == SGX_QL_SUCCESS && \
+        supplemental_data_size == sizeof(sgx_ql_qv_supplemental_t)) {
+        grpc_printf("Info: tdx_qv_get_quote_supplemental_data_size successfully returned.\n");
+        p_supplemental_data = (uint8_t*)malloc(supplemental_data_size);
+    } else {
+        grpc_printf("Error: tdx_qv_get_quote_supplemental_data_size failed: 0x%04x\n", dcap_ret);
+        supplemental_data_size = 0;
+    }
+
+    // set current time. This is only for sample purposes, in production mode a trusted time should be used.
+    current_time = time(NULL);
+
+    // call DCAP quote verify library for quote verification
+    print_hex_dump("TDX parse quote data\n", " ", quote_buf, quote_size);
+    dcap_ret = tdx_qv_verify_quote(
+            quote_buf, quote_size,
+            NULL,
+            current_time,
+            &collateral_expiration_status,
+            &quote_verification_result,
+            NULL,
+            supplemental_data_size,
+            p_supplemental_data);
+    if (dcap_ret == SGX_QL_SUCCESS) {
+        grpc_printf("Info: App: tdx_qv_verify_quote successfully returned.\n");
+    } else {
+        grpc_printf("Error: App: tdx_qv_verify_quote failed: 0x%04x\n", dcap_ret);
+    }
+
+    //check verification result
+    switch (quote_verification_result) {
+        case SGX_QL_QV_RESULT_OK:
+            //check verification collateral expiration status
+            //this value should be considered in your own attestation/verification policy
+            //
+            if (collateral_expiration_status == 0) {
+                grpc_printf("Info: App: Verification completed successfully.\n");
+                ret = 0;
+            } else {
+                grpc_printf("Warning: App: Verification completed, but collateral is out of date based on 'expiration_check_date' you provided.\n");
+                ret = 1;
+            }
+            break;
+        case SGX_QL_QV_RESULT_CONFIG_NEEDED:
+        case SGX_QL_QV_RESULT_OUT_OF_DATE:
+        case SGX_QL_QV_RESULT_OUT_OF_DATE_CONFIG_NEEDED:
+        case SGX_QL_QV_RESULT_SW_HARDENING_NEEDED:
+        case SGX_QL_QV_RESULT_CONFIG_AND_SW_HARDENING_NEEDED:
+            grpc_printf("Warning: App: Verification completed with Non-terminal result: %x\n", quote_verification_result);
+            ret = 1;
+            break;
+        case SGX_QL_QV_RESULT_INVALID_SIGNATURE:
+        case SGX_QL_QV_RESULT_REVOKED:
+        case SGX_QL_QV_RESULT_UNSPECIFIED:
+        default:
+            grpc_printf("Error: App: Verification completed with Terminal result: %x\n", quote_verification_result);
+            ret = -1;
+            break;
+    }
+
+    return ret;
+}
+#endif
+
+int tdx_verify_cert(const char *der_crt, size_t len) {
+    int ret = 0;
+    uint32_t quote_size = 0;
+    uint8_t *quote_buf = nullptr;
+
+    BIO *bio = BIO_new(BIO_s_mem());
+    BIO_write(bio, der_crt, len);
+    X509 *x509 = PEM_read_bio_X509(bio, NULL, NULL, NULL);
+    if (!x509) {
+        grpc_printf("parse the crt failed.\n");
+        goto out;
+    }
+
+    ret = tdx_parse_quote(x509, &quote_buf, quote_size);
+    if (ret != 0) {
+        grpc_printf("parse quote failed.\n");
+        goto out;
+    }
+
+    ret = tdx_verify_quote(quote_buf, quote_size-SHA256_DIGEST_LENGTH);
+    if (ret != 0) {
+        grpc_printf("verify quote failed.\n");
+        goto out;
+    }
+
+    ret = verify_pubkey_hash(x509, quote_buf+quote_size-SHA256_DIGEST_LENGTH, SHA256_DIGEST_LENGTH);
+    if (ret != 0) {
+        grpc_printf("verify the public key hash failed.\n");
+        goto out;
+    }
+
+    // ret = verify_measurement((const char *)&p_rep_body->mr_enclave,
+    //                          (const char *)&p_rep_body->mr_signer,
+    //                          (const char *)&p_rep_body->isv_prod_id,
+    //                          (const char *)&p_rep_body->isv_svn);
+
+out:
+    BIO_free(bio);
+    return ret;
+}
+
+ra_tls_measurement tdx_parse_measurement(const char *der_crt, size_t len) {
+    // TODO
+    return ra_tls_measurement();
+}
+
+} // namespace sgx
+} // namespace grpc
+
+#endif // SGX_RA_TLS_TDX_BACKEND || SGX_RA_TLS_AZURE_TDX_BACKEND
diff --git a/src/cpp/sgx/sgx_ra_tls_utils.cc b/src/cpp/sgx/sgx_ra_tls_utils.cc
new file mode 100644
index 0000000000..019aef292a
--- /dev/null
+++ b/src/cpp/sgx/sgx_ra_tls_utils.cc
@@ -0,0 +1,212 @@
+/*
+ *
+ * Copyright (c) 2022 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+#include <grpcpp/security/sgx/sgx_ra_tls_utils.h>
+
+#include <cstring>
+#include <iostream>
+#include <fstream>
+#include <sstream>
+
+namespace grpc {
+namespace sgx {
+
+void check_free(void* ptr) {
+    if (ptr) {
+        free(ptr);
+        ptr = nullptr;
+    };
+}
+
+template<typename T>
+void check_delete(T ptr) {
+    if (ptr) {
+        delete(ptr);
+        ptr = nullptr;
+    };
+}
+
+bool check_file(const char* file_path) {
+    bool ret = false;
+    if (file_path) {
+        struct stat buffer;
+        ret = stat(file_path, &buffer) == 0;
+    }
+    return ret;
+}
+
+bool hex_to_byte(const char *src, char *dst, size_t dst_size) {
+    if (std::strlen(src) < dst_size*2) {
+        return false;
+    } else {
+        for (auto i = 0; i < dst_size; i++) {
+            if (!isxdigit(src[i*2]) || !isxdigit(src[i*2+1])) {
+                return false;
+            } else {
+                sscanf(src+i*2, "%02hhx", dst+i);
+            }
+        }
+        return true;
+    }
+};
+
+void byte_to_hex(const char *src, char *dst, size_t src_size) {
+    for (auto i = 0; i < src_size; i++) {
+        grpc_sprintf(dst+i*2, "%02hhx", src[i]);
+    }
+};
+
+std::string byte_to_hex(const char *src, size_t src_size) {
+    char dst[src_size*2];
+    memset(dst, 0, sizeof(dst));
+    byte_to_hex(src, dst, src_size);
+    return std::string(dst);
+};
+
+void print_hex_dump(const char *title, const char *prefix_str,
+                    const uint8_t *buf, int len) {
+    const uint8_t *ptr = buf;
+    int i, rowsize = HEX_DUMP_SIZE;
+
+    if (!len || !buf) {
+        return;
+    }
+
+    grpc_fprintf(stdout, "\t\t%s", title);
+
+    for (i = 0; i < len; i++) {
+        if (!(i % rowsize)) {
+            grpc_fprintf(stdout, "\n%s%.8x:", prefix_str, i);
+        }
+
+        if (ptr[i] <= 0x0f) {
+            grpc_fprintf(stdout, " 0%x", ptr[i]);
+        } else {
+            grpc_fprintf(stdout, " %x", ptr[i]);
+        }
+    }
+
+    grpc_fprintf(stdout, "\n");
+}
+
+library_engine::library_engine() : handle(nullptr), error(nullptr) {};
+
+library_engine::library_engine(const char* file, int mode) : handle(nullptr), error(nullptr) {
+    this->open(file, mode);
+}
+
+library_engine::~library_engine() {
+    this->close();
+}
+
+void library_engine::open(const char* file, int mode) {
+    this->close();
+    handle = dlopen(file, mode);
+    error = dlerror();
+    if (error != nullptr || handle == nullptr) {
+        throw std::runtime_error("dlopen " + std::string(file) + " error, " + std::string(error));
+    }
+}
+
+void library_engine::close() {
+    if (handle) {
+        dlclose(handle);
+    }
+    handle = nullptr;
+    error = nullptr;
+}
+
+void* library_engine::get_func(const char* name) {
+    auto func = dlsym(handle, name);
+    error = dlerror();
+    if (error != nullptr || func == nullptr) {
+        throw std::runtime_error("dlsym " + std::string(name) + " error, " + std::string(error));
+        return nullptr;
+    } else {
+        return func;
+    }
+}
+
+void* library_engine::get_handle() {
+    return handle;
+}
+
+json_engine::json_engine() : handle(nullptr) {};
+
+json_engine::json_engine(const char* file) : handle(nullptr){
+    this->open(file);
+}
+
+json_engine::~json_engine() {
+    this->close();
+}
+
+bool json_engine::open(const char* file) {
+    if (!file) {
+        grpc_printf("wrong json file path\n");
+        return false;
+    }
+
+    this->close();
+
+    auto file_ptr = fopen(file, "r");
+    fseek(file_ptr, 0, SEEK_END);
+    auto length = ftell(file_ptr);
+    fseek(file_ptr, 0, SEEK_SET);
+    auto buffer = malloc(length);
+    fread(buffer, 1, length, file_ptr);
+    fclose(file_ptr);
+
+    this->handle = cJSON_Parse((const char *)buffer);
+
+    check_free(buffer);
+
+    if (this->handle) {
+        return true;
+    } else {
+        grpc_printf("cjson open %s error: %s", file, cJSON_GetErrorPtr());
+        return false;
+    }
+}
+
+void json_engine::close() {
+    if (this->handle) {
+        cJSON_Delete(this->handle);
+        this->handle = nullptr;
+    }
+}
+
+cJSON* json_engine::get_handle() {
+    return this->handle;
+}
+
+cJSON* json_engine::get_item(cJSON* obj, const char* item) {
+    return cJSON_GetObjectItem(obj, item);
+};
+
+char* json_engine::print_item(cJSON* obj) {
+    return cJSON_Print(obj);
+};
+
+bool json_engine::cmp_item(cJSON* obj, const char* item) {
+    auto obj_item = this->print_item(obj);
+    return strncmp(obj_item+1, item, std::min(strlen(item), strlen(obj_item)-2)) == 0;
+};
+
+} // namespace sgx
+} // namespace grpc
diff --git a/src/cpp/sgx/sgx_ra_tls_utils.h b/src/cpp/sgx/sgx_ra_tls_utils.h
new file mode 100644
index 0000000000..994e99eca2
--- /dev/null
+++ b/src/cpp/sgx/sgx_ra_tls_utils.h
@@ -0,0 +1,106 @@
+/*
+ *
+ * Copyright (c) 2022 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+#ifndef SGX_RA_TLS_UTILS_H
+#define SGX_RA_TLS_UTILS_H
+
+#include <string>
+#include <vector>
+#include <memory>
+#include <dlfcn.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <time.h>
+#include <sys/stat.h>
+
+#include "sgx_ra_tls_log.h"
+
+#define HEX_DUMP_SIZE   16
+#define MAX_ROW_SIZE    70
+
+namespace grpc {
+namespace sgx {
+
+#include "cjson/cJSON.h"
+
+class library_engine {
+    public:
+        library_engine();
+
+        library_engine(const char*, int);
+
+        ~library_engine();
+
+        void open(const char*, int);
+
+        void close();
+
+        void* get_func(const char*);
+
+        void* get_handle();
+
+    private:
+        void* handle;
+        char* error;
+};
+
+class json_engine {
+    public:
+        json_engine();
+
+        json_engine(const char*);
+
+        ~json_engine();
+
+        bool open(const char*);
+
+        void close();
+
+        cJSON* get_handle();
+
+        cJSON* get_item(cJSON* obj, const char* item);
+
+        char* print_item(cJSON* obj);
+
+        bool cmp_item(cJSON* obj, const char* item);
+
+    private:
+        cJSON* handle;
+};
+
+void check_free(void* ptr);
+
+template<typename T>
+void check_delete(T ptr);
+
+bool check_file(const char* file_path);
+
+bool hex_to_byte(const char* src, char* dst, size_t dst_size);
+
+void byte_to_hex(const char* src, char* dst, size_t src_size);
+
+std::string byte_to_hex(const char* src, size_t src_size);
+
+void print_hex_dump(const char *title, const char *prefix_str,
+                    const char *buf, int len);
+
+} // namespace sgx
+} // namespace grpc
+
+#endif // SGX_RA_TLS_UTILS_H
diff --git a/src/python/grpcio/grpc/__init__.py b/src/python/grpcio/grpc/__init__.py
index ea393c44c5..72c388f9d2 100644
--- a/src/python/grpcio/grpc/__init__.py
+++ b/src/python/grpcio/grpc/__init__.py
@@ -1735,7 +1735,6 @@ def ssl_server_credentials(private_key_certificate_chain_pairs,
                 for key, pem in private_key_certificate_chain_pairs
             ], require_client_auth))
 
-
 def xds_server_credentials(fallback_credentials):
     """Creates a ServerCredentials for use with xDS. This is an EXPERIMENTAL
       API.
@@ -1921,6 +1920,40 @@ def alts_server_credentials():
     return ServerCredentials(_cygrpc.server_credentials_alts())
 
 
+def sgxratls_channel_credentials(config_json, verify_option="two-way"):
+    """Creates a ChannelCredentials for use with an SGX-enabled Channel.
+
+    Args:
+      config_json: sgx_config_json
+      verify_option:
+        two-way verification: "two-way"
+        server verification: "server"
+        client verification: "client"
+
+    Returns:
+      A ChannelCredentials for use with an SGX-enabled Channel Credential.
+    """
+    return ChannelCredentials(
+        _cygrpc.channel_credentials_sgxratls(config_json, verify_option))
+
+
+def sgxratls_server_credentials(config_json, verify_option="two-way"):
+    """Creates a ServerCredentials for use with an SGX-enabled Server.
+
+    Args:
+      config_json: sgx_config_json
+      verify_option:
+        two-way verification: "two-way"
+        server verification: "server"
+        client verification: "client"
+
+    Returns:
+      A ServerCredentials for use with an SGX-enabled Server Credential.
+    """
+    return ServerCredentials(
+      _cygrpc.server_credentials_sgxratls(config_json, verify_option))
+
+
 def compute_engine_channel_credentials(call_credentials):
     """Creates a compute engine channel credential.
 
@@ -2000,7 +2033,6 @@ def secure_channel(target, credentials, options=None, compression=None):
     return _channel.Channel(target, () if options is None else options,
                             credentials._credentials, compression)
 
-
 def intercept_channel(channel, *interceptors):
     """Intercepts a channel through a set of interceptors.
 
@@ -2146,6 +2178,8 @@ __all__ = (
     'local_server_credentials',
     'alts_channel_credentials',
     'alts_server_credentials',
+    'sgxratls_channel_credentials',
+    'sgxratls_server_credentials',
     'ssl_server_credentials',
     'ssl_server_certificate_configuration',
     'dynamic_ssl_server_credentials',
diff --git a/src/python/grpcio/grpc/_cython/_cygrpc/grpc.pxi b/src/python/grpcio/grpc/_cython/_cygrpc/grpc.pxi
index fb8ceae6a5..8de2f2c9e6 100644
--- a/src/python/grpcio/grpc/_cython/_cygrpc/grpc.pxi
+++ b/src/python/grpcio/grpc/_cython/_cygrpc/grpc.pxi
@@ -435,7 +435,6 @@ cdef extern from "grpc/grpc.h":
 
   grpc_slice grpc_dump_xds_configs() nogil
 
-
 cdef extern from "grpc/grpc_security.h":
 
   # Declare this as an enum, this is the only way to make it a const in
@@ -640,7 +639,7 @@ cdef extern from "grpc/grpc_security.h":
   ctypedef struct grpc_alts_credentials_options:
     # We don't care about the internals (and in fact don't know them)
     pass
- 
+
   grpc_channel_credentials *grpc_alts_credentials_create(
     const grpc_alts_credentials_options *options)
   grpc_server_credentials *grpc_alts_server_credentials_create(
@@ -651,7 +650,96 @@ cdef extern from "grpc/grpc_security.h":
   void grpc_alts_credentials_options_destroy(grpc_alts_credentials_options *options)
   void grpc_alts_credentials_client_options_add_target_service_account(grpc_alts_credentials_options *options, const char *service_account)
 
+  ctypedef enum grpc_tls_server_verification_option:
+    GRPC_TLS_SERVER_VERIFICATION
+    GRPC_TLS_SKIP_HOSTNAME_VERIFICATION
+    GRPC_TLS_SKIP_ALL_SERVER_VERIFICATION
+    GRPC_RA_TLS_CLIENT_VERIFICATION
+    GRPC_RA_TLS_SERVER_VERIFICATION
+    GRPC_RA_TLS_TWO_WAY_VERIFICATION
+
+  ctypedef struct grpc_tls_error_details:
+    pass
+
+  ctypedef struct grpc_tls_identity_pairs:
+    pass
+
+  ctypedef struct grpc_tls_certificate_provider:
+    pass
+
+  ctypedef struct grpc_tls_credentials_options:
+    pass
+
+  ctypedef struct grpc_tls_server_authorization_check_arg:
+    pass
+
+  ctypedef struct grpc_tls_server_authorization_check_config:
+    pass
+
+  grpc_tls_identity_pairs* grpc_tls_identity_pairs_create();
+
+  void grpc_tls_identity_pairs_add_pair(grpc_tls_identity_pairs* pairs,
+                                        const char* private_key,
+                                        const char* cert_chain);
+
+  void grpc_tls_identity_pairs_destroy(grpc_tls_identity_pairs* pairs);
+
+  grpc_tls_certificate_provider* grpc_tls_certificate_provider_static_data_create(
+    const char* root_certificate, grpc_tls_identity_pairs* pem_key_cert_pairs);
 
+  grpc_tls_certificate_provider* grpc_tls_certificate_provider_file_watcher_create(
+    const char* private_key_path, const char* identity_certificate_path,
+    const char* root_cert_path, unsigned int refresh_interval_sec);
+
+  void grpc_tls_certificate_provider_release(
+      grpc_tls_certificate_provider* provider);
+
+  grpc_tls_credentials_options* grpc_tls_credentials_options_create()
+
+  void grpc_tls_credentials_options_set_cert_request_type(
+    grpc_tls_credentials_options* options,
+    grpc_ssl_client_certificate_request_type type);
+
+  void grpc_tls_credentials_options_set_server_verification_option(
+    grpc_tls_credentials_options* options,
+    grpc_tls_server_verification_option server_verification_option);
+
+  void grpc_tls_credentials_options_set_certificate_provider(
+    grpc_tls_credentials_options* options,
+    grpc_tls_certificate_provider* provider);
+
+  void grpc_tls_credentials_options_watch_root_certs(
+    grpc_tls_credentials_options* options);
+
+  void grpc_tls_credentials_options_set_root_cert_name(
+    grpc_tls_credentials_options* options, const char* root_cert_name);
+
+  void grpc_tls_credentials_options_watch_identity_key_cert_pairs(
+    grpc_tls_credentials_options* options);
+
+  void grpc_tls_credentials_options_set_identity_cert_name(
+    grpc_tls_credentials_options* options, const char* identity_cert_name);
+
+  void grpc_tls_credentials_options_set_server_authorization_check_config(
+    grpc_tls_credentials_options* options,
+    grpc_tls_server_authorization_check_config* config);
+
+  grpc_tls_server_authorization_check_config* grpc_tls_server_authorization_check_config_create(
+    const void* config_user_data,
+    int (*schedule)(void* config_user_data,
+                    grpc_tls_server_authorization_check_arg* arg),
+    void (*cancel)(void* config_user_data,
+                   grpc_tls_server_authorization_check_arg* arg),
+    void (*destruct)(void* config_user_data));
+
+  void grpc_tls_server_authorization_check_config_release(
+    grpc_tls_server_authorization_check_config* config);
+
+  grpc_channel_credentials* grpc_tls_credentials_create(
+    grpc_tls_credentials_options* options);
+
+  grpc_server_credentials* grpc_tls_server_credentials_create(
+    grpc_tls_credentials_options* options);
 
 cdef extern from "grpc/compression.h":
 
@@ -696,6 +784,11 @@ cdef extern from "grpc/impl/codegen/compression_types.h":
 
 
 cdef extern from "grpc/grpc_security_constants.h":
+
   ctypedef enum grpc_local_connect_type:
     UDS
     LOCAL_TCP
+
+
+cdef extern from "src/core/lib/iomgr/error.h":
+  const grpc_error* GRPC_ERROR_CANCELLED
diff --git a/src/python/grpcio/grpc/_cython/_cygrpc/sgx_ra_tls.pxd.pxi b/src/python/grpcio/grpc/_cython/_cygrpc/sgx_ra_tls.pxd.pxi
new file mode 100644
index 0000000000..408bd0216d
--- /dev/null
+++ b/src/python/grpcio/grpc/_cython/_cygrpc/sgx_ra_tls.pxd.pxi
@@ -0,0 +1,47 @@
+# Copyright (c) 2022 Intel Corporation
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+from libcpp.vector cimport vector as cppvector
+from libcpp.string cimport string as cppstring
+
+cdef extern from "grpcpp/security/sgx/sgx_ra_tls.h" namespace "grpc::sgx":
+  struct mrs_context:
+    pass
+
+cdef extern from "grpcpp/security/sgx/sgx_ra_tls.h" namespace "grpc::sgx":
+  cdef void grpc_sgx_ra_tls_parse_config "grpc::sgx::ra_tls_parse_config"(mrs_context);
+
+cdef extern from "grpcpp/security/sgx/sgx_ra_tls.h" namespace "grpc::sgx":
+  cdef void grpc_sgx_ra_tls_parse_config_json "grpc::sgx::ra_tls_parse_config"(const char *);
+
+cdef extern from "grpcpp/security/sgx/sgx_ra_tls.h" namespace "grpc::sgx":
+  cdef void grpc_sgx_ra_tls_verify_init "grpc::sgx::ra_tls_verify_init"();
+
+cdef extern from "grpcpp/security/sgx/sgx_ra_tls.h" namespace "grpc::sgx":
+  cdef cppvector[cppstring] grpc_sgx_ra_tls_generate_key_cert "grpc::sgx::ra_tls_generate_key_cert"(int)
+
+cdef extern from "grpcpp/security/sgx/sgx_ra_tls.h" namespace "grpc::sgx":
+  cdef int grpc_sgx_ra_tls_auth_check_schedule "grpc::sgx::ra_tls_auth_check_schedule"(
+    void *, grpc_tls_server_authorization_check_arg *);
+
+cdef class SGXChannelCredentials(ChannelCredentials):
+  cdef grpc_tls_identity_pairs *c_pairs
+
+  cdef grpc_tls_certificate_provider *c_provider
+
+  cdef grpc_tls_credentials_options *c_options
+
+  cdef grpc_tls_server_authorization_check_config *c_check_config
+
+  cdef grpc_channel_credentials *c(self) except *
diff --git a/src/python/grpcio/grpc/_cython/_cygrpc/sgx_ra_tls.pyx.pxi b/src/python/grpcio/grpc/_cython/_cygrpc/sgx_ra_tls.pyx.pxi
new file mode 100644
index 0000000000..f33fe71600
--- /dev/null
+++ b/src/python/grpcio/grpc/_cython/_cygrpc/sgx_ra_tls.pyx.pxi
@@ -0,0 +1,142 @@
+# Copyright (c) 2022 Intel Corporation
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+cdef class SGXChannelCredentials(ChannelCredentials):
+
+  def __cinit__(self,
+                const char* config_json,
+                grpc_tls_server_verification_option verify_option):
+    # parse sgx ra tls config json
+    grpc_sgx_ra_tls_parse_config_json(config_json)
+
+    # tls credentials options
+    self.c_options = grpc_tls_credentials_options_create()
+
+    # tls certificate provider
+    is_dummy = verify_option == GRPC_RA_TLS_SERVER_VERIFICATION
+    cdef cppvector[cppstring] cpp_key_crt = grpc_sgx_ra_tls_generate_key_cert(is_dummy)
+
+    self.c_pairs = grpc_tls_identity_pairs_create();
+
+    grpc_tls_identity_pairs_add_pair(
+      self.c_pairs, cpp_key_crt[0].c_str(), cpp_key_crt[1].c_str())
+
+    self.c_provider = grpc_tls_certificate_provider_static_data_create(NULL, self.c_pairs);
+
+    grpc_tls_credentials_options_set_certificate_provider(self.c_options, self.c_provider)
+
+    # grpc_tls_credentials_options_watch_root_certs(self.c_options)
+
+    grpc_tls_credentials_options_watch_identity_key_cert_pairs(self.c_options)
+
+    grpc_tls_credentials_options_set_cert_request_type(
+      self.c_options, GRPC_SSL_REQUEST_AND_REQUIRE_CLIENT_CERTIFICATE_BUT_DONT_VERIFY)
+
+    grpc_tls_credentials_options_set_root_cert_name(self.c_options, "")
+
+    grpc_tls_credentials_options_set_identity_cert_name(self.c_options, "")
+
+    # authorization check
+    grpc_sgx_ra_tls_verify_init()
+
+    grpc_tls_credentials_options_set_server_verification_option(
+      self.c_options, verify_option)
+
+    self.c_check_config = grpc_tls_server_authorization_check_config_create(
+      NULL, grpc_sgx_ra_tls_auth_check_schedule, NULL, NULL)
+
+    grpc_tls_credentials_options_set_server_authorization_check_config(
+      self.c_options, self.c_check_config)
+
+  def __dealloc__(self):
+    if self.c_provider != NULL:
+      grpc_tls_certificate_provider_release(self.c_provider)
+      self.c_provider = NULL
+
+    if self.c_check_config != NULL:
+      grpc_tls_server_authorization_check_config_release(self.c_check_config)
+      self.c_check_config = NULL
+
+  cdef grpc_channel_credentials *c(self) except *:
+    return grpc_tls_credentials_create(self.c_options)
+
+
+def channel_credentials_sgxratls(config_json, verify_option):
+  config_json = bytes(config_json, encoding = "ascii")
+  cdef grpc_tls_server_verification_option c_verify_option = GRPC_RA_TLS_TWO_WAY_VERIFICATION
+  if verify_option == "server":
+    c_verify_option = GRPC_RA_TLS_SERVER_VERIFICATION
+  elif verify_option == "client":
+    c_verify_option = GRPC_RA_TLS_CLIENT_VERIFICATION
+  else:
+    pass
+  return SGXChannelCredentials(config_json, c_verify_option)
+
+def server_credentials_sgxratls(config_json, verify_option):
+  # parse sgx ra tls config json
+  config_json = bytes(config_json, encoding = "ascii")
+  grpc_sgx_ra_tls_parse_config_json(config_json)
+
+  # tls credentials options
+  cdef grpc_tls_credentials_options *c_options = grpc_tls_credentials_options_create()
+
+  # tls certificate provider
+  is_dummy = verify_option == GRPC_RA_TLS_CLIENT_VERIFICATION
+  cdef cppvector[cppstring] cpp_key_crt = grpc_sgx_ra_tls_generate_key_cert(is_dummy)
+
+  cdef grpc_tls_identity_pairs *c_pairs = grpc_tls_identity_pairs_create();
+
+  grpc_tls_identity_pairs_add_pair(
+    c_pairs, cpp_key_crt[0].c_str(), cpp_key_crt[1].c_str())
+
+  grpc_tls_credentials_options_watch_identity_key_cert_pairs(c_options)
+
+  # grpc_tls_credentials_options_watch_root_certs(c_options)
+
+  cdef grpc_tls_certificate_provider *c_provider = \
+    grpc_tls_certificate_provider_static_data_create(NULL, c_pairs);
+
+  grpc_tls_credentials_options_set_certificate_provider(c_options, c_provider)
+
+  grpc_tls_credentials_options_set_cert_request_type(
+    c_options, GRPC_SSL_REQUEST_AND_REQUIRE_CLIENT_CERTIFICATE_BUT_DONT_VERIFY)
+
+  grpc_tls_credentials_options_set_root_cert_name(c_options, "")
+
+  grpc_tls_credentials_options_set_identity_cert_name(c_options, "")
+
+  # authorization check
+  grpc_sgx_ra_tls_verify_init()
+
+  cdef grpc_tls_server_verification_option c_verify_option = GRPC_RA_TLS_TWO_WAY_VERIFICATION
+  if verify_option == "server":
+    c_verify_option = GRPC_RA_TLS_SERVER_VERIFICATION
+  elif verify_option == "client":
+    c_verify_option = GRPC_RA_TLS_CLIENT_VERIFICATION
+  else:
+    pass
+
+  grpc_tls_credentials_options_set_server_verification_option(
+    c_options, c_verify_option)
+
+  cdef grpc_tls_server_authorization_check_config *c_check_config = \
+    grpc_tls_server_authorization_check_config_create(NULL, grpc_sgx_ra_tls_auth_check_schedule, NULL, NULL)
+
+  grpc_tls_credentials_options_set_server_authorization_check_config(
+    c_options, c_check_config)
+
+  # credentials
+  cdef ServerCredentials credentials = ServerCredentials()
+  credentials.c_credentials = grpc_tls_server_credentials_create(c_options)
+  return credentials
diff --git a/src/python/grpcio/grpc/_cython/cygrpc.pxd b/src/python/grpcio/grpc/_cython/cygrpc.pxd
index 166be37022..85bb630f4b 100644
--- a/src/python/grpcio/grpc/_cython/cygrpc.pxd
+++ b/src/python/grpcio/grpc/_cython/cygrpc.pxd
@@ -52,3 +52,6 @@ include "_cygrpc/aio/callback_common.pxd.pxi"
 include "_cygrpc/aio/call.pxd.pxi"
 include "_cygrpc/aio/channel.pxd.pxi"
 include "_cygrpc/aio/server.pxd.pxi"
+
+# Following pxi files are part of the SGX
+include "_cygrpc/sgx_ra_tls.pxd.pxi"
diff --git a/src/python/grpcio/grpc/_cython/cygrpc.pyx b/src/python/grpcio/grpc/_cython/cygrpc.pyx
index b958975bb8..eda6fb16c7 100644
--- a/src/python/grpcio/grpc/_cython/cygrpc.pyx
+++ b/src/python/grpcio/grpc/_cython/cygrpc.pyx
@@ -81,6 +81,8 @@ include "_cygrpc/aio/call.pyx.pxi"
 include "_cygrpc/aio/channel.pyx.pxi"
 include "_cygrpc/aio/server.pyx.pxi"
 
+# Following pxi files are part of the SGX
+include "_cygrpc/sgx_ra_tls.pyx.pxi"
 
 #
 # initialize gRPC
